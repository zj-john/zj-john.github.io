[{"title":"如何开发一个Form","date":"2020-06-21T01:01:15.000Z","path":"notes/ckboi6xf500008ktyc5b16q6u.html","text":"背景Form是前端开发中使用频率最高的元素之一，也是变化最复杂的组件之一。 Form虽然从结果上看，是表单内容的填写+验证+提交，但在此过程中还是有很多变化的。例如表单内容之间的联动，非常规表单内容的组合展示，复杂验证等等。 如何更快速的完成一个Form的编码是前端工程师不断关注和努力的方向之一。 最近工作中遇到一个较为复杂的Form，输入项有六七十个，联动极多。Form中还穿插着表格等其他组件的展示。 对如何写好这个form，做了一些思考，列在本文中。 调研常见的几种方式： Form内容的叠加 描述：这种方式最简单直接，把所有的输入项平铺在Form中，所见即所得。 优点：便于调试，逻辑相对简单，无学习成本 缺点：缺少封装，缺少拆分，不利于扩展。如果是大型Form，一个文件过大，而拆分又会增加非常大的复杂度 JSON-SCHEME 描述：充分利用了Form键值对的本质，把所有Form内容抽象为一个JSON的数据，通过JSON动态渲染Form 优点：封装性好，修改简单，便于扩展 缺点：得到的JSON配置文件会很大，增加了阅读难度，不利于调试，有学习成本 可视化搭建 描述：这可能是比较高级的方案，利用Form组件的常规性，把常用的输入项封装为物料，直接拖拽生成Form。 优点：构建UI上应该是最快速的，而且修改也很简单。甚至可以把这一搭建工作交给产品或设计。 缺点：平台需要提前搭好和维护，且只适合于内部逻辑不复杂的Form。一旦逻辑变得复杂，后续开发成本变得更高。 没有哪种方案是最好的，只有更合适的。 针对我目前的项目，很巧合，从需求1.1到1.3都有一个Form的开发，1.1采用的是第一种叠加方式，1.2采用的是第二种SCHEME的方式。我目前在做的是1.3的需求。由于1.3的Form更加复杂，在参考了上面2种开发方式后，最终采取了比较折衷的方案。 整体思路原型-&gt; 基础配置文件 -&gt; 扩充配置文件，完成逻辑开发 从原型生成基础配置看一眼原型，写一部分代码的方式很繁琐，而且特别低效。来回切换搞得开发思路短路，而且眼疼。 但偏偏Form的性质又是最适合这种方式的，每一个字段的名称，描述，验证，备注都需要一点点的搬运。 所以根据原型，先写一个config，后续的开发工作就变成了基于config文件的逻辑开发。 举个例子： 比如上面这个简易的Form模型，我们根据模型可以得到这样一个config内容。 默认所有显示出来的字段都是必填的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const formConfig = [ &#123; key: 'name', formKey: 'name', label: '姓名', rules: [ &#123; required: true, message: '字段必填' &#125; ], render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; return &lt;Input placeholder=\"请填写姓名\" /&gt; &#125; &#125;, &#123; key: 'sex', formKey: 'sex', label: '性别', rules: [ &#123; required: true, message: '字段必填' &#125; ], render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; return &lt;Select placeholder=\"请选择性别\" /&gt; &#125; &#125;, &#123; key: 'age', formKey: 'age', label: '年龄', rules: [ &#123; required: true, message: '字段必填' &#125; ], render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; return &lt;Input type=\"number\" placeholder=\"请填写年龄\" /&gt; &#125; &#125;, &#123; key: 'idCardNum', formKey: 'idCardNum', label: 'ID', rules: [ &#123; required: true, message: '字段必填' &#125; ], show: (&#123;parentForm, defaultData&#125;)=&gt;&#123; const age = this.getCurrentValueByKey(parentForm, defaultData, 'age'); if(age &gt; 16) return true; return false; &#125; render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; return &lt;Input placeholder=\"请填写身份证号\" /&gt; &#125; &#125;, &#123; key: 'isMarried', formKey: 'isMarried', label: '婚否', rules: [ &#123; required: true, message: '字段必填' &#125; ], show: (&#123;parentForm, defaultData&#125;)=&gt;&#123; const age = this.getCurrentValueByKey(parentForm, defaultData, 'age'); const sex = this.getCurrentValueByKey(parentForm, defaultData, 'sex'); if(age &gt; 22 &amp;&amp; sex === 'W') return true; if(age &gt; 24 &amp;&amp; sex === 'M') return true; return false; &#125; render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; return &lt;Select placeholder=\"请选择是否结婚\" /&gt; &#125; &#125;, &#123; key: 'summary', formKey: 'summary', span: FULL_WIDTH label: '汇总', render:(&#123;parentForm, mode, defaultData&#125;)=&gt;&#123; const name = this.getCurrentValueByKey(parentForm, defaultData, 'name'); const sex = this.getCurrentValueByKey(parentForm, defaultData, 'sex'); const age = this.getCurrentValueByKey(parentForm, defaultData, 'age'); const idCardNum = this.getCurrentValueByKey(parentForm, defaultData, 'idCardNum'); const isMarried = this.getCurrentValueByKey(parentForm, defaultData, 'isMarried'); return &lt;SummaryTable data=&#123; age, sex, age, idCardNum, isMarried&#125; /&gt; &#125; &#125;] 字段说明 key: 适用于循环的唯一key值。 formKey: 在form中的key，可以是提交给后端的字段名。一个formKey可能对应多个key值，对应一个formKey的多种展示方式，但出于显示状态的只能是一个。 label:输入项标签。 labelWidth：输入项标签的宽度。 span：输入项组件的宽度。 hide：是否显示，目前定义的是function，也可以支持其它类型。 mode：展示模式，比如 edit/disabled/view。定义多种模式，便于切换编辑和查看。目前定义的是function，也可以支持其它类型 rules：正则规则 render：function,输出为要展示的内容。 其它： config中假设已经定义了一个getCurrentValueByKey的函数，表示从当前的form或defaultData中获取某个formKey的值。这个函数需要自己后面补充。 render中定义了函数的输入是一个object，包含的内容是 parentForm，mode，defaultData parentForm：当前form中的值 mode：目前的展示模式，可以根据这个值渲染不同内容 defaultData：form的默认值 定义了一个常量FULL_WIDTH，对展示宽度做定义 得到上面的config后，后续的开发就可以脱离原型了。 扩充config有了上面的config，剩下待做事项还有： 循环渲染。 每一个输入项的render中的组件，onchange的时候需要赋值给整个form，方便其他输入项使用 一个Form的简单模型如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;form ref=&#123;this.formRef&#125; &gt; &#123; this.formConfig.map(item =&gt; &#123; const currentForm = this.formRef.current; return ( &lt;FormItem key = &#123;item.formKey&#125; forItemKey = &#123;item.formKey&#125; label= &#123;item.label&#125; labelWidth = &#123; typeof item.labelWidth === 'number'?item.labelWidth: LABEL_WIDTH &#125; span =&#123;item.span?item.span:FORM_COLUMN_WIDTH.HALF&#125; hide=&#123;(&#123;parentForm, defaultData&#125;)=&gt;&#123; if(item.show instanceof Function) &#123; return !item.show(&#123;parentForm, defaultData&#125;); &#125; return false; &#125;&#125; mode =&#123; item.mode &amp;&amp; item.mode instanceof Function?item.mode(&#123;parentForm: currentForm, defaultData, mode&#125;):mode &#125; rules = &#123; item.rule instanceOf Function ? item.rule(&#123;parentForm: currentForm, defaultData&#125;):item.rule &#125; &gt; &#123; (&#123;currentForm, mode&#125;)=&gt;&#123; return item.render(&#123; parentForm:currentForm, mode, defaultData &#125;) &#125; &#125; &lt;/FormItem&gt; ) &#125;) &#125;&lt;/form&gt; 说明： 实际代码中使用的不是原生的form标签，而是一个封装的Form组件。Form中对FormItem组件中的onChange事件进行了统一的监听，然后添加了onSubmit/onReset/onValidation等一些钩子函数，可以做一些统一处理。 FormItem里面做了对样式的处理，还有validation验证失败时的一些统一处理，展示。 Demo后续会补充一个简单完整的Demo上来。 问题 form输入项很多时，config会非常大，需要拆分 Form和FormItem组件还可以做更多事情，以便减少config中的内容","tags":[{"name":"form","slug":"form","permalink":"https://zj-john.github.io/tags/form/"},{"name":"联动","slug":"联动","permalink":"https://zj-john.github.io/tags/联动/"},{"name":"组件","slug":"组件","permalink":"https://zj-john.github.io/tags/组件/"}]},{"title":"hash路由下，允许单路由跳过登录","date":"2020-04-30T12:36:38.000Z","path":"notes/ckbdbl42200482ktyek161dq1.html","text":"背景有个同事来问，在node层做sso登录验证的情况下，如果想让现有的一个路由绕过登录应该怎么做？ 要解决这个问题，先看一下目前的结构： 前端采用react全家桶构建SPA，使用hash路由。 在node层用koa做http server，验证登录，和做service转发（解决跨域） 原先的方式中，koa的第一个中间件函数就是验证SSO，也就是所有路由都会经过SSO验证通过后才会继续向下走。 之前部分代码node12345678910111213141516171819// 跳转到sso地址完成登录后，sso会返回一个key为ticket的query参数，根据这个ticket完成后续cookie的注册。这部分逻辑不用太关心app.use(async (ctx, next) =&gt; &#123; if (ctx.cookies.get(\"root_principal\")) &#123; await next(); &#125; else &#123; if (ctx.query[\"ticket\"] !== undefined) &#123; const ticket = ctx.query[\"ticket\"]; const principalId = sso.AppID + utils.randStr(); const is_sso_cookie_ok = await sso.has_sso_cookie_ok(ticket, principalId); if (is_sso_cookie_ok) &#123; ctx.cookies.set(\"root_principal\", principalId, &#123; \"expires\": utils.expireDate(7) &#125;); &#125; ctx.redirect(ctx.origin); &#125; else &#123; ctx.redirect(sso.LoginUrlPrefix + ctx.origin); &#125; &#125;&#125;) 页面1234567891011121314151617181920212223242526272829// routesconst Routes = [ &#123; path: \"/one\", component: ComponentOne &#125;, &#123; path: \"/two\", component: ComponentTwo &#125;, &#123; redirect: true, path: \"/\", to: \"/one\", &#125;];// 页面使用const switchRoutes = ( &lt;Switch&gt; &#123;Routes.map((prop, key) =&gt; &#123; if (prop.redirect) &#123; return &lt;Redirect from=&#123;prop.path&#125; to=&#123;prop.to&#125; key=&#123;key&#125; /&gt;; &#125; return &lt;Route path=&#123;prop.path&#125; component=&#123;prop.component&#125; key=&#123;key&#125; /&gt;; &#125;)&#125; &lt;/Switch&gt;); 几个误区通过node判断path因为是hash路由，对 website.com/#/one 这样的路由, 在node端只能收到根路由，hash的内容会被自动忽略掉。 其它方式代替hash进行判断因为hash路由不能被node识别，那么用node会接受的数据来判断呢？比如cookie。 在页面route切换的时候，通过document.cookie，种上标识路由的cookie。 这种方式node确实可以取到cookie值，但是 只有在浏览器第一次请求node的时候，之后的路由切换，都是在页面进行，根本不会发送请求到node层。 brower route页面全局路由从hash路由切换到brower路由，这样的话node就可以接收到每次请求的path，可以相对做处理。 但是这种方式侵入式较强，新的path有可能和已有的service的path冲突。这里不与采用。 之后的方式思路上面的误区中在思路上也有个误区，把对path的判断放在咋node层面。 这样的问题是，如果有path的调整，需要在node层也做同样的适配，不是一个可扩展性的做法。 所以新的思路： 页面route中添加bool类型的auth字段，标识是否需要登录 路由跳转时，当auth为true，且当前未登录（由Service返回状态）时，跳转到一个\\的组件 在route的跳转中，只支持组件，不支持链接地址 在Login组件中，用window.loaction.href跳转到/login地址 这里不带#号 跳到/login时，由node接管后面的登录服务，登录完成后，跳转到ctx.origin 下次路由时，已经是已登录状态，把路由交还给页面 node部分代码1234567891011121314151617181920212223242526272829303132333435// 跳转到sso地址完成登录后，sso会返回一个key为ticket的query参数，根据这个ticket完成后续cookie的注册。这部分逻辑不用太关心app.use(async (ctx, next) =&gt; &#123; if (ctx.path === '/' &amp;&amp; ctx.query[\"ticket\"] !== undefined) &#123; const ticket = ctx.query[\"ticket\"]; const principalId = sso.AppID + utils.randStr(); const is_sso_cookie_ok = await sso.has_sso_cookie_ok(ticket, principalId); if (is_sso_cookie_ok) &#123; ctx.cookies.set(\"root_principal\", principalId, &#123; \"expires\": utils.expireDate(7) &#125;); &#125; ctx.redirect(ctx.origin); &#125; else &#123; await next() &#125;&#125;)//getUserInfo可以获取当前登录人的信息，为null时表示为登录，这里用这个service验证当前是否登录app.use(async (ctx, next) =&gt; &#123; if (ctx.path === '/getUserInfo') &#123; const principalId = ctx.cookies.get(\"root_principal\"); const userInfo = await sso.getUserInfo(principalId); ctx.response.body = userInfo; &#125; else &#123; await next() &#125;&#125;)// 增加了对login的处理，返回一个sso的跳转地址// 这里在node层跳转，而不是在页面中直接跳转这个地址，是因为这个登录地址根据当前部署的环境不同会有区别，node层已经有了环境标识app.use(async (ctx, next) =&gt; &#123; if (ctx.path === '/login') &#123; ctx.redirect(sso.LoginUrlPrefix + ctx.origin); &#125; else &#123; await next() &#125;&#125;) 页面部分代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546// routesconst Routes = [ &#123; path: \"/one\", component: ComponentOne, auth: true &#125;, &#123; path: \"/two\", component: ComponentTwo, auth: false &#125;, &#123; redirect: true, path: \"/\", to: \"/one\", &#125;];//路由跳转 user是从node层获取当前登录用户的数据信息。如果为null，说明未登录。从context中传到组件中。const switchRoutes = (user) =&gt; ( &lt;Switch&gt; &#123;Routes.map((prop, key) =&gt; &#123; if (prop.redirect) &#123; return &lt;Redirect from=&#123;prop.path&#125; to=&#123;prop.to&#125; key=&#123;key&#125; /&gt;; &#125; return &lt;Route path=&#123;prop.path&#125; key=&#123;key&#125; render=&#123;() =&gt; &#123; if (user == null &amp;&amp; prop.auth) &#123; return &lt;Login /&gt; &#125; else &#123; return &lt;prop.component /&gt; &#125; &#125;&#125; /&gt;; &#125;)&#125; &lt;/Switch&gt;);//Login 组件class Login extends React.Component &#123; componentDidMount() &#123; window.location.href = \"/login\"; &#125; render() &#123; return (&lt;div&gt;正在跳转到登录页面...&lt;/div&gt;); &#125;&#125;","tags":[{"name":"hashrouter","slug":"hashrouter","permalink":"https://zj-john.github.io/tags/hashrouter/"},{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"auth","slug":"auth","permalink":"https://zj-john.github.io/tags/auth/"}]},{"title":"当升级到win10……","date":"2020-04-26T12:45:16.000Z","path":"tips/ckbdbl46000c92kty6iak3wh2.html","text":"服役多年的win7在一次重启后，蓝屏了……告别了win7，还来不及有迎接win10的喜悦，win10下的一些问题暴露了…… where is hosts安装win10后，原先driver下没有etc文件夹，也找不到熟悉的hosts文件了。 解决方法：找到cmd，选择用管理员帐户打开：输入以下命令1for /f %P in (&apos;dir %windir%\\WinSxS\\hosts /b /s&apos;) do copy %P %windir%\\System32\\drivers\\etc &amp; echo %P &amp; Notepad %P 当显示“已复制1个文件。”时即表示命令完成，同时将使用记事本打开 hosts 文件，此时 hosts 文件即恢复。 chrome80跨域安装了最新版本80后，使用原先72版本的方式跨域，发现未成功。 chrome72版本时：1&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; --disable-web-security --user-data-dir=&quot;c:\\chrome_kuayu&quot; 到了chrome80版本，虽然这样设置后，打开chrome显示熟悉的“不安全提示”，但是真正测试一个跨域应用时，发现并未成功，console中有如下warning提示： 1A cookie associated with a cross-site resource at http://XXXXX.com/ was set without the `SameSite` attribute. A future release of Chrome will only deliver cookies with cross-site requests if they are set with `SameSite=None` and `Secure`. You can review cookies in developer tools under Application&gt;Storage&gt;Cookies and see more details at https://www.chromestatus.com/feature/5088147346030592 and https://www.chromestatus.com/feature/5633521622188032. 这里表述说，未来的版本将对cookie的安全加强，如果想要跨域，需要新增SameSite的tag标识才可以。 但是这里说了是future，那现在应该只是试用了。 我们在chrome中输入1chrome://flags/ 看到当前浏览器支持配置的各个属性。 找到SameSite by default cookies，把它disable掉。之后访问就可以继续跨域访问了。 gulp2.7 &amp;&amp; node12最新安装的node12下，运行之前一个特别老的项目（gulp2.7运行），报错 1ReferenceError: primordials is not defined 在stackoverflow中找到了答案，虽然上面说在gulp3.9和node12的搭配下会产生这个问题，但实际验证下来，应该是有多个gulp版本有这个问题。 看下来是由于graceful-fs这个包的版本导致的问题（具体未查）。 解决方法： 利用npm的钩子，在安装之前安装graceful-fs 4.2.3。12345678910&#123; // Your current package.json &quot;scripts&quot;: &#123; // Your current package.json scripts &quot;preinstall&quot;: &quot;npx npm-force-resolutions&quot; &#125;, &quot;resolutions&quot;: &#123; &quot;graceful-fs&quot;: &quot;4.2.3&quot; &#125;&#125; Mysqlinstall 官网下载，解压到需要的目录，比如 c:\\mysql 这里提供的下载地址是免安装版 在安装MySQL程序的文件夹下创建一个data文件夹，用来存放数据库文件。使用记事本创建一个my.ini文件 设置my.ini 内容 12345678910111213141516171819202122232425262728293031323334353637383940414243[mysqld]# 设置端口3306（mysql的默认端口为3306）port=3306# 设置mysql的安装目录basedir=c:\\mysql# 设置mysql数据库的数据的存放目录datadir=c:\\mysql\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 设置mysql服务器使用的字符集，默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 进入安装目录下的bin文件夹，比如：c:\\mysql\\bin，启动CMD。执行初始化1mysqld --initialize --user=mysql --console 在返回的结果中，得到一个root帐户的初始密码 把mysql注册到windows的服务中，然后启动服务 12mysqld -installnet start mysql 使用刚才得到的初始密码，登录。并修改密码 1mysql -u root -p 修改密码：假设新密码是6666661ALTER USER USER() IDENTIFIED BY &apos;666666&apos;; 方便以后使用，把mysql命令加入环境变量 忘记root密码 先打开CMD命令窗口，停止mysql的服务 1net stop mysql 进行免密登录 1mysqld --console --skip-grant-tables --shared-memory 保持当前的窗口不动，新开一个CMD命令窗口，登录 1mysql -u root 修改密码把root的密码改为空 123use mysqlUPDATE mysql.user SET authentication_string=&apos;&apos; WHERE user=&apos;root&apos;;select host,user,authentication_string from mysql.user; 可以关闭之前的窗口了，打开一个新窗口把密码从空改为需要的值即可。参照安装时的密码修改 参考文档 https://github.com/google/google-api-javascript-client/issues/561 https://stackoverflow.com/questions/55921442/how-to-fix-referenceerror-primordials-is-not-defined-in-node","tags":[{"name":"chrome","slug":"chrome","permalink":"https://zj-john.github.io/tags/chrome/"},{"name":"win10","slug":"win10","permalink":"https://zj-john.github.io/tags/win10/"},{"name":"host","slug":"host","permalink":"https://zj-john.github.io/tags/host/"}]},{"title":"React16 ReactRouter5特性","date":"2020-04-24T12:36:38.000Z","path":"notes/ckbdbl42j005b2ktygq3b2mzy.html","text":"React.StrictModecreate-react-app建立的demo项目中，使用了React.StrictMode 123456ReactDOM.render( &lt;React.StrictMode&gt; &lt;Basic /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 特性 StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。 可以识别： 识别不安全的生命周期 关于使用过时字符串 ref API 的警告 关于使用废弃的 findDOMNode 方法的警告 检测意外的副作用 检测过时的 context API 可以看出，这是一个帮助你进行react升级的好工具。 Link以前的v2/v3版本1import &#123; Link &#125; from 'react-router' 从V4之后1import &#123; Link &#125; from 'react-router-dom' router以前123import &#123; hashHistory &#125; from 'react-router'const history = syncHistoryWithStore(hashHistory, store);&lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt; 现在12345678910111213141516171819202122232425import &#123; HashRouter as Router, Switch, Route, Link&#125; from \"react-router-dom\";ReactDOM.render( &lt;React.StrictMode&gt; &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Basic /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;Food /&gt; &lt;/Route&gt; &lt;Route path=\"/dashboard\"&gt; &lt;Hotel /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); webpackclean-webpack-plugin过去0.1.18/0.1.1912345const CleanWebpackPlugin = require('clean-webpack-plugin');new CleanWebpackPlugin(['*.*', 'js', 'scripts'], &#123; root: path.resolve(__dirname, './dist'), verbose: true&#125;) 现在^3.0.01234const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');new CleanWebpackPlugin(&#123; cleanAfterEveryBuildPatterns: ['build/home']&#125;) css-loader Webpacker only supports css-loader versions greater than 2.1.1, and less than 3.0.0. 持续补充中……","tags":[{"name":"react16","slug":"react16","permalink":"https://zj-john.github.io/tags/react16/"},{"name":"router","slug":"router","permalink":"https://zj-john.github.io/tags/router/"},{"name":"cssloader","slug":"cssloader","permalink":"https://zj-john.github.io/tags/cssloader/"}]},{"title":"微前端实践","date":"2020-04-24T07:59:34.000Z","path":"projects/ckbdbl46n00db2ktyo2l7flh5.html","text":"微前端微前端是2019年很火的一个话题，但是这个概念其实是2016年提出的。主要解决前端巨石项目的问题。 技术栈升级 独立开发/维护/测试（沙盒） 增量打包/发布 主要问题 路由处理 状态处理 打包/部署 CSS污染 框架single-spaqiankun技术实践步骤 采用不同子项目在同一个git仓库的方式 react基础应用 React16 + ReactRouter5 切割应用待做：通过脚本实现分离 独立成单独项目，拥有自己的package.json，webpack 创建3个子项目：npx create-react-app home/work/main 去除项目中的无关项，public目录是共有的，也去除。 为每个项目设置单独的webpack（你也可以使用不同的devserver方式和构建方式，推荐使用webpack） webpack及其插件，可以安装在最外层 各个框架适配 single-spa抛弃single-spa 挂载应用到不同的dom上 延伸每一个独立组件或者说JS的模块就是一个应用，用调用service的方法使用组件","tags":[{"name":"micro frontend","slug":"micro-frontend","permalink":"https://zj-john.github.io/tags/micro-frontend/"},{"name":"single-spa","slug":"single-spa","permalink":"https://zj-john.github.io/tags/single-spa/"},{"name":"qiankun","slug":"qiankun","permalink":"https://zj-john.github.io/tags/qiankun/"}]},{"title":"chrome，fetch发送请求时未传cookie","date":"2019-08-01T03:45:16.000Z","path":"tips/ckbdbl45w00bz2ktygrp826f3.html","text":"有一个工具碰到如下报障，转到我这里排查： 同一个web应用，在本地及大部分同事处调试良好，功能正常。但几个用户报障页面无数据，接口不能使用。 通过远程用户查看，发现后端获取数据的接口返回302。 背景：此项目是前后端分离，需要公司登录认证。前端经过认证后，埋下cookie，后端通过cookie二次校验是否登录。 从chrome dev tool 的network和抓包看，client确实没有把cookie传给后端。所以后端没有拿到登录信息，302到了登录页面。 但比较奇怪的是： get接口正常，cookie传给了后端 post接口，没有带cookie。 application面板看，cookie存在，且同源，且未过期。 因为报障用户的chrome版本是67，然后我本地的chrome67版本可以稳定复现故障现象，chrome69及以上版本则是好的。 初步确定是chrome版本差异导致的。 问题的思路转化为： chrome67 和 chrome69以上版本对cookie的处理有什么不同之处？ 查阅了相关文档后，并未发现在对cookie的处理上有什么改动。毕竟cookie这种东西，受http的制约，不太敢瞎搞。 那从项目代码入手， 前端请求接口使用的都是fetch，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940PostHttp = (url, data) =&gt; &#123; return new Promise(function (resolve, reject) &#123; fetch(url, &#123; body: JSON.stringify(data), // must match 'Content-Type' header method: 'POST', // *GET, POST, PUT, DELETE, etc. headers: &#123; 'content-type': 'application/json' &#125;, &#125;).then((response) =&gt; &#123; console.log(\"response\", response); let data = (response &amp;&amp; response.status === 200) ? response.json() : &#123; \"success\": false, \"msg\": `接口异常，状态码为$&#123;response.status&#125;` &#125;; resolve(data); &#125;).catch((error) =&gt; &#123; resolve(&#123; \"success\": false, \"msg\": `接口异常:$&#123;error&#125;` &#125;); &#125;) &#125;);&#125;;GetHttp = (url) =&gt; &#123; return new Promise(function (resolve, reject) &#123; fetch(url).then((response) =&gt; &#123; let data = (response &amp;&amp; response.status === 200) ? response.json() : &#123; \"success\": false, \"msg\": `接口异常，状态码为$&#123;response.status&#125;` &#125;; resolve(data); &#125;).catch((error) =&gt; &#123; resolve(&#123; \"success\": false, \"msg\": `接口异常:$&#123;error&#125;` &#125;); &#125;) &#125;);&#125;; fetch还是一个相对比较新的API，那问题转换为 在chrome67 和 chrome69以上版本对cookie的处理有什么不同之处？ 带着这些关键字一查找，还真的找到了文档上的一个细节： 在fetch文档sending cookie这一章节下，看到了如下信息： 所以在chrome67版本前后，credentials的默认值是不同的。 让工具开发在fetch中，把credentials的值完整的写上去，发布再测试后，问题解决。 参考文档 https://github.com/github/fetch#sending-cookies https://stackoverflow.com/questions/34558264/fetch-api-with-cookie https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch","tags":[{"name":"chrome","slug":"chrome","permalink":"https://zj-john.github.io/tags/chrome/"},{"name":"fetch","slug":"fetch","permalink":"https://zj-john.github.io/tags/fetch/"},{"name":"cookie","slug":"cookie","permalink":"https://zj-john.github.io/tags/cookie/"}]},{"title":"从Webpack到Parcel","date":"2018-12-04T02:04:53.000Z","path":"notes/ckbdbl42p005i2ktywwvqbaoi.html","text":"过去的一年中，您可能听过Parcel，一个新的构建工具。对于那些还没有接触过它的人，Parcel将自己描述为 “一个Web应用程序打包器，利用多核处理提供极快的性能，并且需要零配置”。现在构建工具很丰富，特别是有像Webpack和Browserify这样的优秀工具。所以为什么我们需要一个新工具Parcel？ 原因因为Webpack不适用于初学者。即使只做一些基础功能，比如对Sass/SCSS、ES6、浏览器前缀的处理，代码压缩、hash命名，dev-server等，也需要在webpack中进行大量配置，而且每种配置的可选值也多到连作者都说不清（这个梗是在GitHub上看到webpack作者回复的一个issue）。 说实话，虽然用了很久的webpack，但每次开新项目或修改配置，我还是会回到文档查询。因为要记的东西太多了，离开文档无法存活…… 为了解决这些问题，于是有了parcel。 parcel极速零配置Web应用打包工具。 极速打包：Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。 将你所有的资源打包：Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。 零配置代码分拆：使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。 自动转换：如若有需要，Babel, PostCSS, 和PostHTML甚至 node_modules 包会被用于自动转换代码. 热模块替换：Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。 友好的错误日志：当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题。 从这些特性看，文件缓存系统这个功能还是挺好的，对比webpack的每次启动实在是太慢了。后面的这些都像是webpack的语法糖。对于不太在乎打包性能的，比如内部工具来说，是一个比较便捷的方式。但对于性能要求高的外部应用，还是用webpack去做优化配置更好一些。 转换前下面，我们将采用一个典型的Webpack设置，其中包含前面提到的所有插件，然后我们将其换成Parcel。 让我们看一下 webpack.config.js 文件，评估下将要转换的内容：1234567891011121314151617181920212223242526272829303132333435module.exports = &#123; entry: &#123; main: './src/js/main.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash].js' &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: \"babel-loader\" &#125; &#125;, &#123; test: /\\.s[c|a]ss$/, use: ['style-loader', MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader'] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin('dist', &#123;&#125;), new MiniCssExtractPlugin(&#123; filename: 'style.[contenthash].css', &#125;), new HtmlWebpackPlugin(&#123; inject: false, hash: true, template: './src/html/index.html', filename: 'index.html' &#125;), new WebpackMd5Hash() ]&#125;; 除了安装webpack和webpack-cli之外，我们还必须安装以下依赖项：autoprefixer，babel-core，babel-loader，babel-preset-env，clean-webpack-plugin，css-loader，extract-text-webpack-plugin，html-webpack-plugin，mini-css-extract-plugin，node-sass，postcss-loader，sass-loader，style-loader和webpack-md5-hash。我还需要设置一个 postcss.config.js 文件，以便浏览器前缀可以工作。 看吧，为了实现一些基础功能，我们已经需要进行大量配置了。 转换为了与我们的Webpack设置保持一致，我们希望Parcel设置能够处理以下事情： Sass/SCSS; Babel; Vendor Prefixing; Code Minification; Cache-Busting/Hashing; Live Server whipping-uppering. 要怎么做？首先，我们安装Parcel。1npm install -g parcel-bundler 这里进行全局安装，以便我们运行parcel命令时无需包含整个文件路径。 如果您愿意，可以选择省略-g并在项目内部进行本地安装。此时，需要在终端Node中运行 node_modules/parcel-bundler/bin/ cli.js. 然后我去创建了一个初始项目结构，如下所示：1234/dist/src/js/script.js/src/scss/styles.scssIndex.html 我进入项目根目录并在终端中运行12//无命令界面，以默认方式创建npm init -y 创建 package.json 文件我把一些初始代码放在 script.js 和 styles.scss 中作为测试代码。没有什么太花哨的：我在 script.js 中创建了一个const，看它是否会被编译成var，并编写了一些非常基本的嵌套SCSS代码，看它是否会被编译成CSS。 js:12const msg = \"HelloWorld\"alert(msg); css:12345body &#123; h1 &#123; color: red &#125;&#125; Parcel会从index.html中的脚本开始，编译它找到的代码。 所以在我们的情况下，我在index.html中有以下内容 123456&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello, Parcel!&lt;/h1&gt; &lt;script src=\"src/js/script.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后我从终端运行了parcel index.html。几秒钟后，Parcel将一些文件编译到/dist目录并在端口1234启动了本地服务器。 请注意，此时我们并没有运行npm install,目录下也没有node_module目录，但是已经可以运行了 打开浏览器并转到localhost:1234，可以看到一切正常！我检查了编译后的脚本文件（它还有一个哈希后缀来处理缓存清除），并且可以看到const确实已经变成了var。 因此，在我没有配置任何东西的情况下，Parcel已经生成一个本地服务器，使用Babel将ES6代码转换为ES5，甚至处理文件hash。 我们可以通过简单地在命令的末尾添加-open来让Parcel打开你的默认浏览器并加载页面。 css部分下面，我们在script.js文件的顶部添加了import ‘../scss/styles.scss’。123import '../scss/styles.scss'const msg = \"HelloWorld\"alert(msg); 为了使scss生效，我们首先安装node-sass。在终端上运行1npm install node-sass 然后运行parcel index.html，此时效果已经有了。 此时，dist文件夹中包含用于HTML，CSS和JS单独的文件 ，Parcel使用了895ms来编译所有内容，这非常快速！ 浏览器前缀我在我的SCSS中添加了一个::placeholder标记，看看会发生什么。1234567&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello, Parcel!&lt;/h1&gt; &lt;input placeholder=\"我是绿色的\"/&gt; &lt;script src=\"src/js/script.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; css12345678body &#123; h1 &#123; color: red &#125; &#125;input::placeholder &#123; color: green;&#125; 此时编译的CSS代码不包含任何前缀。我们所要做的就是在项目的根目录中包含.postcssrc文件，并在其中包含以下内容：12345&#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: true &#125;&#125; 我再次运行parcel index.html，检查输出的css文件，::placeholder现在有一堆浏览器前缀的样式。 这里有一个问题，如果把input::placeholder写在body中，在编译的css中还是没有前缀。是因为scss中，autoprefixer有另外的用法呢还是其它，待考究。 您可能会想，为什么Parcel在没有 .babelrc 文件的情况下使用Babel，但需要一个 .postcssrc 文件来处理浏览器前缀。这是因为Parcel已预先为具有超过1％市场份额的浏览器配置了Babel编译代码。所以只有当你需要为某些小众浏览器开发时，才需要一个.babelrc文件。 打包下面，我们进行打包。1parcel build index.html 打包后，所有的文件都被压缩了。 这里有个问题，打包后的目录如果不更改的话，输出也在dist中，这样dist里就有了2种文件，一种是打包的，一种是非打包的。而且没有明确的命名或其它方式来做区分。如果直接上传dist目录，会导致上传的内容大于实际需要的（虽然在资源请求中不会被用到） 结论最终，使用Parcel，我们只需要以下2个配置，就处理了Webpack处理的所有内容 npm install node-sass; a .postcssrc file. 综上，Parcel对于加快开发过程非常棒，让我专注于构建内容而不是配置设置。而且它在编译时也比Webpack快很多！ 不过，我们不应舍弃Webpack。默认情况下，Webpack尝试尽可能地扩展，而Parcel默认为您提供许多最常用的功能。快速使用是一方面，了解我们正在使用的工具做了什么也是非常重要的一方面，特别是在优化时。 资源 parcel：https://parceljs.org/ webpack -&gt; parcel：https://logrocket.com/blog/switching-to-parcel-from-webpack/ Other Demo：https://alligator.io/tooling/parcel/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.11.30","slug":"2018-11-30","permalink":"https://zj-john.github.io/tags/2018-11-30/"},{"name":"webpack","slug":"webpack","permalink":"https://zj-john.github.io/tags/webpack/"},{"name":"parcel","slug":"parcel","permalink":"https://zj-john.github.io/tags/parcel/"}]},{"title":"一次JS代码的Code Golf","date":"2018-12-03T05:05:02.000Z","path":"notes/ckbdbl417002p2ktyliacbcrp.html","text":"Code Golf的目标是尽可能地减小程序的大小。这里是一个简单的示例。 通过本文的5个主要阶段缩减代码，您可以简单了解下在Code Golf中用到的主要技术。 出发以下代码是使用画布绘制一个黑色方块，并使其从左向右移动。我们将从这块代码入手进行缩减 123456789101112131415161718192021222324252627282930313233// Retrieve the canvas and its contextlet canvas = document.getElementById('c');let ctx = canvas.getContext('2d');// Set the canvas sizecanvas.width = 100;canvas.height = 100;// Variable to store the x position of the squarelet x = 0;// Main function that draws the square and moves itloop();function loop() &#123; // Clear the canvas, so we can draw on it later ctx.clearRect(0, 0, canvas.width, canvas.height); // Change the position of the square if (x &gt; canvas.width) &#123; // If it's gone too far, move it to the far left x = -20; &#125; else &#123; // Otherwise, move it slightly to the right x = x + 2; &#125; // Draw the black square at the position x ctx.fillRect(x, 20, 20, 20); // Call the loop function about 60 times per second requestAnimationFrame(loop);&#125; 现在，除去注释，一共有344个字符。你觉得最终能缩减到多少呢？ 第1阶段：基础知识让我们从一些基础部分开始缩短代码： 关键字let在本代码中不是必需的，因此我们将其删除。 减少所有变量名称的长度，例如canvas变为c。 在loop()函数中，我们用值100替换c.width以及c.height。 用三元运算符代替if-else。 为了保持本文中的代码可读，删除空格，分号和空行将在最后操作。 通过这些更改，新代码如下。1234567891011121314c = document.getElementById('c');t = c.getContext('2d');c.width = 100;c.height = 100;x = 0;loop();function loop() &#123; t.clearRect(0, 0, 100, 100); x = (x &gt; 100) ? -20 : x + 2; t.fillRect(x, 20, 20, 20); requestAnimationFrame(loop);&#125; 字符数：从344到247。 第2阶段：DOM和Canvas技巧经过一些搜索后，我发现了3个与DOM和Canvas相关的技巧，这些技巧会使代码显著缩短。 第一个是关于getElementById()。事实证明根本没有必要使用这个函数，因为Javascript会自动为每个带有id的HTML元素创建变量。因此，要访问具有id=&quot;c&quot;的画布，我们可以直接使用该变量c。 第二个技巧是requestAnimationFrame()。这是一个很好的功能，每秒刷新画布约60次，但输入也很长。所以，我们可以使用setInterval()。它们工作原理基本相同，但后者要短得多。 最后一招是关于clearRect()。有一种方法不用clearRect()也可以清除画布，就是通过设置画布的大小。因此，如果我们把c.width = 100直接放在loop()函数内部，画布将在每一次循环时被清除。 这是具有3个技巧的新代码。 1234567891011t = c.getContext('2d');x = 0;setInterval(loop, 20);function loop() &#123; c.width = 100; c.height = 100; x = (x &gt; 100) ? -20 : x + 2; t.fillRect(x, 20, 20, 20);&#125; 让我们用匿名函数替换loop()。123456789t = c.getContext('2d');x = 0;setInterval(() =&gt; &#123; c.width = 100; c.height = 100; x = (x &gt; 100) ? -20 : x + 2; t.fillRect(x, 20, 20, 20);&#125;, 20); 字符数量：从247到154。 第3阶段：新的变量如果我们以更智能的方式使用变量，可以节省一些字符。以下是一些想法： 第一次setInterval()调用时，它返回值1（不一定）。我们可以利用这个来直接初始化变量，比如x用x = setInterval(...)。 可以一次分配多个变量。例如：c.width = c.height = 100。 变量t （画布的上下文）仅在我们使用t.fillRect(...)时使用过一次。这意味着我们不需要这个变量，而应该直接写c.getContext(&#39;2d&#39;).fillRect(...)。 12345x = setInterval(() =&gt; &#123; c.width = c.height = 100; x = (x &gt; 100) ? -20 : x + 2; c.getContext('2d').fillRect(x, 20, 20, 20);&#125;, 20); 我们还应该做两件事： 我们在代码中使用了5次20。如果我们给20设置一个变量k，就可以避免这种重复。 同样的，100使用了2次，我们用w变量替代。 这两个更改实际上使代码稍长。但很快，当我们删除空格和分号时，这些修改将变得有价值。123456k = 20;x = setInterval(() =&gt; &#123; w = c.width = c.height = 100; x = (x &gt; w) ? -k : x + 2; c.getContext('2d').fillRect(x, k, k, k);&#125;, k); 字符数：从154到141。 第4阶段：合并行在Javascript中分配变量时，将返回变量本身的值。例如，当 k = 20时,我们设置 k为20，我们也返回值20。我们可以使用这个事实将两行组合成一行，就像这样。123456// Beforek = 20;x = setInterval(/* ... */, k);// Afterx = setInterval(/* ... */, k = 20); 使用相同的想法，我们合并这两行，并删除变量w。 123456// Beforew = c.width = c.height = 100;x = (x &gt; w) ? -k : x + 2;// Afterx = (x &gt; (c.width = c.height = 100)) ? -k : x + 2; 还有这两行。123456// Beforex = (x &gt; (c.width = c.height = 100)) ? -k : x + 2;c.getContext('2d').fillRect(x, k, k, k);// Afterc.getContext('2d').fillRect(x = (x &gt; (c.width = c.height = 100)) ? -k : x + 2, k, k, k); 现在我们的匿名函数包含一行代码。123x = setInterval(() =&gt; &#123; c.getContext('2d').fillRect(x = (x &gt; (c.width = c.height = 100)) ? -k : x + 2, k ,k, k);&#125;, k = 20); 字符数：从141到126。 第五阶段：最后的技巧如果我们仔细阅读setIterval()文档，我们会发现第一个参数可以是函数也可以是字符串。1234x = setInterval( \"c.getContext('2d').fillRect(x = (x &gt; (c.width = c.height = 100)) ? -k : x + 2, k ,k, k);\", k = 20); 这看起来很奇怪，但它正常。最后，我们应该： 删除所有空格和换行符，因为它们都是可选的。 删除两个不必要的分号。 从三元运算符中删除一对不需要的括号。 更改100为99，节省一个字符。 这是最终的结果：1x=setInterval(&quot;c.getContext(&apos;2d&apos;).fillRect(x=x&gt;(c.width=c.height=99)?-k:x+2,k,k,k)&quot;,k=20) 字符数：从126到89。 原始代码有344个字符。现在，相同的结果，它几乎要小4倍！ HTML到目前为止我们只讨论过Javascript，那HTML呢？ 这里是HTML和Javascript的代码，只有119个字符。为了便于阅读，我添加了一些换行符。 1234&lt;canvas id=c&gt;&lt;script&gt; x=setInterval(\"c.getContext('2d').fillRect(x=x&gt;(c.width=c.height=99)?-k:x+2,k,k,k)\",k=20)&lt;/script&gt; 如果将这个代码保存在HTML文件中并在浏览器中打开它，您将看相同的结果。 结论从344个字符到89个字符是一个迷人的旅程。很多次我以为“没有办法再缩短”，但结果我总是错的。要确信代码可以更小。 这里的示例是一个为了缩减代码而做的极端，很多点在真实场景中量力使用。 资源 原文：https://www.lesscake.com/code-golf-javascript Code_golf：https://en.wikipedia.org/wiki/Code_golf GitHub：https://github.com/lesscake/code-golf-javascript","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"code golf","slug":"code-golf","permalink":"https://zj-john.github.io/tags/code-golf/"},{"name":"JS","slug":"JS","permalink":"https://zj-john.github.io/tags/JS/"},{"name":"2018.11.30","slug":"2018-11-30","permalink":"https://zj-john.github.io/tags/2018-11-30/"}]},{"title":"Electron再见, Desktop PWAs你好","date":"2018-11-21T02:36:50.000Z","path":"notes/ckbdbl41u003t2ktyv3hq14ap.html","text":"Chrome v70最近的公告最新的Chrome版本（v70）增加了Linux和Windows上对Desktop Progressive Web应用程序（DPWA）的支持，这令人兴奋。下图是Chrome具体的支持列表。 列表里没有MacOS，不过不用担心，Chrome V72中应该会添加这一支持。 请注意，虽然默认情况下MacOS不提供此功能，但可通过Chrome的功能标记启用。要启用这些标记，只需打开Chrome，并转到chrome://flags或直接转到Desktop PWAs的选项chrome://flags/#enable-desktop-pwas。启用任意功能标记后记得重启Chrome生效。 什么是渐进式Web应用程序（PWA）？这里我们不会深入介绍PWA，您可以阅读Google的文档来学习。如果想查看一些丰富的示例并了解在Android的Chrome，iOS的Safari（部分支持）上使用PWA的感觉，可以阅读这些示例。 什么是Electron？Electron 是一个允许开发人员使用Javascript，HTML和CSS构建跨平台桌面应用的平台。它是一种替代方案，降低了Web应用开发人员创建桌面程序的门槛，也让一些优秀的Javascript库和框架有了新的应用领域。基于Electron的桌面应用程序十分风靡，Slack，VSCode，Atom和Discord等项目在Electron开发方面都投入了大量资金。如果您还没有使用过这些服务，请试一试。 桌面应用程序一向以笨重的和过时的UI被人诟病，Electron的出现为桌面领域带来了一缕清泉！ 为什么选择桌面PWAs？尽管Electron应用程序越来越多，并且它们的实现与Web应用程序的实现接近，但它们仍然存在一些缺点。首先，Electron应用程序附带了他们自己的Chromium二进制文件。我们知道运行Chrome是很费内存的，同时使用多个Electron应用程序对内存简直是个灾害。如果您有所怀疑，可以在您的机器上打开多个Electron应用程序，然后通过您的活动监视器监视下内存的使用。除了对内存的大量耗费导致效率低下外，许多Electron应用程序还需要与NodeJS对接的额外的Electron代码接口，并且不一定与其相应的Web应用程序相同。通过必须管理对旧版本和软件更新管道的支持，Electron还需要额外的复杂性。 Abundant use of RAM is not only inefficient, but many Electron applications require additional Electron specific code interfaces with NodeJS and is not necessarily the same as it’s corresponding web application. Electron also requires additional complexity by having to manage support for older versions and software update pipelines. [桌面电脑输入]。想象一个世界，您可以利用电子应用程序的外观和感觉，而无需冗长的安装，软件更新，所有这些都在运送单个Web应用程序时。Chrome似乎正在为桌面电路板设置此行为的标准。当您访问Chrome中的网页并且该应用程序符合所有条件时，开发人员可以提示用户在其桌面上安装该应用程序。提示符如下所示：[Desktop PWAs enter]. Imagine a world where you could leverage the look and feel of an Electron Application, without requiring lengthy installs, software updates, all while shipping a single web application. Chrome seems to be setting the standard for this behavior in Desktop PWAs. When you visit a webpage in Chrome and the application meets all the criteria, the developer has the ability to prompt the user to install the application on their desktop. The prompt looks something like this: 只有在浏览器触发窗口事件“beforeinstallprompt”后，开发人员才能显示此提示。一旦安装，这个应用程序将通常成为用户桌面上的应用程序图标。This prompt can be shown at the developers discretion only after the window event ‘beforeinstallprompt’ is fired by the browser. Once installed, this application will usually become an application icon on users desktop. 启动这个新安装的应用程序后，您将获得一个新的最小浏览器窗口，其外观和感觉就像一个真正的桌面应用程序。 我的游乐场示例 My Playground ExampleDesktop PWAsProof of Concept when implementing Desktop PWAs www.desktop-pwas.com supercycle91/desktop-pwasExperimenting with Desktop PWAs. Contribute to supercycle91/desktop-pwas development by creating an account on GitHub. github.com上面的快照是我汇总的一个简单的概念证明，向您展示如何开始使用Desktop PWA。要安装它，请确保已启用桌面PWA功能标志，并且您在我的站点上处于活动状态至少30秒。请务必注意，测试Desktop PWA时有多个要求。如果您想要下载我的存储库，请按照桌面PWA清单进行操作，但这里有一个快速摘要：The snapshots above are a simple proof of concept I have put together to show you how you can get started with Desktop PWAs. To install it, be sure you enabled the desktop PWA feature flag and you are active on my site for at least 30 seconds. It is important to note that there are multiple requirements when testing Desktop PWAs. If you would like to pull down my repository, please follow the Desktop PWA checklist but here is a quick summary: 必须安装一个具有至少一个提取处理程序的Service Worker 必须通过HTTPS提供 Must have an installed Service Worker with at least one fetch handler 必须提供有效的manifest.json 页面必须是响应式的 其他例子如果您当前使用的是MacOS，许多应用程序并未假设您已启用桌面PWA功能标记，因此不会提示您进行安装。通过在Chrome中启用一些正确的标记，以及在Chrome Devtools控制台中进行精明的编码，您可以使用现有的PWA并让它们立即安装。以下是我能够在桌面上安装的一些现有PWA。If you are currently on MacOS, many applications are not assuming you have the Desktop PWA feature flag enabled and thus do not prompt you to install. With some correct flag enabling in Chrome, and savvy coding in Chrome Devtools Console, you can take existing PWAs and have them prompt to install. Here are some existing PWAs I have been able to install on my desktop. 星巴克星巴克在创建一个伟大的PWA方面投入了大量资金。虽然不是我常用的东西，但桌面安装的版本确实令人印象深刻。Starbucks have invested heavily in creating a great PWA. Although not something I frequent, the Desktop installed version is really impressive. Google Maps这个应用真的很酷。非常轻巧且高效。反应迅速。获取Google地图的诀窍是强行加载移动网站。This app is really cool. Very lightweight and gets the job done. Responsive and quick. The trick to getting Google maps is to force load the Mobile site. TwitterTwitter确实为手机上的Twitter PWA设置了很好的基线，安装的桌面版本对它们的实现非常有益。Twitter has really been setting great baselines for the Twitter PWA on mobile, the installed desktop version is a great compliment to their implementation. 后记随着桌面电路板的所有嗡嗡声，理解标准仍处于初期阶段是明智之举。正在发展和变化，包括：With all the buzz around Desktop PWAs, it is wise to understand the standards are still in it’s infancy. Developments and changes are being made including things such as:深度链接：打开Chrome中的链接以触发已安装的应用程序而不是Chrome。Deep Linking: Opening links in Chrome to trigger the installed application instead of in Chrome.图标徽章：类似于通过应用程序图标标记的移动应用程序通知。Icon badging: Similar to a mobile application notification badging over the application icon.键盘快捷键：能够在已安装的应用程序中侦听使用本机键盘快捷键。Keyboard Shortcuts: Ability to listen to use native keyboard shortcuts inside the installed application.一旦成熟，我看到许多今天的Electron应用程序找到了台式电路板的重要竞争对手。Once maturation, I see many of today’s Electron applications finding a serious competitor with Desktop PWAs. 资源 Resourcessupercycle91/desktop-pwasExperimenting with Desktop PWAs. Contribute to supercycle91/desktop-pwas development by creating an account on GitHub. github.com Progressive Web Apps | Web | Google DevelopersProgressive Web Apps are now supported on the desktop! developers.google.com Desktop Progressive Web Apps | Web | Google DevelopersProgressive Web Apps work on the desktop, including Chrome OS, Mac, Linux, and Windows. developers.google.com Progressive Web App Checklist | Web | Google DevelopersA checklist which breaks down all the things we think it takes to be a baseline progressive web app, and how to take it… developers.google.com Lighthouse | Tools for Web Developers | Google DevelopersLearn how to set up Lighthouse to audit your web apps. developers.google.com 资源 原文 https://medium.com/dailyjs/goodbye-electron-hello-desktop-pwas-f316b8f39882 PWA https://developers.google.com/web/progressive-web-apps/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"Web Development","slug":"Web-Development","permalink":"https://zj-john.github.io/tags/Web-Development/"},{"name":"PWA","slug":"PWA","permalink":"https://zj-john.github.io/tags/PWA/"},{"name":"Desktop App","slug":"Desktop-App","permalink":"https://zj-john.github.io/tags/Desktop-App/"},{"name":"Electron","slug":"Electron","permalink":"https://zj-john.github.io/tags/Electron/"},{"name":"2018.11.16","slug":"2018-11-16","permalink":"https://zj-john.github.io/tags/2018-11-16/"}]},{"title":"The HTML Canvas Guide","date":"2018-11-14T04:58:02.000Z","path":"notes/ckbdbl43000672ktytgv5c5l9.html","text":"本文介绍一种可以在浏览器屏幕上绘画的方式，即Canvas API。在HTML中，canvas是一个标签：&lt;canvas&gt;，标识可以通过Canvas API绘画的元素。 新建canvas新建Canvas很简单，只要把&lt;canvas&gt;&lt;/canvas&gt;放到HTML文件中即可。 此时，你看不到任何内容，因为canvas是一个不可见的元素。让我们添加下边框。 因为Chrome中会自动给body元素添加一个8px的margin值，所以看起来我们的canvas边框像是一个frame，你可以通过css去除这个margin值。 123body &#123; margin: 0;&#125; 这里我们先暂时保持原样。 此时，我们的canvas元素就可以通过DOM API来选择了，这里我们使用document.querySelector(): 1const canvas = document.querySelector('canvas') 修改canvas的背景颜色在css中如下做：123canvas &#123; background-color: lightblue;&#125; 调整canvas大小可以在css中设置高度、宽度12345canvas &#123; border: 1px solid black; width: 100%; height: 100%;&#125; 以上代码使canvas充满整个外层元素。 如果canvas是html的第一个元素，将会充满整个body。 如果想充满整个窗口，则可以： 12canvas.width = window.innerWidthcanvas.height = window.innerHeight 如果在css中移除body的margin，并且设置背景颜色，则可以填充这个页面。 如果窗口大小变化，我们也需要重新计算canvas的宽高。可以使用debounce函数来避免过于频繁的重新计算（当你用鼠标调整窗口大小时，resize事件会执行成百上千次）：123456789101112const debounce = (func) =&gt; &#123; let timer return (event) =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(func, 100, event) &#125;&#125;window.addEventListener('resize', debounce(() =&gt; &#123; canvas.width = window.innerWidth canvas.height = window.innerHeight&#125;)) 获取canvas的上下文(context)我们想在canvas上画画，首先需要获取上下文 1const c = canvas.getContext('2d') 有时候把上下文变量设置为c,有时设置为ctx，都是“context”的简称 The getContext()方法根据传的类型参数返回一个绘画上下文。 可用的值有： 2d, 本文我们用这个值 webgl WebGL版本1 webgl2 WebGL版本2 bitmaprenderer 和ImageBitmap结合使用 根据上下文的类型，你可以给getContext()传递第二个参数来指定一些额外的选项。 在2d值下，我们有一个参数可以在所有浏览器中使用，alpha，默认值为true。如果设置为false，则浏览器认为canvas没有透明背景并且可以加快渲染速度。 开始绘画有了上下文后，我们就可以开始绘制了。 我们有一些绘画方法可供选择，而且我们可以绘制： text lines rectangles paths images对于每种类型，我们都可以执行填充，描框，渐变，样式，阴影，旋转，缩放等大量操作。 让我们最简单的画一个矩形开始。 可以使用fillRect(x, y, width, height)方法来完成： 1c.fillRect(100, 100, 100, 100) 上面代码会从(100,100)位置开始，画一个长宽都为100px的黑色矩形： 你可以通过给fillStyle()传一些css的颜色字符串，来给矩形填充不同的颜色：12c.fillStyle = 'white'c.fillRect(100, 100, 100, 100) 通过这些，你可以开始创造性的绘画了： 这种，123456for (let i = 0; i &lt; 60; i++) &#123; for (let j = 0; j &lt; 60; j++) &#123; c.fillStyle = `rgb($&#123;i * 5&#125;, $&#123;j * 5&#125;, $&#123;(i+j) * 50&#125;)` c.fillRect(j * 20, i * 20, 10, 10) &#125;&#125; 或者这种：123456for (let i = 0; i &lt; 60; i++) &#123; for (let j = 0; j &lt; 60; j++) &#123; c.fillStyle = `rgb($&#123;i * 5&#125;, $&#123;j * 5&#125;, $&#123;(i+j) * 50&#125;)` c.fillRect(j * 20, i * 20, 20, 20) &#125;&#125; 绘画元素就像上文提到的，你可以画很多图案： text lines rectangles paths images 我们只以矩形和文本为例执行对应的一些操作，您可以在此处找到所需的所有其他API 。 修改颜色可以通过fillStyle和strokeStyle属性来修改填充和边框的颜色，它们都接受css颜色，包括字符串和RGB等:12c.strokeStyle = `rgb(255, 255, 255)`c.fillStyle = `white` 矩形 clearRect(x, y, width, height) fillRect(x, y, width, height) strokeRect(x, y, width, height) 我们上一节中已经见过fillRect() 。strokeRect()的调用方式和它类似，但它不是填充矩形，而是使用当前笔触样式绘制笔划（样式可以使用strokeStyle属性更改）：1234567const c = canvas.getContext('2d')for (let i = 0; i &lt; 61; i++) &#123; for (let j = 0; j &lt; 61; j++) &#123; c.strokeStyle = `rgb($&#123;i * 5&#125;, $&#123;j * 5&#125;, $&#123;(i+j) * 50&#125;)` c.strokeRect(j * 20, i * 20, 20, 20) &#125;&#125; clearRect()把一块区域设置为透明: Text绘制文字和矩形类似，有以下2个方法： fillText(text, x, y) strokeText(text, x, y) x和y是相对于canvas画布左下角的值。 你可以使用canvas的font属性改变字体和大小: 1c.font = '148px Courier New' 下面是更改的与文本相关的其他属性（* 是默认值）： textAlign (start*, end, left, right, center) textBaseline (top, hanging, middle, alphabetic*, ideographic, bottom) direction (ltr, rtl, inherit*) Lines要绘制一条线，首先调用beginPath()方法，然后用moveTo(x, y)提供一个起点，然后调用lineTo(x, y)来画线。最后调用stroke()： 1234c.beginPath()c.moveTo(10, 10)c.lineTo(300, 300)c.stroke() 线将根据c.strokeStyle得属性值进行着色。 一个复杂点的例子这段代码生成了800个粒子： 每个粒子都包含在canvas中，它的半径是随机的。 当你调整窗口大小时，元素会重绘。 你可以在Codepen上运行代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const canvas = document.querySelector('canvas')canvas.width = window.innerWidthcanvas.height = window.innerHeightconst c = canvas.getContext('2d')const circlesCount = 800const colorArray = [ '#046975', '#2EA1D4', '#3BCC2A', '#FFDF59', '#FF1D47']const debounce = (func) =&gt; &#123; let timer return (event) =&gt; &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(func, 100, event) &#125;&#125;window.addEventListener('resize', debounce(() =&gt; &#123; canvas.width = window.innerWidth canvas.height = window.innerHeight init()&#125;))const init = () =&gt; &#123; for (let i = 0; i &lt; circlesCount; i++) &#123; const radius = Math.random() * 20 + 1 const x = Math.random() * (innerWidth - radius * 2) + radius const y = Math.random() * (innerHeight - radius * 2) + radius const dx = (Math.random() - 0.5) * 2 const dy = (Math.random() - 0.5) * 2 const circle = new Circle(x, y, dx, dy, radius) circle.draw() &#125;&#125;const Circle = function(x, y, dx, dy, radius) &#123; this.x = x this.y = y this.dx = dx this.dy = dy this.radius = radius this.minRadius = radius this.color = colorArray[Math.floor(Math.random() * colorArray.length)] this.draw = function() &#123; c.beginPath() c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false) c.strokeStyle = 'black' c.stroke() c.fillStyle = this.color c.fill() &#125;&#125;init() 另一个例子：在canvas上设置动画元素基于上面的示例，我们通过循环函数为元素设置动画。每个圆圈都有自己的“生命”，并在画布的边界内移动。到达边界时，它会反弹： 我们使用requestAnimationFrame()，在迭代渲染每帧时稍微移动图像来实现这个效果。 与canvas上的元素交互下面扩展上面的示例，使用户允许使用鼠标和粒子进行交互。 当您悬停在画布时，鼠标附近的粒子将会变大，当您移动到其他位置时，它们将恢复正常： 这要怎么实现呢？首先，我们使用2个变量跟踪鼠标的位置： 1234567let mousex = undefinedlet mousey = undefinedwindow.addEventListener('mousemove', (e) =&gt; &#123; mousex = e.x mousey = e.y&#125;) 然后我们在Circle的update()方法中，使用这些变量来确定粒子的半径是否应该变大（或减小）： 12345if (mousex - this.x &lt; distanceFromMouse &amp;&amp; mousex - this.x &gt; -distanceFromMouse &amp;&amp; mousey - this.y &lt; distanceFromMouse &amp;&amp; mousey - this.y &gt; -distanceFromMouse) &#123; if (this.radius &lt; maxRadius) this.radius += 1&#125; else &#123; if (this.radius &gt; this.minRadius) this.radius -= 1&#125; distanceFromMouse是一个像素（设置为200）值，它定义了我们希望粒子对鼠标做出反应的范围。 性能如果您尝试在上面的示例中添加更多粒子和移动元素，您可能会发现性能问题。浏览器会消耗大量资源来渲染画布的动画和交互，因此请注意你的代码可能在性能较差的机器上失去良好体验。 特别是当我尝试使用表情文字替代粒子时，我遇到了一些问题，我发现渲染文本需要更多的资源，因此界面会很快变得迟钝。 MDN上给出了许多有关性能的提示，可以供参考。 结语本文只是对canvas的简单介绍，利用它，你可以在页面上创造更多可能性，和构建令人惊叹的效果。 资源 原文：https://flaviocopes.com/canvas/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"html","slug":"html","permalink":"https://zj-john.github.io/tags/html/"},{"name":"2018.11.09","slug":"2018-11-09","permalink":"https://zj-john.github.io/tags/2018-11-09/"},{"name":"canvas","slug":"canvas","permalink":"https://zj-john.github.io/tags/canvas/"}]},{"title":"超越console.log","date":"2018-11-13T02:52:02.000Z","path":"notes/ckbdbl40z002b2ktyer1jhq11.html","text":"调试JavaScript不止是用console.log输出一些值。这话听起来，感觉我要推荐一些调试器了，但实际上不会。 使用浏览器的单步调试功能很酷，而且你肯定会在某个时间用到。不过，大部分时间，你只是想知道代码的某一部分是否执行或者变量是什么，而不用深入到某个代码库的核心部分。 尽管如此，虽然console.log有用，但很多人并没有意识到它console下有很多超越log的选择。适当使用这些功能可以使调试更容易，更快速，更直观。 console.log虽然大多数人都以console.log(object)这种方式使用它，你也可以这样做console.log(object, otherObject, string)，它会将它们都整齐地记录下来。 更重要的是，还有另一种格式：console.log(msg, values)。这非常类似于C或PHP中的sprintf方法。 1console.log('I like %s but I do not like %s.', 'Skittles', 'pus'); 将完全按照您的预期输出。1&gt; I like Skittles but I do not like pus. 常见的占位符是%o（字母o，而不是零）代替对象，%s代替字符串，%d代替一个十进制或整数。 另一个有趣的是%c，它的情况有所不同，因为它实际上是CSS值的占位符。1console.log('I am a %cbutton', 'color: white; background-color: orange; padding: 2px 5px; border-radius: 2px'); 这些样式会用到其后面的任何内容上，而且可以不用“结束标记”，这有点奇怪。 当然也可以使用。 它不优雅，也不是特别有用。当然，这不是一个真正的按钮。 console.dir在大多数情况下，虽然console.dir()看起来和log()有点不同，但实际功能非常类似。 按下小箭头将显示与console.log相同的对象细节。 不过，当你输出内容是元素时，这种分歧更加剧烈，更有趣。 1let element = document.getElementById('2x-container'); 这是log的输出： 这里我们可以清楚地浏览DOM及其元素。 但是console.dir(element)的输出完全不同。 它以更加客观的方式来查看元素。 console.warn它可能是log()最直接的替代品，您可以以完全相同的方式使用console.warn()。唯一真正的区别是输出带了黄色。具体来说，是输出了处于警告而不是信息级别的信息，因此浏览器将稍微区别对待它，这使其在杂乱输出中带有更明显的效果。 但是，有一个更大的优势。由于输出是警告而不是信息，因此您可以过滤掉所有内容console.log并仅保留console.warn。这对于偶尔会在浏览器中输出大量无用内容的应用程序尤其有用。 console.tableconsole.table()功能旨在以一种更整洁的显示表格数据的方式展示原始对象数组。 例如，这是一个数据列表。123456789101112131415161718192021const transactions = [&#123; id: \"7cb1-e041b126-f3b8\", seller: \"WAL0412\", buyer: \"WAL3023\", price: 203450, time: 1539688433 &#125;, &#123; id: \"1d4c-31f8f14b-1571\", seller: \"WAL0452\", buyer: \"WAL3023\", price: 348299, time: 1539688433 &#125;, &#123; id: \"b12c-b3adf58f-809f\", seller: \"WAL0012\", buyer: \"WAL2025\", price: 59240, time: 1539688433 &#125;]; 如果我们使用console.log ，我们会得到如下不太有用的信息：1▶ (3) \\[&#123;…&#125;, &#123;…&#125;, &#123;…&#125;\\] 点击小箭头可以让你打开具体信息，当然，但这并不是我们想要的“一目了然”。 这时，console.table(data)更有帮助。 第二个参数是可选的，表示您想要展示的列。显然默认为所有列，但我们也可以这样做。1&gt; console.table(data, [\"id\", \"price\"]); 我们得到了只显示id和价格的输出。这适用于过大的，只需要展示一些细节的对象。索引列是自动创建的，并且据我所知不会消失。 这里注意，列是可以排序的。 另外，console.table() 只能处理最多1000行，因此可能不适合所有数据集。 console.assert另一个很有用的函数是assert()，它和log()的功能类似，但仅在第一个参数为假的情况下。如果第一个参数为真，它什么都不做。【断言】 这对于有循环（或几个不同的函数调用），但只有一个特定行为需要显示的情况特别有用。基本上它等同于下面的代码。123if (object.whatever === 'value') &#123; console.log(object); &#125; 澄清一下，这里说的“相同”，实际上是相反。因为你需要反转条件，为false时才输出。 让我们假设时间戳中有一个值是null或0。这要识别出来，不然会搞砸我们的日期格式化。1console.assert(tx.timestamp, tx); 当任何有效的数据传过来时，它只会跳过去。但是当0或null传入时会触发我们的日志记录，因为对应的值是false。 有时我们想要更复杂的条件。例如，我们已经看到了用户WAL0412数据的问题，所以只想显示来自它们的交易。这是直观的解决方案。 1console.assert(tx.buyer === 'WAL0412', tx); 这看起来正确，但不起作用。请记住，条件必须是假的…我们要 断言，而不是 过滤 。1console.assert(tx.buyer !== 'WAL0412', tx); 这才是我们想要的。 console.countcount是一个计数器，可选择作为一个命名计数器。1234567891011for(let i = 0; i &lt; 10000; i++) &#123; if(i % 2) &#123; console.count('odds'); &#125; if(!(i % 5)) &#123; console.count('multiplesOfFive'); &#125; if(isPrime(i)) &#123; console.count('prime'); &#125;&#125; 这段代码有点抽象，没有实际用处。此外，我不打算演示这个isPrime函数，我们假装它有效。我们得到的是如下列表：1234567891011odds: 1 odds: 2 prime: 1 odds: 3 multiplesOfFive: 1 prime: 2 odds: 4 prime: 3 odds: 5 multiplesOfFive: 2 ... 这对于您只是转储索引，或者您希望保留一个（或多个）运行计数的情况很有用。您也可以直接使用console.count()，无需参数。这样做默认叫做default。如果您愿意，还可以使用console.resetCount()重置计数器。 console.trace这个函数很难用简单的数据进行演示。因为它擅长的是当你在类或库中试图找出一个真正导致问题的调用者时。 例如，可能有12个不同的组件调用服务，但其中一个组件没有正确设置依赖关系。1234567891011export default class CupcakeService &#123; constructor(dataLib) &#123; this.dataLib = dataLib; if(typeof dataLib !== 'object') &#123; console.log(dataLib); console.trace(); &#125; &#125; ...&#125; console.log()这里将告诉我们传递的dataLib的内容是什么，而不是在哪里。但是，堆栈跟踪将非常清楚地告诉我们是new CupcakeService(false)导致的错误，在Dashboard.js这个文件下。 console.time用于跟踪操作所用时间的专用函数console.time()，它是跟踪JavaScript执行所用时间的更好方法。123456789101112131415function slowFunction(number) &#123; var functionTimerStart = new Date().getTime(); // something slow or complex with the numbers. // Factorials, or whatever. var functionTime = new Date().getTime() - functionTimerStart; console.log(`Function time: $&#123; functionTime &#125;`);&#125;var start = new Date().getTime();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;var time = new Date().getTime() - start;console.log(`Execution time: $&#123; time &#125;`); 这是一种老式的方法。 让我们看看新的。 123456789101112const slowFunction = number =&gt; &#123; console.time('slowFunction'); // something slow or complex with the numbers. // Factorials, or whatever. console.timeEnd('slowFunction');&#125;console.time();for (i = 0; i &lt; 100000; ++i) &#123; slowFunction(i);&#125;console.timeEnd(); 我们现在不再需要做任何数学运算或设置临时变量就能得到想要的时间了。 console.group现在我们可能学习的是控制台输出中最复杂和最高级的部分。group让你……好吧，分组。特别是它可以让你嵌套输出。它擅长显示代码中常用的结构。 12345678910111213// this is the global scopelet number = 1;console.group('OutsideLoop');console.log(number);console.group('Loop');for (let i = 0; i &lt; 5; i++) &#123; number = i + number; console.log(number);&#125;console.groupEnd();console.log(number);console.groupEnd();console.log('All done now'); 这比较粗糙，但你可以看到输出。 虽然不是很有用，但你可能会看到其中一些是如何组合在一起的。 12345678910111213141516class MyClass &#123; constructor(dataAccess) &#123; console.group('Constructor'); console.log('Constructor executed'); console.assert(typeof dataAccess === 'object', 'Potentially incorrect dataAccess object'); this.initializeEvents(); console.groupEnd(); &#125; initializeEvents() &#123; console.group('events'); console.log('Initialising events'); console.groupEnd(); &#125;&#125;let myClass = new MyClass(false); 上面有很多工作和用于调试信息的代码，这可能不是那么有用。但它仍然是一个有趣的想法，你可以看到它是如何更清晰使的展示上下文的日志记录。 最后一个内容，即console.groupCollapsed。它在功能上和console.group是相同的，区别是一个默认展开，一个默认折叠。 结论这里没有太多结论。如果您可能只需要比console.log(pet)多一点点，而不是调试器，所有这些方法都可能有用， 可能最有用的是console.table，但其它函数也有各自的适用场景。我喜欢用console.assert，因为可以在特定条件下调试的东西。 资源 原文：https://medium.com/@mattburgess/beyond-console-log-2400fdf4a9d8","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"2018.11.09","slug":"2018-11-09","permalink":"https://zj-john.github.io/tags/2018-11-09/"}]},{"title":"The Intl.RelativeTimeFormat API","date":"2018-11-01T03:46:38.000Z","path":"notes/ckbdbl42b004u2ktyiun94g68.html","text":"本文介绍一个2018标准的WEB API - Intl.RelativeTimeFormat，此API属于Intl对象,可以很方便和人性化的格式化时间的展示，特别是在要做国际化的站点上，尤其适用。不过此API目前默认情况下只在V8 v7.1.179和Chrome 71中可用，不过你可以尝尝鲜。 现代Web应用程序通常使用“昨天”，“42秒前”或“3个月”之类的短语，而不是完整日期和时间戳。这种 相对时间格式 已经变得如此普遍，以至于几个流行的库（包括Moment.js， Globalize和date-fns都实现了按本地习惯格式化时间这样的功能。 实现本地化相对时间格式化的一个问题是，您需要为要支持的每种语言提供习惯词或短语列表（例如“昨天”或“上一季度”）。虽然Unicode CLDR（通用语言环境数据仓库）提供此类数据，但您必须将其嵌入并与其他库一起才能使用它。遗憾的是，这不仅增加了包的大小，也对加载时间，解析/编译成本和内存消耗产生负面影响。 全新的Intl.RelativeTimeFormatAPI把这种负担转移到JavaScript引擎上，让JavaScript引擎来获取语言环境数据并供JavaScript开发人员直接使用。所以Intl.RelativeTimeFormat可以在不牺牲性能的情况下实现相对时间的本地格式化。 用法示例下面展示的是在英语环境下相对时间的格式化。12345678910111213141516171819202122232425const rtf = new Intl.RelativeTimeFormat('en'); rtf.format(3.14, 'second'); // → 'in 3.14 seconds' rtf.format(-15, 'minute'); // → '15 minutes ago' rtf.format(8, 'hour'); // → 'in 8 hours' rtf.format(-2, 'day'); // → '2 days ago' rtf.format(3, 'week'); // → 'in 3 weeks' rtf.format(-5, 'month'); // → '5 months ago' rtf.format(2, 'quarter'); // → 'in 2 quarters' rtf.format(-42, 'year'); // → '42 years ago' 需要注意的是，传递给Intl.RelativeTimeFormat构造函数的参数可以是一个标识BCP 47语言标签的字符串，也可以是一个次标注的语言标签数组。 以下是使用简体中文的示例：12345678910111213141516171819202122232425const rtf = new Intl.RelativeTimeFormat('zh-cmn-Hans-CN'); rtf.format(3.14, 'second'); // → \"3.14秒钟后\"rtf.format(-15, 'minute'); // → \"15分钟前\"rtf.format(8, 'hour'); // → \"8小时后\"rtf.format(-2, 'day'); // → \"2天前\" rtf.format(3, 'week'); // → \"3周后\"rtf.format(-5, 'month'); // → \"5个月前\"rtf.format(2, 'quarter'); // → \"2个季度后\"rtf.format(-42, 'year'); // → \"42年前\" 此外，Intl.RelativeTimeFormat构造函数还接受一个可选参数options，该参数可以对输出进行更细粒度的控制。为了说明灵活性，让我们根据默认设置英文查看更多输出：1234567891011121314151617181920212223242526// 这里option中的值就是默认的配置，只不过这里显示的展示出来。const rtf = new Intl.RelativeTimeFormat('en', &#123; localeMatcher: 'best fit', // other values: 'lookup' style: 'long', // other values: 'short' or 'narrow' numeric: 'always', // other values: 'auto' &#125;); // Now, let’s try some special cases! rtf.format(-1, 'day'); // → '1 day ago' rtf.format(0, 'day'); // → 'in 0 days' rtf.format(1, 'day'); // → 'in 1 day' rtf.format(-1, 'week'); // → '1 week ago' rtf.format(0, 'week'); // → 'in 0 weeks' rtf.format(1, 'week'); // → 'in 1 week' 您可能已经注意到，上面的格式化中生成了字符串&#39;1 day ago&#39;而不是 &#39;yesterday&#39;，还有&#39;in 0 weeks&#39;而不是&#39;this week&#39;。发生这种情况是因为默认情况下，格式化程序使用数值作为默认输出。 要更改此行为，请将numeric选项设置为&#39;auto&#39;（而不是隐式默认值 &#39;always&#39;）：12345678910111213141516171819const rtf = new Intl.RelativeTimeFormat('en', &#123; numeric: 'auto' &#125;); rtf.format(-1, 'day'); // → 'yesterday' rtf.format(0, 'day'); // → 'today' rtf.format(1, 'day'); // → 'tomorrow' rtf.format(-1, 'week'); // → 'last week' rtf.format(0, 'week'); // → 'this week' rtf.format(1, 'week'); // → 'next week' 和Intl类下的其它方法类似，Intl.RelativeTimeFormat也有format和formatToParts方法。虽然format涵盖了大部分常见的用例，但如果您需要访问输出的各个部分，用formatToParts则会很有帮助：123456789101112131415const rtf = new Intl.RelativeTimeFormat('en', &#123; numeric: 'auto' &#125;); rtf.format(-1, 'day'); // → 'yesterday' rtf.formatToParts(-1, 'day'); // → [&#123; type: 'literal', value: 'yesterday' &#125;] rtf.format(3, 'week'); // → 'in 3 weeks' rtf.formatToParts(3, 'week'); // → [&#123; type: 'literal', value: 'in ' &#125;, // &#123; type: 'integer', value: '3', unit: 'week' &#125;, // &#123; type: 'literal', value: ' weeks' &#125;] 有关其它选项及其行为的详细信息，请参阅提案库中的API文档。 最后Intl.RelativeTimeFormat默认情况下在V8 v7.1.179和Chrome 71中可用。随着此API变得更加广泛可用，诸如Moment.js， Globalize和date-fns之类的库，就可以使用更原生的相对时间格式化功能，这样即降低了对硬编码的CLDR数据库的依赖性，又可以提高加载时的性能，分析和编译时的性能，运行时的性能和内存的使用。 资源 原文 https://developers.google.com/web/updates/2018/10/intl-relativetimeformat Intl对象 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl API文档 https://github.com/tc39/proposal-intl-relative-time#api","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"},{"name":"Intl.RelativeTimeFormat","slug":"Intl-RelativeTimeFormat","permalink":"https://zj-john.github.io/tags/Intl-RelativeTimeFormat/"},{"name":"CLDR","slug":"CLDR","permalink":"https://zj-john.github.io/tags/CLDR/"}]},{"title":"如何减少JavaScript对页面加载时间的影响","date":"2018-10-30T02:52:02.000Z","path":"notes/ckbdbl424004d2ktydxch0bm0.html","text":"当我们为新客户，尤其是工程师客户宣传时，我们经常会遇到一个问题：GoSquared的JS代码将对网站性能有多大影响。 把GoSquared的一小段JS代码放到您的网页上，它就能为您提供分析，发现潜在顾客，实时聊天等功能。我们将所有这些功能集中在一个小代码段中，以使我们的客户能更轻松的使用它们。但是这可能会因为增加了额外的大小而使您的网站速度变慢，为此我们付出了很多努力来使我们的脚本尽可能快速轻量。 本文是我们在如何减少JS对页面加载时间影响的过程中学到的经验教训，您应该充分关注这些内容并将其应用到其他地方。 我们为什么要关注JavaScript的影响？ 网络变得越来越复杂，网站和Web应用程序的体验越来越丰富。随着越来越多的JS框架的兴起，构建这些丰富的体验比以往任何时候都更容易。 但这种丰富性和复杂性需要付出代价。提供这些体验需要添加额外的资源（脚本，样式表，图像，视频），它们中的每一个都会在用户的设备（CPU，GPU，内存，网络等）上消耗一定量的资源。 所有这些加起来构成了快速，友好与更慢，更令人沮丧体验之间的差异。由于页面加载速度慢是访问者放弃网站的主要原因之一，因此关注JS的影响非常重要。 确切地说，各种资源对最终用户的整体体验有多大差异取决于许多因素，比如不同类型的资源以不同的方式消耗不同的硬件，不同用户的设备性能也大不相同。 JavaScript很贵尽管如此，有一件事是清楚的：每字节都会消耗对应大小的流量。JavaScript是迄今为止最昂贵的资源，特别是对于低端和功率不足的设备 。它不仅消耗网络资源来下载文件，而且解析，编译和执行这些脚本都消耗内存和CPU，这些在移动设备上可能都特别短缺。 当您在您的网站或网络应用程序上安装我们的代码时，会添加额外的JavaScript消耗，因此，对我们来说，将用户体验的成本降至最低限度非常重要。简而言之，我们确保我们的脚本尽可能小而精简。 这并不像说个口号那么简单，而是要尽所有可能来削减字节，而不管其他任何成本。而且，这种优化更多的只针对我们的成本节约，而不是降低用户的体验。 这是我们在持续优化的工作，以保证JavaScript包足够小，不仅对包含它的任何页面的整体性能影响最小，也对我们的开发过程影响最小。 快速获胜：缩小，压缩，分发 互联网上的带宽不是无限的，而且光速意味着每当在很大的地理距离上发送数据时，延迟是不可避免的。 在减少网络消耗方面有一些快速的方法，且不必改变你的代码： 利用像Uglify或Closure这样的编译器 缩减 你的代码。这样既减少代码的大小，又不会缩减功能。 使用HTTP传输编码（如gzip或brotli）压缩 传输中的资源。大多数服务器或CDN（见下文）都支持设置一键启用此功能。 使用内容交付网络（CDN）分发您的静态资源，它支持从非常靠近访问者的物理位置为其提供服务。这可以减少下载资源时产生的延迟。 以上这些都是广泛使用，并且几乎是行业标准的实践。但重要的是去用它们，因为它们可以对用户的体验产生巨大影响。但它们在开发过程中也很容易忘记，因为如果在本地或在办公室中使用高速有线连接进行开发，它带来的网络效果不明显。 但这只是故事的第一部分。浏览器下载脚本后，还有几个步骤，这些步骤仍然有助于整体资源使用和页面速度。 解析，编译，执行大多数现代浏览器的JavaScript引擎实际运行脚本的方式大致可以简化为三个主要阶段：解析，编译和执行。 解析 是读取浏览器接收的脚本内容并生成脚本结构在浏览器内部中展示的过程。Parsing is the process of reading the bytes of a script received by the browser and generating an internal representation of a script’s structure. 编译 采用内部表示并使用它来生成可由处理器直接运行的机器代码，执行是该代码的实际运行。Compilation is taking that internal representation and using it to generate machine code that can be directly run by the processor, and execution is the actual running of that code. （注意：这实际上是对实际情况的过度简化 - 实际上每个浏览器的JavaScript引擎都有自己的多步骤管道 - Chrome的V8 具有Turbofan 和Ignition，Firefox具有IonMonkey - 并且有许多令人难以置信的聪明的计算机科学正在进行中。总体要点大致相同，但）(Note: this is a vast oversimplification of what actually happens – in reality each browser’s JavaScript engine has its own multi-step pipeline – Chrome’s V8 has Turbofan and Ignition, Firefox has IonMonkey – and there’s a lot of incredibly clever computer science going on. The overall gist is roughly the same, though) 这些阶段中的每一个都以略微不同的方式消耗处理器和内存资源，但同时优化所有三个阶段的最可靠方法很简单：减少代码。Each of these phases consumes processor and memory resources in slightly different ways, but the most sure-fire way of simultaneously optimising for all three is simple: ship less code. 这与简单地通过线路向浏览器发送更少的字节不同。传输压缩没有区别（浏览器已经收到了所有字节），甚至代码缩小也可以忽略不计 - 一旦浏览器解析了代码，所有缩小操作（例如删除注释和重命名变量）几乎没有区别。This isn’t the same thing as simply sending fewer bytes over the wire to the browser. Transmission compression makes no difference (the browser has already received all the bytes), and even code minification is negligible – once the browser has parsed the code, all minification operations such as removing comments and renaming variables make practically no difference. 在这一点上，更多的是关于代码的整体复杂性和结构产生差异 - 一般来说，代码中不同函数，语句和其他声明的数量和排列。At this point it’s more about the overall complexity and structure of the code that makes the difference – broadly speaking, the number and arrangement of different functions, statements, and other declarations in the code. 根据用户的设备，这是对用户的影响最大的部分。就像带宽一样，重要的是要记住，不是每个人都总是使用超高速的办公室互联网连接，因此同样重要的是要意识到并非每个人都使用高端MacBook Pro作为他们的桌面设备和最新的iPhone - 这去。设备功率的变化非常大，特别是在移动设备上。在高端iPhone上解析，编译和评估的时间可能只需要一秒钟，在“普通”移动设备上可能需要4-5倍，而在低功耗设备上则需要10-20倍。This is the part where the impact to the user varies most depending on the user’s device. Just as with bandwidth it’s important to remember that not everybody is always on a super-fast office internet connection, so it’s also important to realise that not everybody is using a high-end MacBook Pro as their desktop device and the latest iPhone when on-the-go. The variability in device power is incredibly wide, especially on mobile. What might take just a second to parse, compile, and evaluate on the top-end iPhone might take 4-5 times longer on an “average” mobile device, and 10-20 times longer on a low-power device. 迫使用户在他们的浏览器通过兆字节的JavaScript进行搅拌时等待几秒钟是一种糟糕的体验。目前，上述所有阶段都在浏览器的主CPU线程上运行，这意味着当它们发生时，网页本身实际上是无响应的，因此对于像GoSquared Assistant这样的第三方小部件保持这样的状态非常重要。中断到绝对最低限度。Forcing your users to wait several seconds while their browser churns through megabytes of JavaScript is a terrible experience. Currently, all of the above phases run on the browser’s main CPU thread, which means that while they’re happening, the web page itself is effectively non-responsive, so it’s incredibly important for a third-party widget like GoSquared Assistant to keep such interruption to an absolute minimum. 因此，考虑到所有这些，您如何才能真正减少代码大小？我们如何在GoSquared这里做到这一点？So with all that in mind, how can you actually go about reducing code size? And how do we do it here at GoSquared? JS库的权衡 JavaScript生态系统近年来爆炸式增长。随着打包工具，像Webpack和Rollup的出现，以及包管理工具npm的发展，现在比以往更容易在您的JavaScript包中引入第三方模块。 其中一些第三方模块是框架，一些是界面组件，还有些是有用的工具包，可以让您直接使用复杂的逻辑而无需自己实现。你可能因为不同的动机而选择使用它们，但是在你使用工具包之前，都应该按照相同的标准评估它们。每当我们想要添加新的依赖时，我们都会试着问自己： 我是否需要添加新库？ 我需要添加这个库吗？ 第一个问题是关于用第三方插件还是自己写的选择问题，这是一个非常主观和有争议的问题。与许多事情一样，真正的答案是“视情况而定”。在每种情况下，您都应权衡所涉及的收益和成本： 与自己写（和测试）代码相比，第三方插件可以节省多少开发时间？ 与自己写相比，采用第三方插件会为整体打包增加多少额外的大小？ 第三方插件是否包含对您不会使用的大量输入和用例的支持？Does the third-party version include support for a wide set of inputs and use-cases that you simply won’t be using? 这些问题的答案对彼此有多大关系？How much do the answers to these questions matter in relation to each other? 以上问题的答案完全取决于您要开发的内容和最后呈现的方式。 在GoSquared，我们倾向于更倾向于编写自己的代码而不是使用第三方代码，如果它将在最终捆绑中节省大小而不牺牲我们自己的生产力。但那是因为我们的代码被嵌入到我们客户的数千个网站上 - 如果它的膨胀或缓慢，那么这会让我们的客户看起来很糟糕，而不是我们。我们希望确保任何选择添加GoSquared的网站始终认为它是一种帮助，而不是一种障碍。At GoSquared, we tend to err slightly more towards writing our own code than using third-party code, if it will save size in the final bundle without sacrificing our own productivity. But that’s because our code gets embedded on thousands of our customers’ sites – if it’s bloated or slow, then that makes our customers look bad, rather than us. We want to make sure that any site which chooses to add GoSquared always feels it’s a help, never a hindrance. 做出最佳选择上面的第二个问题是关于评估和选择第三方插件的。这是一个有趣的问题，因为JavaScript生态系统已经蓬勃到对于任何给定的需求，通常都有几个插件可以选择。这意味着您可以在多个选择间权衡。 在各种不同插件之间选择的标准与评估是否首先使用第三方插件的标准大致相同。 从开发的角度来看哪个插件更容易使用？ 哪个在浏览器中有更好的性能？ 哪个总体尺寸最小？ 同样，这些问题的答案，以及你如何权衡，都是非常主观的。就GoSquared而言，我们更倾向于在尺寸和性能方面能在客户端表现更好的插件。 举例来说，我们是大球迷的阵营构建UI。我们通过React Native在我们的主要网络应用程序和iOS和Android应用程序中全面使用它。因此，对于助理，我们希望以类似的方式工作。但是，捆绑包大小更为重要，因此我们使用Preact，它是React的（仅仅）API兼容的插件，但占用空间相对较小。通过对我们的构建过程进行一些调整，我们能够编写与React完全相同的代码，但在最终的捆绑中使用Preact。For example, we’re big fans of React for building UI. We use it across the board in our main web app and in our iOS and Android apps via React Native. So for the Assistant, we wanted to work in a similar way. However, bundle size is much more important, so we instead use Preact, which is a (just about) API-compatible drop-in for React, but with a comparably tiny footprint. With a few tweaks to our build process, we’re able to write the exact same code we do for React, but with Preact in the final bundle. 有时它并不像将一个库换成另一个库那么简单; 通常会涉及一定程度的开发工作。您是否需要根据自己的情况评估开发工作是否对您有益。Sometimes it’s not as simple as swapping one library out for another; often there’ll be some degree of development work involved. Whether that development effort is worth the benefit to you is something you’ll need to evaluate based on your own situation. Bundlephobia是一个非常快速评估库潜在重量的好工具，它通过分析源代码来计算包含模块的粗略影响。唯一需要注意的是，它不能考虑你是包括整个图书馆还是仅包括某些部分 - 不久之后就会更多。但是，作为一般指南使用它很棒。A great tool for very quickly evaluating the potential weight of a library is Bundlephobia, which calculates the rough effect of including a module by analysing its source code. The only caveat being that it can’t take into account whether you’re including the whole library or just some parts – more on that shortly. It’s great to use as a general guide, though. 如果可以，仅导入您需要的内容评估第三方库时的另一个重点是可分解性问题。 也就是说，如果一个库支持各种各样的用例，其中大部分都是你不会使用的，它是否以这样的方式编写，只允许你只提取你真正需要的那些部分？像Webpack或Rollup这样的捆绑器具有“树摇动”或“死代码消除”的概念，这是确保输出仅包括您实际使用的代码的不同方式。That is, if a library supports a whole variety of use-cases, most of which you won’t be using, has it been written in such a way that allows you to pull in only those parts you actually need? Bundlers like Webpack or Rollup feature the idea of “tree-shaking” or “dead code elimination” which are different ways of ensuring the output only includes the code you actually use. 如果以正确的方式构建库，您应该只能包含所需的部分，即使库作为一个整体包含更广泛的功能集。If a library is structured in the right way, you should be able to include only the parts you need, even if the library as a whole includes a much wider set of functionality. 这方面的一个主要例子是在JavaScript中操作日期。多年来，Moment.js因其多功能性和近乎完整的功能集而成为首选的库。几乎所有你可能想要做的日期（解析，操作，格式化），你可以用Moment做。A prime example of this is in the field of manipulating Dates in JavaScript. Over the years, Moment.js emerged as the library of choice for its versatility and near-complete feature set. Pretty much everything you could possibly want to do with a date (parsing, manipulating, formatting), you can do with Moment. 但是，它主要是在现代捆绑器时代之前编写的，所以它不是用可分解性编写的 - 你在需要它的地方包含了脚本文件并获得了所有功能。然而，如今，有许多替代解决方案，要么使用JavaScript的内置功能，要么使用替代库，例如date-fns，这些都是考虑到树木抖动的。date-fns库不是Moment的简单替代品 - 从一个转换到另一个需要相当多的重构工作 - 但是我们在开发GoSquared Assistant时做出了一个决定，以避免大的非-decomposable库，如Moment。However, it was written largely before the age of modern bundlers, so it wasn’t written with decomposability in mind – you included the script file where you needed it and got all the functionality. Nowadays, however, there are plenty of alternative solutions, either using JavaScript’s built-in functionality, or alternative libraries such as date-fns, which were written with tree-shaking in mind. The date-fns library isn’t a simple drop-in replacement for Moment – switching from one to the other requires a fair amount of refactoring work – but we made a decision early on in the development of the GoSquared Assistant to avoid large, non-decomposable libraries such as Moment. 这就是我们如何减少捆绑包中包含的第三方代码的影响。除了简单地编写我们自己的代码之外，我们还要做的最后一件事是保持我们的生产构建精益：So that’s how we reduce the effect of third-party code included in a bundle. Besides simply writing less of our own code, there’s one last major thing we do to keep our production builds lean: 去除生产中不需要的一切 在开发过程中，您会在代码中写一些用于验证，调试或记录的逻辑，以确保代码符合您的预期（如果您还没这样做，那么可以去试试）。即使自己的代码中没有这些逻辑，您包含的第三方插件也可能包含，比如console.log语句，propTypes验证（如果使用React）等所有内容。 但是，在您构建面向访客的生产代码时，这些功能都没有任何用处，或者充其量只是很少使用。所以它应该被删除，而且最好由你的构建系统自动删除。 像React这样的大多数库都会用环境变量“控制”它们的开发模式逻辑，如下所示：12345if (process.env.NODE_ENV === \"production\") &#123; // fast version of code, no debugging&#125; else &#123; // slower version with better debugging&#125; 您可能希望在自己的代码中执行类似的操作。一个好的捆绑器或缩小器将能够在这里检测并内联process.env.NODE_ENV的值（使用诸如rollup-plugin-replace或Webpack的EnvironmentPlugin之类的插件），并完全删除你不想要的代码部分包括。You may want to do something similar in your own code. A good bundler or minifier will be able to detect and inline the value of process.env.NODE_ENV here (with plugins like rollup-plugin-replace or Webpack’s EnvironmentPlugin), and fully strip out the parts of the code that you don’t want to include. 还有许多其他东西可能不应该包含在最终的生产包中，其中许多可以作为构建过程的一部分完全自动删除。例如，对于React propTypes，我们使用transform-react-remove-prop-types Babel插件从生产版本中删除所有开发模式验证和警告。There are many other things that probably shouldn’t be included in the final production bundle, many of which can be completely automatically removed as part of the build process. For example, for React propTypes, we use the transform-react-remove-prop-types Babel plugin to remove all development-mode validation and warning from the production build. 最终效果 据我们所知，GoSquared Assistant是目前最精简，最快速的聊天小部件，大约10倍。To the best of our knowledge, GoSquared Assistant is the leanest and fastest chat widget available right now, by a factor of about 10×.将所有这些技术放在一起用于GoSquared Assistant代码库，我们有：Putting all these techniques together for the GoSquared Assistant codebase, we have: 缩小和压缩所有已部署的脚本 Minify &amp; compress all deployed scripts 选择小而高效的库，如Preact而不是React，这是有意义的 Choose small and performant libraries such as Preact instead of React, where it makes sense 在生产模式下优化我们的构建设置，以删除仅与开发相关的所有代码 Optimise our build settings in production mode to remove all code that’s only relevant to development 降至39KB Getting down to 39KB所有这一切都产生了一个捆绑包，它封装了18种语言的所有必要的JavaScript，第三方库，CSS和本地化字符串（在编写本文时）的测量值为112KB（gzip之后为39KB），并且解析和运行速度比其他任何其他语言快那里的现场聊天提供商。即使在相对低端的移动设备上，它对任何页面的影响也几乎都不可察觉。All this results in a bundle that encapsulates all necessary JavaScript, third-party libraries, CSS and localisation strings for 18 languages that (at time of writing) measures in at 112KB (39KB after gzip), and which parses and runs faster than any other on-site chat provider out there. Even on a relatively low-end mobile device, the impact it has on any page it’s on is barely noticeable.我们为GoSquared Assistant的表现所取得的成就感到非常自豪。据我们所知，它是目前最精简，最快速的聊天小部件，大约10倍，这对移动设备产生巨大影响。We’re very proud of what we’ve managed to achieve in the performance of GoSquared Assistant. To the best of our knowledge, it’s the leanest and fastest chat widget available right now, by a factor of about 10×, which makes a huge difference on mobile devices.显然，我们还可以做更多的事情，并且随着时间的推移我们将会添加更多功能，但您可以相信，每当我们添加任何新内容时，我们始终会将对性能的影响保持在我们客户的网站上。Obviously, there’s still more we can do, and more functionality we’ll be adding over time, but you can trust that we’ll always be keeping the performance impact to our customers’ sites front-of-mind whenever we add anything new. 资源 原文 https://engineering.gosquared.com/improve-javascript-page-load-time The Cost of JavaScript in 2018 The “Developer Experience” Bait-and-Switch The 12 Things You Need to Consider When Evaluating Any New JavaScript Library","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"load time","slug":"load-time","permalink":"https://zj-john.github.io/tags/load-time/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"}]},{"title":"如何在Google地图上创建自定义HTML标记","date":"2018-10-30T02:52:02.000Z","path":"notes/ckbdbl42c004y2ktyt6er7c5z.html","text":"基于Google Map的JavaScript API，在Google地图上创建标记的默认方法是使用图像或SVG路径，但这限制了开发的可能性。本教程将介绍如何使用HTML和CSS在Google Map上创建地图标记。该技术涉及Google Map的扩展库类OverlayView，为了适配它，我们还将介绍如何异步扩展新类以避免构建问题，竞争条件和重复依赖。 如何制作地图和标记在现代应用程序中，大多数依赖项通过包管理器（如npm或yarn）添加，通过import语句引入使用，并通过构建工具（如webpack）构建打包到高性能代码块中。但对Google地图来说，通常通过脚本标记（\\）加载到web应用的HTML文件中，然后将Google Maps的JavaScript库放在全局对象（window.google）上以供运行时使用。 Google Maps 的JS API中，每个功能都在google.maps这个父命名空间下拥有自己的类/命名空间。比如，向地图添加标记的最简单方法是使用google.maps.Marker下的Marker类。这个接口用于在地图上创建标记，它仅接受两种类型的标记内容实体：图像或SVG。这虽然适用于很多情况，但仍然限制了开发人员的操作需求。 Google Maps的JS API还有一个用于在地图上创建实体的更通用的类：OverlayView类，位于google.maps.OverlayView下。文档中称这些为“自定义叠加层(Custom Overlays)”，并将它们定义为“地图上与纬度/经度坐标相关联的对象，因此当您拖动或缩放地图时它们会跟随移动。” 这个描述的效果和使用Marker类定义的地图标记很类似！事实上，google.maps.Marker只是一种预定义的叠加类型。因此，通过使用OverlayView类，开发人员可以使用任何HTML内容来创建满足需求的地图标记。由于自定义叠加的内容只是HTML，因此CSS和JavaScript都可以通过元素的id或类属性来定位自定义叠加元素，从而达到更精细地控制行为，更灵活的内容和CSS动画！ 创建HTMLMapMarker类我们将继承OverlayView类，创建一个名为HTMLMapMarker的ES6的类。构造函数将采用三个参数： 纬度/经度对象。这是另一个Google Maps类：LatLng类 （google.maps.LatLng）的实例。此类的构造函数有两个Number参数，分别表示标记在地图上应放置位置的纬度和经度。 表示标记内容的HTML。以字符串格式表示。对于使用webpack构建的应用程序，可以是通过html-loader导入的HTML文件。 接受标记的Google Map实例。 我们的类还需要重写OverlayView类的以下四种方法：Our class will also need to implement four methods to satisfy the requirements of an OverlayView: draw(). 此方法将用于在地图上绘制标记。 remove(). 此方法将用于从地图中删除标记。 getPosition(). 此方法将用于跟踪标记放置的位置（纬度/经度）。 getDraggable(). 此方法将指示我们的标记是否可拖动。既然不能，就返回 false。 让我们从类定义和构造函数开始。我们将通过具有上述三个属性的对象args将参数传递给构造函数： 12345678910class HTMLMapMarker extends OverlayView &#123; constructor() &#123; super(); this.latlng = args.latlng; this.html = args.html; this.setMap(args.map); &#125; // Remainder of class definition &#125; 如上所示，传递给构造函数的LatLng和HTML会存为同名（this.latlng和this.html）的实例属性。而map实例会立即使用。在构造函数中，我们调用从OverlayView继承的方法setMap，传入map实例，将新标记链接到页面上的当前map实例。 接下来，让我们继续讨论该draw方法。这个方法完成了大部分繁重的工作。 12345678910111213141516171819draw() &#123; if (!this.div) &#123; this.div = document.createElement('div'); this.div.style.position = 'absolute'; if (this.html) &#123; this.div.innerHTML = this.html; &#125; google.maps.event.addDomListener(this.div, 'click', event =&gt; &#123; google.maps.event.trigger(this, 'click'); &#125;); const panes = this.getPanes(); panes.overlayImage.appendChild(this.div); &#125; const point = this.getProjection().fromLatLngToDivPixel(this.latlng); if (point) &#123; this.div.style.left = `$&#123;point.x&#125;px`; this.div.style.top = `$&#123;point.y&#125;px`; &#125;&#125; 第一步是检查是否this.div已定义。&lt;div&gt;中将保存最终放置在地图上的标记元素。如果没有定义，我们将通过document.createElement(“div”)创建一个新的&lt;div&gt;，并将其存储this.div，并将其position设置为absolute。 然后，把&lt;div&gt;的innerHTML属性设置为构造函数中已赋值的this.html，这完成了标记元素的HTML内容。 在方法的第8行，我们使用google.maps.event类的方法addDomLister向我们的新div添加一个事件监听器。该方法以this.div为第一个参数，事件名称（’click’）作为第二个参数，以及在事件发生时执行的回调作为第三个参数。在我们的例子中，回调参数只需要将click事件传递给this，即使用中已实例化的类，稍后会详细介绍。 该draw方法的第10行使用从OverlayView中继承的方法getPanes来获取当前地图实例的窗格。窗格是Google对图层的叫法，每个图层上都可以放置用于在地图上显示的各种实体。有关窗格的更多信息，您可以在此处阅读文档。我们使用overlayImage窗格的appendChild方法来追加我们存储在this.div中的元素&lt;div&gt;。 draw方法的最后一步是将我们新放置的&lt;div&gt;定位到适当的纬度/经度位置。这可以通过使用继承方法getProjection获取地图投影，然后在返回的投影上调用fromLatLngToDivPixel方法来完成。此方法将提供的纬度/经度转换为屏幕上对应的x，y位置。然后，我们将div的left 和top属性分别设置为x和y值。这也是基于像素的偏移量，添加渲染元素的理想位置，在本文最后的演示中，您会注意到我已经在高度和宽度上添加了25px的偏移，因为图像是50px的长宽，最后得到的效果正好使图像在所提供的纬度/经度上居中。 我们类中的draw方法就完成了，但一点点重构可以提高可读性。我选择了将功能的逻辑重构到三种辅助方法：createDiv, appendDivToOverlay和positionDiv。如下： 12345678910111213141516171819202122232425262728293031createDiv() &#123; this.div = document.createElement('div'); this.div.style.position = 'absolute'; if (this.html) &#123; this.div.innerHTML = this.html; &#125; google.maps.event.addDomListener(this.div, 'click', event =&gt; &#123; google.maps.event.trigger(this, 'click'); &#125;);&#125;appendDivToOverlay() &#123; const panes = this.getPanes(); panes.overlayImage.appendChild(this.div);&#125;positionDiv() &#123; const point = this.getProjection().fromLatLngToDivPixel(this.latlng); if (point) &#123; this.div.style.left = `$&#123;point.x&#125;px`; this.div.style.top = `$&#123;point.y&#125;px`; &#125;&#125;draw() &#123; if (!this.div) &#123; this.createDiv(); this.appendDivToOverlay(); &#125; this.positionDiv();&#125; 接下来看remove方法： 123456remove() &#123; if (this.div) &#123; this.div.parentNode.removeChild(this.div); this.div = null; &#125;&#125; 此方法只检查this.div中HTML元素是否存在。如果它存在，我们可以通过在它的parentNode上调用removeChild 来从DOM中删除它。一旦从DOM删除，我们也设置this.div为null，使实例的引用也被删除。 剩下的方法，getPosition和getDraggable都非常简单： 1234567getPosition() &#123; return this.latlng;&#125;getDraggable() &#123; return false;&#125; getPosition方法只返回保存在this.latlng的纬度/经度，getDraggable则返回布尔值false，因为我们的标记不可拖动。 我们已经完成了类的定义。最终的代码应如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class HTMLMapMarker extends OverlayView &#123; constructor() &#123; super(); this.latlng = args.latlng; this.html = args.html; this.setMap(args.map); &#125; createDiv() &#123; this.div = document.createElement('div'); this.div.style.position = 'absolute'; if (this.html) &#123; this.div.innerHTML = this.html; &#125; google.maps.event.addDomListener(this.div, 'click', event =&gt; &#123; google.maps.event.trigger(this, 'click'); &#125;); &#125; appendDivToOverlay() &#123; const panes = this.getPanes(); panes.overlayLayer.appendChild(this.div); &#125; positionDiv() &#123; const point = this.getProjection().fromLatLngToDivPixel(this.latlng); if (point) &#123; this.div.style.left = `$&#123;point.x&#125;px`; this.div.style.top = `$&#123;point.y&#125;px`; &#125; &#125; draw() &#123; if (!this.div) &#123; this.createDiv(); this.appendDivToOverlay(); &#125; this.positionDiv(); &#125; remove() &#123; if (this.div) &#123; this.div.parentNode.removeChild(this.div); this.div = null; &#125; &#125; getPosition() &#123; return this.latlng; &#125; getDraggable() &#123; return false; &#125;&#125; 在运行时定义OverlayView由于我们一直基于Google Maps JavaScript库提供的类OverlayView进行开发，因此我们需要保证在使用时，google.maps.OverlayView已经定义。 如果您的应用不需要构建过程，且在定义类时全局google.maps对象已经定义，则可以直接继承OverlayView： 1class HTMLMapMarker extends google.maps.OverlayView &#123;&#125; 但是，如果您正在一个需要构建过程的项目中工作，那么在您尝试让HTMLMapMarker继承google.maps.OverlayView类时，它可能还没有定义。虽然直接将OverlayView类添加到项目中可能会解决问题，但它会导致代码重复，因为在加载Google Maps库时OverlayView将始终加载。 由于闭包的强大功能，我们可以包装我们的类google.maps.OverlayView以保证在使用时完成定义。没有竞争条件，没有重复的代码。 让我们来命名我们的闭包函数为createHTMLMapMarker。此函数接受一个具有两个属性的对象：一个具有默认值的google.maps.OverlayView的属性OverlayView，以及一个rest运算符（…args）来收集传递给createHTMLMapMarker的参数。 123456789const createHTMLMapMarker = (&#123; OverlayView = google.maps.OverlayView, ...args &#125;) =&gt; &#123; class HTMLMapMarker extends OverlayView &#123; // Remainder of class definition &#125; return new HTMLMapMarker();&#125;;export default createHTMLMapMarker; 通过这个小的改变，我们可以保证在我们调用createHTMLMapMarker时google.maps.OverlayView已经定义。 现在我们已经完成了我们的类和闭包，让我们继续学习！本教程的其余部分将采用以下文件目录： 1234/index.html/src/index.js/src/html-map-marker.js &lt;-- Our closure + class definition/src/style.css 出于我们的教程目的，index.html需要只需加载我们的CSS，加载Google Maps JavaScript库，然后加载应用程序的入口点src/index.js。页面上唯一的元素是ID为map的&lt;div&gt;，它用于显示Google Map。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Custom HTML Map Markers&lt;/title&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;link rel=\"stylesheet\" href=\"src/style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"map\"&gt;&lt;/div&gt; &lt;script src=\"https://maps.googleapis.com/maps/api/js?v=3.exp\"&gt;&lt;/script&gt; &lt;script src=\"src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js将定义一个以Timbuktu的纬度和经度为中心的，新Google Maps 实例map。然后，它将使用我们之前定义的闭包函数createHTMLMapMarker定义一个marker，以相同的latlng、map实例，和将呈现为标记内容的html作为参数传入。我们将使用派对鹦鹉作为图像标记，定义ID属性为parrot以便后续增加样式。 123456789101112131415161718import createHTMLMapMarker from \"./html-map-marker.js\";const latLng = new google.maps.LatLng(16.7666, -3.0026);const mapOptions = &#123; zoom: 11, center: latLng&#125;;const map = new google.maps.Map(document.getElementById(\"map\"), mapOptions);let marker = createHTMLMapMarker(&#123; latlng: latLng, map: map, html: `&lt;img id=\"parrot\" src=\"https://cultofthepartyparrot.com/parrots/hd/parrot.gif\"&gt;`&#125;);marker.addListener(\"click\", () =&gt; &#123; alert(\"Partyin Partyin Yeah!\");&#125;); 还记得我们在类HTMLMapMarker的draw方法中定义了“click”的DOM事件吗？如前所述，click事件只是传递给marker实例。这允许我们通过addListener方法直接向我们新创建的marker添加一个事件监听器，如第16-18行所示index.js。 下面是设置的样式： 1234567891011121314html, body &#123; height: 100%; margin: 0; padding: 0;&#125;#map &#123; height: 100%;&#125;#parrot &#123; border: 1px solid #f00; border-radius: 20%; height: 50px; width: 50px;&#125; 完成！通过我们的新的createHTMLMapMarker功能，我们现在可以轻松地将任何HTML添加到Google地图实例中。您可以在下面看到教程的最终结果。 请注意，下面的代码示例（CodeSandbox中）还会收到来自Google的提醒“此页面无法正确加载Google地图”，因为没有使用任何API密钥。不过该应用程序仍应按预期工作。 资源 原文: https://levelup.gitconnected.com/how-to-create-custom-html-markers-on-google-maps-9ff21be90e4b Demo: https://4q0w9wq91w.codesandbox.io/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"},{"name":"google maps","slug":"google-maps","permalink":"https://zj-john.github.io/tags/google-maps/"},{"name":"development","slug":"development","permalink":"https://zj-john.github.io/tags/development/"}]},{"title":"理解JavaScript中的柯里化","date":"2018-10-30T02:52:02.000Z","path":"notes/ckbdbl42t005t2kty708srmka.html","text":"函数式编程是一种 把函数作为参数传递（回调）和返回无副作用（修改程序的状态）函数的 编程方式， 许多语言都采用这种编程风格，其中最受欢迎的是JavaScript，Haskell，Clojure，Erlang和Scala。 而且根据它传递和返回函数的能力，引申了许多概念： 纯功能 柯里化 高阶函数 我们将在本文学习的一个概念是 柯里化（Currying）。 在本文中，我们将学习柯里化是如何工作的以及它如何在实际开发中发挥作用。 什么是柯里化？柯里化是函数式编程中的一个过程，我们可以将具有多个参数的函数转换为嵌套函数序列。它返回一个新函数，并在内部使用下一个参数。 它不断返回一个新函数, 然后消耗当前参数，就像我们之前所说的那样，直到所有参数都用完为止。所有的参数通过闭包得以保留（&quot;alive&quot;），并且当返回并执行柯里化链中的最终函数时，所有参数都在执行中使用。 Currying是将具有多个arity的函数转换为具有较少arity函数的过程 - Kristina Brainwave 注意： 术语arity是指函数的参数个数。例如， 1234567function fn(a, b) &#123; //... &#125;function _fn(a, b, c) &#123; //... &#125; 函数fn接受两个参数（2-arity函数）, _fn接受三个参数（3-arity函数）。 因此，柯里化就是将具有多个参数的函数转换为一系列只需要一个参数函数的过程。 我们来看一个简单的例子：123function multiply(a, b, c) &#123; return a * b * c; &#125; 此函数接受三个数字，将数字相乘并返回结果。1multiply(1,2,3); // 6 这里展示了如何使用完整参数调用乘法函数。下面，让我们创建一个柯里化的函数版本，看看我们如何在一系列函数调用中实现相同的功能，并得到相同的结果： 123456789function multiply(a) &#123; return (b) =&gt; &#123; return (c) =&gt; &#123; return a * b * c &#125; &#125; &#125;log(multiply(1)(2)(3)) // 6 这里，我们已经将multiply(1,2,3)函数调用转为了multiply(1)(2)(3)这样的多个函数调用。 为了得到相乘的结果，1，2，3这三个参数会一个接一个地传递，每个数字都预填充到下一个函数内，等待调用。 我们可以将multiply(1)(2)(3)分开来更好地理解它：1234const mul1 = multiply(1); const mul2 = mul1(2); const result = mul2(3); log(result); // 6 让我们一个接一个的分析。首先，我们传递参数1给multiply函数：1let mul1 = multiply(1); 它返回函数：12345return (b) =&gt; &#123; return (c) =&gt; &#123; return a * b * c &#125; &#125; 现在，mul1转为上面的函数定义，它需要一个参数b。 接着，我们调用mul1函数，传入参数2：1let mul2 = mul1(2); 在mul1将返回第三个函数：123return (c) =&gt; &#123; return a * b * c &#125; 返回的函数现在存储在mul2变量中。从本质上讲，mul2是：123mul2 = (c) =&gt; &#123; return a * b * c &#125; 当mul2调用参数3，1const result = mul2(3); 它与先前通过的参数：a = 1, b = 2一起计算并返回6。1log(result); // 6 作为嵌套函数，mul2可以访问外部函数的变量范围，multiply以及mul1。 这是mul2可以使用前置函数中定义的变量执行乘法运算的前提。虽然这些函数早已返回，并且在内存中垃圾回收了，但它的变量仍以某种方式保持”alive”。 您会看到三个数字一次一个地应用于该函数，并且每次都返回一个新函数，直到所有数字都用完为止。 让我们看另一个例子：12345function volume(l,w,h) &#123; return l * w * h; &#125;const aCylinder = volume(100,20,90) // 180000l 我们有一个volume函数，它可以计算任何立方体的体积。 curried版本将接受一个参数并返回一个函数，该函数也将接受一个参数并返回一个函数。然后循环往复，直到到达最后一个参数并返回最后一个函数，然后执行所有前置参数和最后一个参数的乘法运算。12345678function volume(l) &#123; return (w) =&gt; &#123; return (h) =&gt; &#123; return l * w * h &#125; &#125; &#125; const aCylinder = volume(100)(20)(90) // 180000 与我们在multiply函数中所使用的一样，最后一个函数只接受参数h，但是将使用已包含在函数作用域的其他变量来执行最终操作。因为闭包，所以这种方式是有效的。 currying背后的想法是获取一个函数并派生一个返回特殊函数的函数。 数学中的柯里化维基百科进一步给出了柯里化的概念。让我们用下面的例子来学习。 如果我们有一个等式：1f(x,y) = x^2 + y = z 有两个变量x和y。如果两个变量是x=3和y=4，就可以计算z的值。 让我们在f(x,y)替换x和y的值：1f(x,y) = f(3,4) = x^2 + y = 3^2 + 4 = 13 = z 我们得到结果，13。 我们可以柯里化f(x,y)：12h = x^2 + y = f(x,y)hy(x) = x^2 + y = hx(y) = x^2 + y 注意：hx 中 x 是下标，hy 中 y 是下标。 如果我们在等式hx(y) = x^2 + y中固定x=3，它将返回一个以y作为变量的新的等式：1h3(y) = 3^2 + y = 9 + y 注意 ：h3 中 3 是下标 上式等同于：1h3(y) = h(3)(y) = f(3,y) = 3^2 + y = 9 + y 最终返回了一个需要变量y的新方程式9 + y。接下来，我们传入y=4：1h3(4) = h(3)(4) = f(3,4) = 9 + 4 = 13 y是柯里化变量链中的最后一个变量，在前一个变量x = 3仍保留的前提下，执行了相加操作，最终算结果为13。 事实上，我们将等式f(x,y) = 3^2 + y柯里化为了一系列等式：123453^2 + y -&gt; 9 + yf(3,y) = h3(y) = 3^2 + y = 9 + yf(3,y) = 9 + yf(3,4) = h3(4) = 9 + 4 = 13 哇！这是数学中的柯里化，如果你发现讲解的不够清楚😕，可以阅读👉 维基百科，了解全部细节。 柯里化和部分函数应用（Partial function application）现在，有些人可能会开始认为柯里化函数的嵌套函数数量取决于它接收的参数的数量。是的，这就是 柯里化。 我可以把 volume 的柯里化函数设计为这样：12345function volume(l) &#123; return (w, h) =&gt; &#123; return l * w * h &#125; &#125; 所以它可以像这样被调用： 12345const hCy = volume(70);hCy(203,142); hCy(220,122); hCy(120,123); 或者 123volume(70)(90,30); volume(70)(390,320); volume(70)(940,340); 我们刚刚定义了一个专门的函数来计算任何长度为（l）的圆柱体的体积。 它需要3个参数并具有2层嵌套函数，不像我们以前的版本，需要3参数时要做3层嵌套函数。 这个版本不是柯里化,只是 volume 函数的部分应用。 柯里化和部分应用是相关的，但它们有不同的概念。 部分应用程序将函数转换为具有较小arity的另一个函数。 12345678910// fromfunction acidityRatio(x, y, z) &#123; return performOp(x,y,z) &#125;// tofunction acidityRatio(x) &#123; return (y,z) =&gt; &#123; return performOp(x,y,z) &#125; &#125; 注意：我故意省略了performOp函数的实现，它不是重点。你必须要了解的是柯里化和部分应用的概念。 这是acidityRatio函数的部分应用，不涉及到柯里化的问题。acidityRatio函数被部分应用以接受较少的arity，最终期望参数的数量少于其原始函数。 如果把它柯里化，它会是这样的：1234567function acidityRatio(x) &#123; return (y) = &gt; &#123; return (z) = &gt; &#123; return performOp(x,y,z) &#125; &#125; &#125; 柯里化根据函数的参数个数创建嵌套函数。每个函数都接收一个参数。如果没有参数，也就没有柯里化了。 Currying适用于具有两个以上参数的函数 - Wikipedia 可能存在一种情况，让柯里化和部分应用彼此相遇，如下。假设我们有一个函数：123function div(x,y) &#123; return x/y; &#125; 如果我们部分应用它。我们将得到：12345function div(x) &#123; return (y) =&gt; &#123; return x/y; &#125; &#125; 同时，柯里化将给我们相同的结果：12345function div(x) &#123; return (y) =&gt; &#123; return x/y; &#125; &#125; 虽然柯里化和部分函数有可能给出相同的结果，但它们仍是两个不同的概念。 就像我们之前说的那样，柯里化和部分应用是相关的，但实际上并没有相同的设计。他们之间的共同点是他们都依靠闭包来工作。 柯里化有用吗？当然，当您遇到以下场景时，柯里化会派上用场： 编写可以轻松重用和配置的小代码模块，就像我们使用npm一样：例如，您拥有一家商店🏠并希望为您的客户提供10％💵的折扣：123function discount(price, discount) &#123; return price * discount &#125; 当一个客户购买价值500美元的商品时，你会给他：12const price = discount(500,0.10); // $50 // $500 - $50 = $450 从长远来看，我们会发现自己每天都在计算10％的折扣。1234567891011121314const price = discount(1500,0.10); // $150 // $1,500 - $150 = $1,350const price = discount(2000,0.10); // $200 // $2,000 - $200 = $1,800const price = discount(50,0.10); // $5 // $50 - $5 = $45const price = discount(5000,0.10); // $500 // $5,000 - $500 = $4,500const price = discount(300,0.10); // $30 // $300 - $30 = $270 我们可以把discount功能柯里化，这样我们就不用总是添加0.10折扣：1234567function discount(discount) &#123; return (price) =&gt; &#123; return price * discount; &#125; &#125;const tenPercentDiscount = discount(0.1); 现在，我们现在只需要您客户购买的商品价格就可以计算了：12tenPercentDiscount(500); // $50 // $500 - $50 = $450 同样，有些优惠客户比其它优惠客户更重要，让我们称之为超级客户。我们希望为超级客户提供20％的折扣。 我们使用柯里化：1const twentyPercentDiscount = discount(0.2); 我们通过使用0.2折扣值创建了一个新的柯里化函数，返回的函数twentyPercentDiscount将用于计算我们超级客户的折扣：123456twentyPercentDiscount(500); // 100 // $500 - $100 = $400 twentyPercentDiscount(5000); // 1000 // $5,000 - $1,000 = $4,000 twentyPercentDiscount(1000000); // 200000 // $1,000,000 - $200,000 = $600,000 避免频繁调用具有相同参数的函数：例如，我们有一个计算圆柱体积的函数：123function volume(l, w, h) &#123; return l * w * h; &#125; 碰巧仓库中的所有圆柱高度都为100米。你会看到，你会反复使用h为100调用此函数：123volume(200,30,100) // 2003000l volume(32,45,100); //144000l volume(2322,232,100) // 53870400l 要解决这个问题，你可以调整volume函数（就像我们之前做的那样）：1234567function volume(h) &#123; return (w) =&gt; &#123; return (l) =&gt; &#123; return l * w * h &#125; &#125; &#125; 我们可以为特定的圆柱高度定义一个特定的函数：1234const hCylinderHeight = volume(100);hCylinderHeight(200)(30); // 600,000l hCylinderHeight(2322)(232); // 53,870,400l 通用柯里化函数让我们开发一个函数，它接受任何函数并返回函数的柯里化版本。 此函数不是唯一的，你可以写自己的版本 12345678910function curring(fn)&#123; var _args = []; return function cb()&#123; if(arguments.length === 0) &#123; return fn.apply(this, _args); &#125; Array.prototype.push.apply(_args, [].slice.call(arguments)); return cb; &#125;&#125; 示例如下：1234567891011function volume(l,h,w) &#123; return l * h * w &#125;console.log(curring(volume)(100)(200)(900)())// 18000000const hCy = curring(volume)(100);hCy(200)(900)(); // 18000000l hCy(70)(60)(); // 420000l 通用部分函数12345function PartialFunction(fn, ...args) &#123; return (..._arg) =&gt; &#123; return fn(...args, ..._arg); &#125; &#125; 示例如下： 12345678function volume(l,h,w) &#123; return l * h * w &#125;const hCy = PartialFunction(volume,100);hCy(200,900); // 18000000l hCy(70,60); // 420000l 结论闭包使得可以在JavaScript中进行柯里化。它能够保留已经执行的函数的状态，使我们能够创建一个函数为特定值的工厂函数。 柯里化，闭包和函数式编程是比较棘手的一块儿内容。但通过不断的练习，一旦掌握它，你会知道付出是值得的。 资源 原文 https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339 Currying — Wikipedia https://en.m.wikipedia.org/wiki/Currying Partial Application Function — Wikipedia https://en.m.wikipedia.org/wiki/Partial_application","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"},{"name":"currying","slug":"currying","permalink":"https://zj-john.github.io/tags/currying/"},{"name":"柯里化","slug":"柯里化","permalink":"https://zj-john.github.io/tags/柯里化/"},{"name":"functional programming","slug":"functional-programming","permalink":"https://zj-john.github.io/tags/functional-programming/"}]},{"title":"最新的Airbnb的JavaScript风格指南（ES6版本）","date":"2018-10-30T02:52:02.000Z","path":"notes/ckbdbl4ct00t32ktyuqe6nwh6.html","text":"Airbnb的JavaScript风格指南是目前业界认可度最高，使用最为广泛的JavaScript编写指南，很多公司也会结合此文档和实际情况编写内部的JS使用指南。可以说这个指南代表了一种使用JavaScript最合理的方法。 本文对原文的中文简版进行了翻译上的优化和一些精简，可以方便开发人员快速使用。 注意: 本文中所有代码都是基于ES6的。 Typestypes–primitives当你访问一个基本类型时，你可以直接访问到它的值。 string number boolean null undefined symbol 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 Symbols目前还没有完全匹配功能的polyfill（哪位大神开发下？），所以不应该在不能原生支持symbol类型的环境[浏览器]中使用 symbol 类型。 types–complex当你访问一个复杂类型时，你访问的是它的引用（类似于C中指针的概念）。 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 References避免使用var。 references–prefer-const优先使用const声明变量原因： 使用const可以让你避免重复赋值，也可以认清哪些真正是“变”量。 eslint: prefer-const, no-const-assign 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; references–disallow-var如果你有对参数重新赋值的需求，那就用let吧。原因： 因为let是块级作用域，而var是函数级作用域。let完胜。 eslint: no-var 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; references–block-scopelet、const都是块级作用域 1234567// const 和 let 都只存在于它定义的那个块级作用域&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError Objectsobjects–no-new使用字面值({})创建对象. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; es6-computed-properties当创建一个包含动态属性名的对象时，用下面的方式：原因： 这可以使你的对象定义看起来更整洁，找属性的时候也方便。 123456789101112131415161718function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// good getKey('enabled')是动态属性名const obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; es6-object-shorthand用对象方法的简写方式. eslint: object-shorthand 123456789101112131415161718// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, // 对象的方法 addValue(value) &#123; return atom.value + value; &#125;,&#125;; es6-object-concise用属性值缩写.原因： 这样写的更少且更可读 eslint: object-shorthand 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; objects–grouped-shorthand将所有缩写的属性放在对象声明的开始.原因： 这样也是为了更方便的知道有哪些属性用了缩写. 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; objects–quoted-props只对必须要使用引号的属性使用引号 &#39;&#39;.原因： 通常我们认为这种方式主观上易读。他优化了代码，并且更容易压缩。 eslint: quote-props 12345678910111213// badconst bad = &#123; 'foo': 3, 'bar': 4, 'data-blah': 5,&#125;;// goodconst good = &#123; foo: 3, bar: 4, 'data-blah': 5,&#125;; objects–prototype-builtins不要直接调用Object.prototype上的方法，如hasOwnProperty, propertyIsEnumerable, isPrototypeOf。原因：：主要是怕一些对象的默认方法被更改或屏蔽过。如：{ hasOwnProperty: false } - 或这是一个空对象Object.create(null) 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // 在模块作用内做一次缓存/* or */import has from 'has'; // https://www.npmjs.com/package/has// ...console.log(has.call(object, key)); objects–rest-spread对象浅拷贝时，更推荐使用扩展运算符[就是...运算符]，而不是Object.assign。获取对象指定的几个属性时，用对象的rest解构运算符[也是...运算符]更好。 12345678910111213141516// very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;); // this mutates `original` ಠ_ಠdelete copy.a; // so does this// badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// good es6扩展运算符 ...const original = &#123; a: 1, b: 2 &#125;;// 浅拷贝const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// rest 赋值运算符const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125; Arraysarrays–literals用字面量赋值。 eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; arrays–push用Array#push 代替直接向数组中添加一个值。 1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); es6-array-spreads用扩展运算符做数组浅拷贝，类似上面的对象浅拷贝 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i += 1) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; arrays–from-iterable用 ... 运算符而不是Array.from来将一个可迭代的对象转换成数组。 1234567const foo = document.querySelectorAll('.foo');// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; arrays–from-array-like用 Array.from 去将一个类数组对象转成一个数组。 1234567const arrLike = &#123; 0: 'foo', 1: 'bar', 2: 'baz', length: 3 &#125;;// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); arrays–mapping用 Array.from 而不是 ... 运算符去做map遍历。 因为这样可以避免创建一个临时数组。 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); arrays–callback-return在数组方法的回调函数中使用 return 语句。 如果函数体由一条返回一个表达式的语句组成， 并且这个表达式没有副作用， 这个时候可以忽略return，详见 8.2. eslint: array-callback-return 1234567891011121314151617181920212223242526272829303132333435363738394041// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;);// good 函数只有一个语句[1, 2, 3].map(x =&gt; x + 1);// bad - 没有返回值， 因为在第一次迭代后acc 就变成undefined了[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123; const flatten = acc.concat(item); acc[index] = flatten;&#125;);// good[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; &#123; const flatten = acc.concat(item); acc[index] = flatten; return flatten;&#125;);// badinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === 'Mockingbird') &#123; return author === 'Harper Lee'; &#125; else &#123; return false; &#125;&#125;);// goodinbox.filter((msg) =&gt; &#123; const &#123; subject, author &#125; = msg; if (subject === 'Mockingbird') &#123; return author === 'Harper Lee'; &#125; return false;&#125;); arrays–bracket-newline如果一个数组有很多行，在数组的 [ 后和 ] 前断行。 请看下面示例 12345678910111213141516171819202122232425262728293031// badconst arr = [ [0, 1], [2, 3], [4, 5],];const objectInArray = [&#123; id: 1,&#125;, &#123; id: 2,&#125;];const numberInArray = [ 1, 2,];// goodconst arr = [[0, 1], [2, 3], [4, 5]];const objectInArray = [ &#123; id: 1, &#125;, &#123; id: 2, &#125;,];const numberInArray = [ 1, 2,]; Destructuringdestructuring–object用对象的解构赋值来获取和使用对象某个或多个属性值。 eslint: prefer-destructuring 原因 ：解构保存了这些属性的临时值/引用 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; destructuring–array用数组解构. 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; destructuring–object-over-array多个返回值用对象的解构，而不是数据解构。 原因：你可以在后期添加新的属性或者变换变量的顺序而不会打破原有的调用 1234567891011121314151617// badfunction processInput(input) &#123; // 然后就是见证奇迹的时刻 return [left, right, top, bottom];&#125;// 调用者需要想一想返回值的顺序const [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // oops， 奇迹又发生了 return &#123; left, right, top, bottom &#125;;&#125;// 调用者只需要选择他想用的值就好了const &#123; left, top &#125; = processInput(input); Stringsstrings–quotes对string用单引号 &#39;&#39; 。 eslint: quotes 12345678// badconst name = \"Capt. Janeway\";// bad - 样例应该包含插入文字或换行const name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; strings–line-length超过100个字符的字符串不应该用string串联成多行。原因：折断的字符串很容易出错，而且使得代码可读性和搜索性变差。 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; es6-template-literals用字符串模板而不是字符串拼接来组织可编程字符串。 eslint: prefer-template template-curly-spacing 原因：模板字符串更具可读性、语法简洁、字符串插入参数。 12345678910111213141516171819// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// badfunction sayHi(name) &#123; return `How are you, $&#123; name &#125;?`;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; strings–eval永远不要在字符串中用eval()，他就是潘多拉盒子。 eslint: no-eval strings–escaping不要使用不必要的转义字符。 eslint: no-useless-escape 原因：反斜线可读性差，所以他们只在必须使用时才出现哦 12345678// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';//bestconst foo = `my name is '$&#123;name&#125;'`; Functionsfunctions–declarations用命名函数表达式而不是函数声明。 eslint: func-style 函数表达式： const func = function () {} 函数声明： function func() {} Why? 函数声明时作用域被提前了，这意味着在一个文件里函数很容易（太容易了）在其定义之前被引用。这样伤害了代码可读性和可维护性。如果你发现一个函数有大又复杂，这个函数妨碍这个文件其他部分的理解性，这可能就是时候把这个函数单独抽成一个模块了。别忘了给表达式显示的命名，不用管这个名字是不是由一个确定的变量推断出来的，这消除了由匿名函数在错误调用栈产生的所有假设，这在现代浏览器和类似babel编译器中很常见 (Discussion) Why? 这一段还不理解这种错误发生的场景，所以只能直译过来了， 另附原文Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! Don’t forget to explicitly name the expression, regardless of whether or not the name is inferred from the containing variable (which is often the case in modern browsers or when using compilers such as Babel). This eliminates any assumptions made about the Error’s call stack. (Discussion) 12345678910111213141516// badfunction foo() &#123; // ...&#125;// badconst foo = function () &#123; // ...&#125;;// good// lexical name distinguished from the variable-referenced invocation(s)// 函数表达式名和声明的函数名是不一样的const short = function longUniqueMoreDescriptiveLexicalFoo() &#123; // ...&#125;; functions–iife把立即执行函数包裹在圆括号里。 eslint: wrap-iife Why? immediately invoked function expression = IIFEWhy? 一个立即调用的函数表达式是一个单元 - 把它和他的调用者（圆括号）包裹起来，在括号中可以清晰的地表达这些。Why? 注意：在模块化世界里，你几乎用不着 IIFE 1234// immediately-invoked function expression (IIFE)(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); functions–in-blocks不要在非函数块（if、while等等）内声明函数。把这个函数分配给一个变量。浏览器会允许你这样做，但浏览器解析方式不同，这是一个坏消息。【详见no-loop-func】 eslint: no-loop-func functions–note-on-blocksNote: 在ECMA-262中 [块 block] 的定义是： 一系列的语句； 但是函数声明不是一个语句。 函数表达式是一个语句。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; ###functions–arguments-shadow不要用arguments命名参数。他的优先级高于每个函数作用域自带的 arguments 对象， 这会导致函数自带的 arguments 值被覆盖 123456789// badfunction foo(name, options, arguments) &#123; // ...&#125;// goodfunction foo(name, options, args) &#123; // ...&#125; es6-rest不要使用arguments，用rest语法...代替。 eslint: prefer-rest-params Why? ...明确你想用那个参数。而且rest参数是真数组，而不是类似数组的arguments 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; es6-default-parameters用默认参数语法而不是在函数里对参数重新赋值。 123456789101112131415161718192021// really badfunction handleThings(opts) &#123; // 不， 我们不该改arguments // 第二： 如果 opts 的值为 false, 它会被赋值为 &#123;&#125; // 虽然你想这么写， 但是这个会带来一些细微的bug opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; functions–default-side-effects默认参数避免副作用 Why? 他会令人迷惑不解， 比如下面这个， a到底等于几， 这个需要想一下。 123456789var b = 1;// badfunction count(a = b++) &#123; console.log(a);&#125;count(); // 1count(); // 2count(3); // 3count(); // 3 functions–defaults-last把默认参数赋值放在最后 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; functions–constructor不要用函数构造器创建函数。 eslint: no-new-func Why? 以这种方式创建函数将类似于字符串 eval()，这会打开漏洞。 12345// badvar add = new Function('a', 'b', 'return a + b');// still badvar subtract = Function('a', 'b', 'return a - b'); functions–signature-spacing函数签名部分要有空格。eslint: space-before-function-paren space-before-blocks Why? 统一性好，而且在你添加/删除一个名字的时候不需要添加/删除空格 12345678// badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;;// goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;; functions–mutate-params不要改参数. eslint: no-param-reassign Why? 操作参数对象对原始调用者会导致意想不到的副作用。 就是不要改参数的数据结构，保留参数原始值和数据结构。 123456789// badfunction f1(obj) &#123; obj.key = 1;&#125;;// goodfunction f2(obj) &#123; const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&#125;; functions–reassign-params不要对参数重新赋值。 eslint: no-param-reassign Why? 参数重新赋值会导致意外行为，尤其是对 arguments。这也会导致优化问题，特别是在V8里 1234567891011121314151617181920// badfunction f1(a) &#123; a = 1; // ...&#125;function f2(a) &#123; if (!a) &#123; a = 1; &#125; // ...&#125;// goodfunction f3(a) &#123; const b = a || 1; // ...&#125;function f4(a = 1) &#123; // ...&#125; functions–spread-vs-apply用spread操作符...去调用多变的函数更好。 eslint: prefer-spread Why? 这样更清晰，你不必提供上下文，而且你不能轻易地用apply来组成new 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));// goodnew Date(...[2016, 8, 5]); functions–signature-invocation-indentation调用或者书写一个包含多个参数的函数应该想这个指南里的其他多行代码写法一样： 每行值包含一个参数，每行逗号结尾。 123456789101112131415161718192021222324252627// badfunction foo(bar, baz, quux) &#123; // ...&#125;// good 缩进不要太过分function foo( bar, baz, quux,) &#123; // ...&#125;// badconsole.log(foo, bar, baz);// goodconsole.log( foo, bar, baz,); Arrow Functionsarrows–use-them当你一定要用函数表达式（在回调函数里）的时候就用箭头表达式吧。 eslint: prefer-arrow-callback, arrow-spacing Why? 他创建了一个this的当前执行上下文的函数的版本，这通常就是你想要的；而且箭头函数是更简洁的语法 Why? 什么时候不用箭头函数： 如果你有一个相当复杂的函数，你可能会把这个逻辑移出到他自己的函数声明里。 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); arrows–implicit-return如果函数体由一个没有副作用的表达式语句组成，删除大括号和return。否则，继续用大括号和 return 语句。 eslint: arrow-parens, arrow-body-style Why? 语法糖，当多个函数链在一起的时候好读 1234567891011121314151617181920212223242526272829303132333435363738// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);// good[1, 2, 3].map((number) =&gt; &#123; const nextNumber = number + 1; return `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map((number, index) =&gt; (&#123; [index]: number&#125;));// 表达式有副作用就不要用隐式returnfunction foo(callback) &#123; const val = callback(); if (val === true) &#123; // Do something if callback returns true &#125;&#125;let bool = false;// bad// 这种情况会return bool = true, 不好foo(() =&gt; bool = true);// goodfoo(() =&gt; &#123; bool = true;&#125;); arrows–paren-wrap万一表达式涉及多行，把他包裹在圆括号里更可读。 Why? 这样清晰的显示函数的开始和结束 1234567891011121314// bad['get', 'post', 'put'].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ));// good['get', 'post', 'put'].map(httpMethod =&gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod ))); arrows–one-arg-parens如果你的函数只有一个参数并且函数体没有大括号，就删除圆括号。否则，参数总是放在圆括号里。 注意： 一直用圆括号也是没问题，只需要配置 “always” option for eslint. eslint: arrow-parens Why? 这样少一些混乱， 其实没啥语法上的讲究，就保持一个风格。 12345678910111213141516171819202122// bad[1, 2, 3].map((x) =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(number =&gt; ( `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); arrows–confusing避免箭头函数(=&gt;)和比较操作符（&lt;=, &gt;=）混淆. eslint: no-confusing-arrow 1234567891011121314// badconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// badconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;// goodconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);// goodconst itemHeight = (item) =&gt; &#123; const &#123; height, largeSize, smallSize &#125; = item; return height &gt; 256 ? largeSize : smallSize;&#125;; whitespace–implicit-arrow-linebreak在隐式return中强制约束函数体的位置， 就写在箭头后面。 eslint: implicit-arrow-linebreak 12345678910111213// bad(foo) =&gt; bar;(foo) =&gt; (bar);// good(foo) =&gt; bar;(foo) =&gt; (bar);(foo) =&gt; ( bar) Classes &amp; Constructorsconstructors–use-class常用class，避免直接操作prototype Why? class语法更简洁更易理解 12345678910111213141516171819202122// badfunction Queue(contents = []) &#123; this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value;&#125;;// goodclass Queue &#123; constructor(contents = []) &#123; this.queue = [...contents]; &#125; pop() &#123; const value = this.queue[0]; this.queue.splice(0, 1); return value; &#125;&#125; constructors–extends用extends实现继承 Why? 它是一种内置的方法来继承原型功能而不打破instanceof 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; constructors–chaining方法可以返回this来实现方法链 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function () &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function (height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); constructors–tostring写一个定制的toString()方法是可以的，只要保证它是可以正常工作且没有副作用的 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || 'no name'; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; constructors–no-useless如果没有具体说明，类有默认的构造方法。一个空的构造函数或只是代表父类的构造函数是不需要写的。 eslint: no-useless-constructor 123456789101112131415161718192021222324// badclass Jedi &#123; constructor() &#123;&#125; getName() &#123; return this.name; &#125;&#125;// badclass Rey extends Jedi &#123; // 这种构造函数是不需要写的 constructor(...args) &#123; super(...args); &#125;&#125;// goodclass Rey extends Jedi &#123; constructor(...args) &#123; super(...args); this.name = 'Rey'; &#125;&#125; classes–no-duplicate-members避免重复类成员。 eslint: no-dupe-class-members Why? 重复类成员会默默的执行最后一个 —— 重复本身也是一个bug 123456789101112131415// badclass Foo &#123; bar() &#123; return 1; &#125; bar() &#123; return 2; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 1; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 2; &#125;&#125; Modulesmodules–use-them用(import/export) 模块而不是无标准的模块系统。你可以随时转到你喜欢的模块系统。 Why? 模块化是未来，让我们现在就开启未来吧。 1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; modules–no-wildcard不要用import通配符， 就是 * 这种方式 Why? 这确保你有单个默认的导出 12345// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; modules–no-export-from-import不要直接从import中直接export Why? 虽然一行是简洁的，有一个明确的方式进口和一个明确的出口方式来保证一致性。 12345678// bad// filename es6.jsexport &#123; es6 as default &#125; from './AirbnbStyleGuide';// good// filename es6.jsimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; modules–no-duplicate-imports一个路径只 import 一次。eslint: no-duplicate-imports Why? 从同一个路径下import多行会使代码难以维护 12345678910111213// badimport foo from 'foo';// … some other imports … //import &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2,&#125; from 'foo'; modules–no-mutable-exports不要到处可变的东西eslint: import/no-mutable-exports Why? 变化通常都是需要避免，特别是当你要输出可变的绑定。虽然在某些场景下可能需要这种技术，但总的来说应该导出常量。 1234567// badlet foo = 3;export &#123; foo &#125;// goodconst foo = 3;export &#123; foo &#125; modules–prefer-default-export在一个单一导出模块里，用 export default 更好。eslint: import/prefer-default-export Why? 鼓励使用更多文件，每个文件只做一件事情并导出，这样可读性和可维护性更好。 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; modules–imports-firstimport 放在其他所有语句之前。eslint: import/first Why? 让import放在最前面防止意外行为。 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); modules–multiline-imports-over-newlines多行import应该缩进，就像多行数组和对象字面量 Why? 花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。 1234567891011// badimport &#123;longNameA, longNameB, longNameC, longNameD, longNameE&#125; from 'path';// goodimport &#123; longNameA, longNameB, longNameC, longNameD, longNameE,&#125; from 'path'; modules–no-webpack-loader-syntax在import语句里不允许Webpack loader语法eslint: import/no-webpack-loader-syntax Why? 一旦用Webpack语法在import里会把代码耦合到模块绑定器。最好是在webpack.config.js里写webpack loader语法 1234567// badimport fooSass from 'css!sass!foo.scss';import barCss from 'style!css!bar.css';// goodimport fooSass from 'foo.scss';import barCss from 'bar.css'; Iterators and Generatorsiterators–nope不要用遍历器。用JavaScript高级函数代替for-in、 for-of。 eslint: no-iterator no-restricted-syntax Why? 这强调了我们不可变的规则。 处理返回值的纯函数比副作用更容易。 Why? 用数组的这些迭代方法： map() / every() / filter() / find() / findIndex() / reduce() / some() / … , 用对象的这些方法 Object.keys() / Object.values() / Object.entries() 去产生一个数组， 这样你就能去遍历对象了。 123456789101112131415161718192021222324252627282930const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach(num =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15;// badconst increasedByOne = [];for (let i = 0; i &lt; numbers.length; i++) &#123; increasedByOne.push(numbers[i] + 1);&#125;// goodconst increasedByOne = [];numbers.forEach(num =&gt; increasedByOne.push(num + 1));// best (keeping it functional)const increasedByOne = numbers.map(num =&gt; num + 1); generators–nope现在不要用generator Why? 它在es5上支持的不好 generators–spacing如果你一定要用，或者你忽略我们的建议, 请确保它们的函数签名空格是得当的。 eslint: generator-star-spacing Why? function 和 * 是同一概念关键字 - *不是function的修饰符，function*是一个和function不一样的独特结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badfunction * foo() &#123; // ...&#125;// badconst bar = function * () &#123; // ...&#125;// badconst baz = function *() &#123; // ...&#125;// badconst quux = function*() &#123; // ...&#125;// badfunction*foo() &#123; // ...&#125;// badfunction *foo() &#123; // ...&#125;// very badfunction*foo() &#123; // ...&#125;// very badconst wat = function*() &#123; // ...&#125;// goodfunction* foo() &#123; // ...&#125;// goodconst foo = function* () &#123; // ...&#125; Propertiesproperties–dot访问属性时使用点符号. eslint: dot-notation 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; properties–bracket当获取的属性是变量时用方括号[]取 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); es2016-properties–exponentiation-operator做幂运算时用幂操作符 ** 。 eslint: no-restricted-properties. 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; Variablesvariables–const用const声明变量。不这样做会导致全局变量。 我们想要避免污染全局命名空间。首长这样警告我们。 eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); variables–one-const每个变量都用一个 const 或 let。 eslint: one-var Why? 这种方式很容易去声明新的变量，你不用去考虑把;调换成,，或者引入一个只有标点的不同的变化。这种做法也可以是你在调试的时候单步每个声明语句，而不是一下跳过所有声明。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; variables–const-let-groupconst放一起，let放一起 Why? 在你需要分配一个新的变量， 而这个变量依赖之前分配过的变量的时候，这种做法是有帮助的 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; variables–define-where-used在你需要的地方声明变量，但是要放在合理的位置 Why? let 和 const 都是块级作用域而不是函数级作用域 1234567891011121314151617181920212223242526272829303132// bad - unnecessary function callfunction checkName(hasName) &#123; const name = getName(); if (hasName === 'test') &#123; return false; &#125; if (name === 'test') &#123; this.setName(''); return false; &#125; return name;&#125;// goodfunction checkName(hasName) &#123; if (hasName === 'test') &#123; return false; &#125; // 在需要的时候分配 const name = getName(); if (name === 'test') &#123; this.setName(''); return false; &#125; return name;&#125; variables–no-chain-assignment不要使用链接变量分配。 eslint: no-multi-assign Why? 链接变量分配创建隐式全局变量。 123456789101112131415161718192021222324// bad(function example() &#123; // JavaScript 将这一段解释为 // let a = ( b = ( c = 1 ) ); // let 只对变量 a 起作用; 变量 b 和 c 都变成了全局变量 let a = b = c = 1;&#125;());console.log(a); // undefinedconsole.log(b); // 1console.log(c); // 1// good(function example() &#123; let a = 1; let b = a; let c = a;&#125;());console.log(a); // undefinedconsole.log(b); // undefinedconsole.log(c); // undefined// `const` 也是如此 variables–unary-increment-decrement不要使用一元自增自减运算符（++， --）. eslint no-plusplus Why? 根据eslint文档，一元增量和减量语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的无声错误。 使用num + = 1而不是num ++或num ++语句来表达你的值也是更有表现力的。 禁止一元增量和减量语句还会阻止您无意地预增/预减值，这也会导致程序出现意外行为。 1234567891011121314151617181920212223242526 // bad let array = [1, 2, 3]; let num = 1; num++; --num; let sum = 0; let truthyCount = 0; for(let i = 0; i &lt; array.length; i++)&#123;let value = array[i];sum += value;if (value) &#123; truthyCount++;&#125; &#125; // good let array = [1, 2, 3]; let num = 1; num += 1; num -= 1; const sum = array.reduce((a, b) =&gt; a + b, 0); const truthyCount = array.filter(Boolean).length; variables–linebreak在赋值的时候避免在 = 前/后换行。 如果你的赋值语句超出 max-len， 那就用小括号把这个值包起来再换行。 eslint operator-linebreak. Why? 在 = 附近换行容易混淆这个赋值语句。 123456789101112131415// badconst foo = superLongLongLongLongLongLongLongLongFunctionName();// badconst foo = 'superLongLongLongLongLongLongLongLongString';// goodconst foo = ( superLongLongLongLongLongLongLongLongFunctionName());// goodconst foo = 'superLongLongLongLongLongLongLongLongString'; variables–no-unused-vars不允许有未使用的变量。 eslint: no-unused-vars Why? 一个声明了但未使用的变量更像是由于重构未完成产生的错误。这种在代码中出现的变量会使阅读者迷惑。 12345678910111213141516171819202122232425262728293031// badvar some_unused_var = 42;// 写了没用var y = 10;y = 5;// 变量改了自己的值，也没有用这个变量var z = 0;z = z + 1;// 参数定义了但未使用function getX(x, y) &#123; return x;&#125;// goodfunction getXPlusY(x, y) &#123; return x + y;&#125;var x = 1;var y = a + 2;alert(getXPlusY(x, y));// 'type' 即使没有使用也可以可以被忽略， 因为这个有一个 rest 取值的属性。// 这是从对象中抽取一个忽略特殊字段的对象的一种形式var &#123; type, ...coords &#125; = data;// 'coords' 现在就是一个没有 'type' 属性的 'data' 对象 Hoistinghoisting–aboutvar声明会被提前到他的作用域的最前面，它分配的值还没有提前。const 和 let被赋予了新的调用概念时效区 —— Temporal Dead Zones (TDZ)。 重要的是要知道为什么 typeof不再安全. 1234567891011121314151617181920212223242526// 我们知道这个不会工作，假设没有定义全局的notDefinedfunction example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 在你引用的地方之后声明一个变量，他会正常输出是因为变量作用域上升。// 注意： declaredButNotAssigned的值没有上升function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器把变量声明提升到作用域最前面，// 可以重写成如下例子， 二者意义相同function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// 用 const， let就不一样了function example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; hoisting–anon-expressions匿名函数表达式和 var 情况相同 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; hoisting–named-expresions已命名函数表达式提升他的变量名，不是函数名或函数体 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 函数名和变量名一样是也如此function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;;&#125; hoisting–declarations函数声明则提升了函数名和函数体 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 详情请见JavaScript Scoping &amp; Hoisting by Ben Cherry. Comparison Operators &amp; Equalitycomparison–eqeqeq用 === 和 !== 而不是 == 和 !=. eslint: eqeqeq comparison–if条件语句如’if’语句使用强制`ToBoolean’抽象方法来评估它们的表达式，并且始终遵循以下简单规则： Objects 计算成 true Undefined 计算成 false Null 计算成 false Booleans 计算成 the value of the boolean Numbers +0, -0, or NaN 计算成 false 其他 true Strings &#39;&#39; 计算成 false 其他 true 1234if ([0] &amp;&amp; []) &#123; // true // 数组（即使是空数组）是对象，对象会计算成true&#125; comparison–shortcuts布尔值用缩写，而字符串和数字要明确比较对象 1234567891011121314151617181920212223242526272829// badif (isValid === true) &#123; // ...&#125;// goodif (isValid) &#123; // ...&#125;// badif (name) &#123; // ...&#125;// goodif (name !== '') &#123; // ...&#125;// badif (collection.length) &#123; // ...&#125;// goodif (collection.length &gt; 0) &#123; // ...&#125; comparison–moreinfo更多信息请见Angus Croll的真理、平等和JavaScript —— Truth Equality and JavaScript comparison–switch-blocks在case和default分句里用大括号创建一块包含语法声明的区域(e.g. let, const, function, and class). eslint rules: no-case-declarations. Why? 语法声明在整个switch的代码块里都可见，但是只有当其被分配后才会初始化，他的初始化时当这个case被执行时才产生。 当多个case分句试图定义同一个事情时就出问题了 12345678910111213141516171819202122232425262728293031323334353637383940// badswitch (foo) &#123; case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() &#123; // ... &#125; break; default: class C &#123;&#125;&#125;// goodswitch (foo) &#123; case 1: &#123; let x = 1; break; &#125; case 2: &#123; const y = 2; break; &#125; case 3: &#123; function f() &#123; // ... &#125; break; &#125; case 4: bar(); break; default: &#123; class C &#123;&#125; &#125;&#125; comparison–nested-ternaries三元表达式不应该嵌套，通常是单行表达式。 eslint rules: no-nested-ternary. 12345678910111213141516// badconst foo = maybe1 &gt; maybe2 ? \"bar\" : value1 &gt; value2 ? \"baz\" : null;// betterconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; comparison–unneeded-ternary避免不需要的三元表达式 eslint rules: no-unneeded-ternary. 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; comparison–no-mixed-operators用圆括号来混合这些操作符。 只有当标准的算术运算符(+, -, *, &amp; /)， 并且它们的优先级显而易见时，可以不用圆括号括起来。 eslint: no-mixed-operators Why? 这提高了可读性，并且明确了开发者的意图 12345678910111213141516171819202122232425// badconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;// badconst bar = a ** b - 5 % d;// bad// 别人会陷入(a || b) &amp;&amp; c 的迷惑中if (a || b &amp;&amp; c) &#123; return d;&#125;// goodconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);// goodconst bar = (a ** b) - (5 % d);// goodif (a || (b &amp;&amp; c)) &#123; return d;&#125;// goodconst bar = a + b / c * d; Blocksblocks–braces用大括号包裹多行代码块。 eslint: nonblock-statement-body-position 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction foo() &#123; return false; &#125;// goodfunction bar() &#123; return false;&#125; blocks–cuddled-elsesif表达式的else和if的关闭大括号在一行。 eslint: brace-style 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; blocks–no-else-return如果 if 语句中总是需要用 return 返回， 那后续的 else 就不需要写了。 if 块中包含 return， 它后面的 else if 块中也包含了 return， 这个时候就可以把 return 分到多个 if 语句块中。 eslint: no-else-return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// badfunction foo() &#123; if (x) &#123; return x; &#125; else &#123; return y; &#125;&#125;// badfunction cats() &#123; if (x) &#123; return x; &#125; else if (y) &#123; return y; &#125;&#125;// badfunction dogs() &#123; if (x) &#123; return x; &#125; else &#123; if (y) &#123; return y; &#125; &#125;&#125;// goodfunction foo() &#123; if (x) &#123; return x; &#125; return y;&#125;// goodfunction cats() &#123; if (x) &#123; return x; &#125; if (y) &#123; return y; &#125;&#125;// goodfunction dogs(x) &#123; if (x) &#123; if (z) &#123; return y; &#125; &#125; else &#123; return z; &#125;&#125; Control Statementscontrol-statements当你的控制语句(if, while 等)太长或者超过最大长度限制的时候， 把每一个(组)判断条件放在单独一行里。 逻辑操作符放在行首。 Why? 把逻辑操作符放在行首是让操作符的对齐方式和链式函数保持一致。这提高了可读性，也让复杂逻辑更容易看清楚。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// badif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// badif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// badif ( foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// goodif ( foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125;// goodif ( (foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) &#123; thing1();&#125;// goodif (foo === 123 &amp;&amp; bar === 'abc') &#123; thing1();&#125; control-statements–value-selection不要用选择操作符代替控制语句。 1234567// bad!isRunning &amp;&amp; startRunning();// goodif (!isRunning) &#123; startRunning();&#125; Commentscomments–multiline多行注释用 /** ... */ 123456789101112131415161718192021222324// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ... return element;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125; comments–singleline单行注释用//，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行 123456789101112131415161718192021222324252627282930313233// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// also goodfunction getType() &#123; // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; comments–spaces所有注释开头空一个，方便阅读。 eslint: spaced-comment 12345678910111213141516171819202122232425262728293031// bad//is current tabconst active = true;// good// is current tabconst active = true;// bad/** *make() returns a new element *based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123; // ... return element;&#125; comments–actionitems在你的注释前使用FIXME&#39;或TODO’前缀， 这有助于其他开发人员快速理解你指出的需要重新访问的问题， 或者您建议需要实现的问题的解决方案。 这些不同于常规注释，因为它们是可操作的。 动作是FIXME： - 需要计算出来或TODO： - 需要实现。 comments–fixme用// FIXME:给问题做注释 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // FIXME: shouldn't use a global here total = 0; &#125;&#125; comments–todo用// TODO:去注释问题的解决方案 12345678class Calculator extends Abacus &#123; constructor() &#123; super(); // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; Whitespacewhitespace–spacestab用两个空格. eslint: indent 1234567891011121314// badfunction foo() &#123;∙∙∙∙const name;&#125;// badfunction bar() &#123;∙const name;&#125;// goodfunction baz() &#123;∙∙const name;&#125; whitespace–before-blocks在大括号前空一格。 eslint: space-before-blocks 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); whitespace–around-keywords在控制语句(if, while 等)的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格。 eslint: keyword-spacing 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; whitespace–infix-ops用空格来隔开运算符。 eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; whitespace–newline-at-end文件结尾空一行. eslint: eol-last 1234// badimport &#123; es6 &#125; from './AirbnbStyleGuide'; // ...export default es6; 12345// badimport &#123; es6 &#125; from './AirbnbStyleGuide'; // ...export default es6;↵↵ 1234// goodimport &#123; es6 &#125; from './AirbnbStyleGuide'; // ...export default es6;↵ whitespace–chains当出现长的方法链（&gt;2个）时用缩进。用点开头强调该行是一个方法调用，而不是一个新的语句。eslint: newline-per-chained-call no-whitespace-before-property 12345678910111213141516171819202122232425262728293031323334353637// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led);// goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led);// goodconst leds = stage.selectAll('.led').data(data); whitespace–after-blocks在一个代码块后下一条语句前空一行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// goodconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj;// badconst arr = [ function foo() &#123; &#125;, function bar() &#123; &#125;,];return arr;// goodconst arr = [ function foo() &#123; &#125;, function bar() &#123; &#125;,];return arr; whitespace–padded-blocks不要用空白行填充块。 eslint: padded-blocks 123456789101112131415161718192021222324252627// badfunction bar() &#123; console.log(foo);&#125;// also badif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125;// goodfunction bar() &#123; console.log(foo);&#125;// goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; whitespace–in-parens圆括号里不要加空格。 eslint: space-in-parens 12345678910111213141516171819// badfunction bar( foo ) &#123; return foo;&#125;// goodfunction bar(foo) &#123; return foo;&#125;// badif ( foo ) &#123; console.log(foo);&#125;// goodif (foo) &#123; console.log(foo);&#125; whitespace–in-brackets方括号里不要加空格。看示例。 eslint: array-bracket-spacing 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]);// good， 逗号分隔符还是要空格的const foo = [1, 2, 3];console.log(foo[0]); whitespace–in-braces花括号里加空格。 eslint: object-curly-spacing 12345// badconst foo = &#123;clark: 'kent'&#125;;// goodconst foo = &#123; clark: 'kent' &#125;; whitespace–max-len避免一行代码超过100个字符（包含空格）。 注意： 对于上面——strings–line-length，长字符串不受此规则限制，不应分解。 eslint: max-len Why? 这样确保可读性和可维护性 12345678910111213141516171819202122// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125; &#125;).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// good$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125;,&#125;) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); whitespace–block-spacing作为语句的花括号内也要加空格 —— { 后和 } 前都需要空格。 eslint: block-spacing 1234567// badfunction foo() &#123;return true;&#125;if (foo) &#123; bar = 0;&#125;// goodfunction foo() &#123; return true; &#125;if (foo) &#123; bar = 0; &#125; whitespace–comma-spacing, 前不要空格， , 后需要空格。 eslint: comma-spacing 1234567// badvar foo = 1,bar = 2;var arr = [1 , 2];// goodvar foo = 1, bar = 2;var arr = [1, 2]; whitespace–computed-property-spacing计算属性内要空格。参考上述花括号和中括号的规则。 eslint: computed-property-spacing 1234567891011// badobj[foo ]obj[ 'foo']var x = &#123;[ b ]: a&#125;obj[foo[ bar ]]// goodobj[foo]obj['foo']var x = &#123; [b]: a &#125;obj[foo[bar]] whitespace–func-call-spacing调用函数时，函数名和小括号之间不要空格。 eslint: func-call-spacing 12345678// badfunc ();func();// goodfunc(); whitespace–key-spacing在对象的字面量属性中， key value 之间要有空格。 eslint: key-spacing 123456// badvar obj = &#123; \"foo\" : 42 &#125;;var obj2 = &#123; \"foo\":42 &#125;;// goodvar obj = &#123; \"foo\": 42 &#125;; whitespace–no-trailing-spaces行末不要空格。 eslint: no-trailing-spaces whitespace–no-multiple-empty-lines避免出现多个空行。 在文件末尾只允许空一行。 eslint: no-multiple-empty-lines 1234567891011// badvar x = 1;var y = 2;// goodvar x = 1;var y = 2; Commascommas–leading-trailing不要前置逗号。 eslint: comma-style 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime,];// badconst hero = &#123; firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers'&#125;;// goodconst hero = &#123; firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers',&#125;; commas–dangling额外结尾逗号: 要 eslint: comma-dangle Why? 这导致git diffs更清洁。 此外，像Babel这样的转换器会删除转换代码中的额外的逗号，这意味着你不必担心旧版浏览器中的结尾逗号问题。 1234567891011121314// bad - 没有结尾逗号的 git diffconst hero = &#123; firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']&#125;;// good - 有结尾逗号的 git diffconst hero = &#123; firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// badconst hero = &#123; firstName: 'Dana', lastName: 'Scully'&#125;;const heroes = [ 'Batman', 'Superman'];// goodconst hero = &#123; firstName: 'Dana', lastName: 'Scully',&#125;;const heroes = [ 'Batman', 'Superman',];// badfunction createHero( firstName, lastName, inventorOf) &#123; // does nothing&#125;// goodfunction createHero( firstName, lastName, inventorOf,) &#123; // does nothing&#125;// good (note that a comma must not appear after a \"rest\" element)function createHero( firstName, lastName, inventorOf, ...heroArgs) &#123; // does nothing&#125;// badcreateHero( firstName, lastName, inventorOf);// goodcreateHero( firstName, lastName, inventorOf,);// good (note that a comma must not appear after a \"rest\" element)createHero( firstName, lastName, inventorOf, ...heroArgs) SemicolonsYup. eslint: semi Why? 当 JavaScript 遇到没有分号结尾的一行，它会执行自动插入分号 Automatic Semicolon Insertion这一规则来决定行末是否加分号。如果JavaScript在你的断行里错误的插入了分号，就会出现一些古怪的行为。当新的功能加到JavaScript里后， 这些规则会变得更复杂难懂。显示的结束语句，并通过配置代码检查去捕获没有带分号的地方可以帮助你防止这种错误。 1234567891011121314151617// bad(function () &#123; const name = 'Skywalker' return name&#125;)()// good(function () &#123; const name = 'Skywalker'; return name;&#125;());// good, 行首加分号，避免文件被连接到一起时立即执行函数被当做变量来执行。;(() =&gt; &#123; const name = 'Skywalker'; return name;&#125;()); Read more. Type Casting &amp; Coercioncoercion–explicit在语句开始执行强制类型转换。 coercion–stringsStrings: eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is \"object\" not \"string\"// badconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // 不保证返回string// goodconst totalScore = String(this.reviewScore); coercion–numbersNumbers: 用 Number 做类型转换，parseInt转换string常需要带上基数。 eslint: radix 12345678910111213141516171819const inputValue = '4';// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); coercion–comment-deviations请在注释中解释为什么要用移位运算和你在做什么。无论你做什么狂野的事，比如由于 parseInt 是你的性能瓶颈导致你一定要用移位运算。 请说明这个是因为性能原因, 123456// good/** * parseInt是代码运行慢的原因 * 用Bitshifting将字符串转成数字使代码运行效率大幅增长 */const val = inputValue &gt;&gt; 0; coercion–bitwise注意: 用移位运算要小心. 数字使用64-位表示的，但移位运算常常返回的是32为整形source)。移位运算对大于32位的整数会导致意外行为。Discussion. 最大的32位整数是 2,147,483,647: 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 coercion–booleans布尔: 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; Naming Conventionsnaming–descriptive避免用一个字母命名，让你的命名可描述。 eslint: id-length 123456789// badfunction q() &#123; // ...&#125;// goodfunction query() &#123; // ...&#125; naming–camelCase用小驼峰式命名你的对象、函数、实例。 eslint: camelcase 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; naming–PascalCase用大驼峰式命名类。 eslint: new-cap 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: 'nope',&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: 'yup',&#125;); naming–leading-underscore不要用前置或后置下划线。 eslint: no-underscore-dangle Why? JavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着“private”，事实上，这些属性是完全公有的，因此这部分也是你的API的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。 如果你想要什么东西变成“private”，那就不要让它在这里出现。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; naming–self-this不要保存引用this， 用箭头函数或函数绑定——Function#bind. 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function () &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; naming–filename-matches-exportexport default导出模块A，则这个文件名也叫A.*， import 时候的参数也叫A。 大小写完全一致。 123456789101112131415161718192021222324252627282930// file 1 contentsclass CheckBox &#123; // ...&#125;export default CheckBox;// file 2 contentsexport default function fortyTwo() &#123; return 42; &#125;// file 3 contentsexport default function insideDirectory() &#123;&#125;// in some other file// badimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filenameimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase exportimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export// badimport CheckBox from './check_box'; // PascalCase import/export, snake_case filenameimport forty_two from './forty_two'; // snake_case import/filename, camelCase exportimport inside_directory from './inside_directory'; // snake_case import, camelCase exportimport index from './inside_directory/index'; // requiring the index file explicitlyimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly// goodimport CheckBox from './CheckBox'; // PascalCase export/import/filenameimport fortyTwo from './fortyTwo'; // camelCase export/import/filenameimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"// ^ supports both insideDirectory.js and insideDirectory/index.js naming–camelCase-default-export当你export-default一个函数时，函数名用小驼峰，文件名需要和函数名一致。 12345function makeStyleGuide() &#123; // ...&#125;export default makeStyleGuide; naming–PascalCase-singleton当你export一个结构体/类/单例/函数库/对象 时用大驼峰。 123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; naming–Acronyms-and-Initialisms简称和缩写应该全部大写或全部小写。 Why? 名字都是给人读的，不是为了适应电脑的算法的。 1234567891011121314151617181920212223// badimport SmsContainer from './containers/SmsContainer';// badconst HttpRequests = [ // ...];// goodimport SMSContainer from './containers/SMSContainer';// goodconst HTTPRequests = [ // ...];// bestimport TextMessageContainer from './containers/TextMessageContainer';// bestconst Requests = [ // ...]; naming–uppercase你可以用全大写字母设置静态变量，他需要满足三个条件。 导出变量 是 const 定义的， 保证不能被改变 这个变量是可信的，他的子属性都是不能被改变的 Why? 这是一个附加工具，帮助开发者去辨识一个变量是不是不可变的。 对于所有的 const 变量呢？ —— 这个是不必要的。大写变量不应该在同一个文件里定义并使用， 它只能用来作为导出变量。 赞同！ 那导出的对象呢？ —— 大写变量处在export的最高级(e.g. EXPORTED_OBJECT.key) 并且他包含的所有子属性都是不可变的。 12345678910111213141516171819202122232425262728// badconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';// badexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';// badexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';// ---// allowed but does not supply semantic valueexport const apiKey = 'SOMEKEY';// better in most casesexport const API_KEY = 'SOMEKEY';// ---// bad - unnecessarily uppercases key while adding no semantic valueexport const MAPPING = &#123; KEY: 'value'&#125;;// goodexport const MAPPING = &#123; key: 'value'&#125;; Accessorsaccessors–not-required不需要使用属性的访问器函数。 accessors–no-getters-setters不要使用JavaScript的getters/setters，因为他们会产生副作用，并且难以测试、维护和理解。相反的，你可以用 getVal()和setVal(‘hello’)去创造你自己的accessor函数 123456789101112131415161718192021// badclass Dragon &#123; get age() &#123; // ... &#125; set age(value) &#123; // ... &#125;&#125;// goodclass Dragon &#123; getAge() &#123; // ... &#125; setAge(value) &#123; // ... &#125;&#125; accessors–boolean-prefix如果属性/方法是boolean， 用 isVal() 或 hasVal() 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; accessors–consistent用get()和set()函数是可以的，但是要一起用 1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; Eventsevents–hash通过哈希而不是原始值向事件装载数据时(不论是DOM事件还是像Backbone事件的很多属性)。 这使得后续的贡献者（程序员）想这个事件装载更多的数据时不用去找或者更新每个处理器。例如： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', (e, listingId) =&gt; &#123; // do something with listingId&#125;); prefer: 12345678// good$(this).trigger('listingUpdated', &#123; listingId: listing.id &#125;);...$(this).on('listingUpdated', (e, data) =&gt; &#123; // do something with data.listingId&#125;); jQueryjquery–dollar-prefixjQuery对象用$变量表示。 12345678// badconst sidebar = $('.sidebar');// goodconst $sidebar = $('.sidebar');// goodconst $sidebarBtn = $('.sidebar-btn'); jquery–cache暂存jQuery查找 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $('.sidebar'); $sidebar.hide(); // ... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; jquery–queriesDOM查找用层叠式$(&#39;.sidebar ul&#39;) 或 父节点 &gt; 子节点 $(&#39;.sidebar &gt; ul&#39;). jsPerf jquery–find用jQuery对象查询作用域的find方法查询 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ES5 兼容性es5-compat–kangax参考Kangax的ES5兼容性列表. ECMAScript 6+ (ES 2015+) Styleses6-styles这是收集到的各种ES6特性的链接 箭头函数——Arrow Functions 类——Classes 对象缩写——Object Shorthand 对象简写——Object Concise 对象计算属性——Object Computed Properties 模板字符串——Template Strings 解构赋值——Destructuring 默认参数——Default Parameters Rest Array Spreads Let and Const 幂操作符——Exponentiation Operator 迭代器和生成器——Iterators and Generators 模块——Modules tc39-proposals不要用TC39 proposals， TC39还没有到 stage 3。 Why? 它还不是最终版, 他可能还有很多变化，或者被撤销。 我们想要用的是 JavaScript， 提议还不是JavaScript。 Standard Library标准库中包含一些功能受损但是由于历史原因遗留的工具类 standard-library–isnan用 Number.isNaN 代替全局的 isNaN.eslint: no-restricted-globals Why? 全局 isNaN 强制把非数字转成数字， 然后对于任何强转后为 NaN 的变量都返回 true如果你想用这个功能，就显式的用它。 1234567// badisNaN('1.2'); // falseisNaN('1.2.3'); // true// goodNumber.isNaN('1.2.3'); // falseNumber.isNaN(Number('1.2.3')); // true standard-library–isfinite用 Number.isFinite 代替 isFinite.eslint: no-restricted-globals Why? 理由同上，会把一个非数字变量强转成数字，然后做判断。 123456// badisFinite('2e3'); // true// goodNumber.isFinite('2e3'); // falseNumber.isFinite(parseInt('2e3', 10)); // true Testingtesting–yupYup. 123function foo() &#123; return true;&#125; testing–for-realNo, but seriously: 无论用那个测试框架，你都需要写测试。 尽量去写很多小而美的纯函数，减少突变的发生 小心 stub 和 mock —— 这会让你的测试变得脆弱。 在 Airbnb 首选 mocha。 tape 偶尔被用来测试一些小的，独立的模块。 100%测试覆盖率是我们努力的目标，即便实际上很少达到。 每当你修了一个bug， 都要写一个回归测试。 一个bug修复了，没有回归测试，很可能以后会再次出问题。 资源 原文：https://github.com/airbnb/javascript 中文简版：https://github.com/lin-123/javascript React CSS-in-JavaScript CSS &amp; Sass Rubybabel-preset-airbnbairbnb-browser-shims","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"},{"name":"Airbnb","slug":"Airbnb","permalink":"https://zj-john.github.io/tags/Airbnb/"},{"name":"style guide","slug":"style-guide","permalink":"https://zj-john.github.io/tags/style-guide/"}]},{"title":"自ES2015以来，JavaScript对象中的属性顺序是可预测的","date":"2018-10-29T02:42:25.000Z","path":"notes/ckbdbl42n005g2kty97itec71.html","text":"下面这段React的代码，最终渲染的效果依赖于对象中属性的顺序。1234styles(&#123; backgroundBlue: true, backgroundRed: true&#125;); 但从执行效果来看，背景将显示为红色，因为它是“放在最后的属性”。如果你已经用了一段时间的JavaScript，你可能会立刻想到 - 等等，什么！？属性是有顺序的吗？ 常见的误解 - “JavaScript中无法保证属性的顺序”几年前写JavaScript时，您可能听到过JS对象中的属性顺序是不可预测的说法。虽然我还没遇到过一些对顺序有强制要求的需求，但我始终遵循“从不依赖属性顺序”的规则。 内部方法ownPropertyKeys实际上，从ES2015以来，就已经有一些包含属性顺序规则的方法了，这得益于内部方法ownPropertyKeys的实现。 对象中属性的顺序取决于所包含属性的类型及其值。具体的顺序规则可以查看定义在“内部方法ownPropertyKeys”中的准则。有些新的方法已经在使用这种规则，例如Object.getOwnPropertyNames和Reflect.ownKeys。 规则如下：1234567891011[[OwnPropertyKeys]] ( )When the [[OwnPropertyKeys]] internal method of O is called the following steps are taken:1. Let keys be a new empty List.2. For each own property key P of O that is an integer index, in ascending numeric index order a. Add P as the last element of keys.3. For each own property key P of O that is a String but is not an integer index, in property creation order a. Add P as the last element of keys.4. For each own property key P of O that is a Symbol, in property creation order a. Add P as the last element of keys.5.Return keys. 有趣的是，一些方法的规格在变化，例如Object.keys从ES5到ES6的变化。ES6规范定义了Object.keys也依赖于ownPropertyKeys，这使得属性顺序在支持ES6的浏览器中可预测。 但这也意味着您必须小心使用此方法，并且不应该强依赖于它来对属性顺序的预测，因为Object.keys可能会因浏览器实现的差异导致结果不同。 原理讲的差不多了，现在让我们来看看代码。 整数以整数索引为key的所有属性，首先出现在整个对象属性顺序中，并之间以数字方式排序。123456789const objWithIndices = &#123; 23: 23, '1': 1, 1000: 1000&#125;;console.log(Reflect.ownKeys(objWithIndices));// [1, 23, 1000]// ☝️ following numeric order ‘1’是整数索引，而’01’不是。你可以这样理解，对一个数组 const a=[1,2,3], a[‘0’]===a[0],值是1，但a[‘01’]值是undefined。 字符串（不是整数）key不计入整数索引且不是Symbol类型的属性，是第二顺序，且它们间按照时间顺序排列。1234567891011const objWithStrings = &#123; 'bar': 'bar', '01': '01'&#125;;objWithStrings.last = 'last';objWithStrings['veryLast'] = 'veryLast';console.log(Reflect.ownKeys(objWithStrings));// ['bar', '01', 'last', 'veryLast']// ☝️ following chronological order Symbols最后是Symbols，之间也遵循时间顺序。12345678910const objWithSymbols = &#123; [Symbol('first')]: 'first', [Symbol('second')]: 'second'&#125;;objWithSymbols[Symbol('last')] = 'last';console.log(Reflect.ownKeys(objWithSymbols));// [Symbol(first), Symbol(second), Symbol(last)]// ☝️ following chronological order 组合规则 组合这些规则时，您将看到整数始终位于对象属性的“前排”，后跟字符串和Symbols。此外，我们可以控制字符串和Symbols属性的顺序，因为它们是按时间顺序排列的！1234567891011121314151617const obj = &#123; '2': 'integer: 2', 'foo': 'string: foo', '01': 'string: 01', 1: 'integer: 1', [Symbol('first')]: 'symbol: first'&#125;;obj['0'] = '0';obj[Symbol('last')] = 'symbol: last';obj['veryLast'] = 'string: very last';console.log(Reflect.ownKeys(obj));// [ \"0\", \"1\", \"2\", \"foo\", \"01\", \"veryLast\", Symbol(first), Symbol(last) ]// -&gt; 1. integers in numeric order// -&gt; 2. strings in chronological order// -&gt; 3. Symbols in chronological order 但是，正如这篇文章指出的，“自有属性顺序”规则仅在一些现代浏览器中得到完全支持，而其他则不行，比如IE不支持。 资源 原文: https://www.stefanjudis.com/today-i-learned/property-order-is-predictable-in-javascript-objects-since-es2015/ The traversal order of object properties in ES6 ECMAScript® 2019 Language Specification - OrdinaryOwnPropertyKeys “Does ES6 introduce a well-defined order of enumeration for object properties?” on Stack Overflow","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.26","slug":"2018-10-26","permalink":"https://zj-john.github.io/tags/2018-10-26/"},{"name":"object","slug":"object","permalink":"https://zj-john.github.io/tags/object/"},{"name":"property order","slug":"property-order","permalink":"https://zj-john.github.io/tags/property-order/"}]},{"title":"使用D3和Vue创建交互式地图","date":"2018-10-26T09:51:56.000Z","path":"notes/ckbdbl41b002w2ktytwquaugb.html","text":"为什么要这么做把地图加到你的网站或者应用里有许多种方法，比如使用Google Maps, Mapbox, Leaflet等。而且用法很简单，有些服务商甚至只需您点击几下即可完成。 但是当你需要自定义设计，显示一些数据集或做你想做的其它事情时，它会变得越来越糟糕。而且，在Vue或React中你只能调用抽象好的javascript API，而不能使用JSX来渲染。 另外，好多库对私人项目也不是免费的。 所以，当我再一次要在地图上显示一些数据时，我决定：我要完全控制我的代码，然后用更好的方式创建我自己的地图。 第1步：创建静态地图让我们用vue-cli 3，Babel和sass开始创建我们的应用程序开始 我们需要D3和d3-tile（它不包含在d3的npm包中）来渲染地图块。 1yarn add d3 d3-tile 实际上我们不需要整个d3代码。对于一个简单的地图，我们只需要用d3-geo生成地图投影，用d3-tile生成切片。 接下来我们应该定义一些设置，如比例，宽度，高度和初始坐标。通常，我在mount时通过计算图表容器所在元素的大小动态确定图表大小。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt;const d3 = &#123; ...require('d3-geo'), ...require('d3-tile'),&#125;;export default &#123; props: &#123; center: &#123; type: Array, default: () =&gt; [33.561041, -7.584838], &#125;, scale: &#123; type: [Number, String], default: 1 &lt;&lt; 20, &#125;, &#125;, data () &#123; return &#123; width: 0, height: 0, &#125;; &#125;, mounted () &#123; const rect = this.$el.getBoundingClientRect(); this.width = rect.width; this.height = rect.height; &#125;, render () &#123; if (this.width &lt;= 0 || this.height &lt;= 0) &#123; // the dummy for calculating element size return &lt;div class=\"map\" /&gt;; &#125; return ( &lt;div class=\"map\"&gt;our map will be here&lt;/div&gt; ); &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.map &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; 现在定义投影生成器和切片生成器。1234567891011121314151617181920export default &#123; // ... computed: &#123; projection () &#123; return d3.geoMercator() .scale(+this.scale / (2 * Math.PI)) .translate([this.width / 2, this.height / 2]) .center(this.center) ; &#125;, tiles () &#123; return d3.tile() .size([this.width, this.height]) .scale(+this.scale) .translate(this.projection([0, 0]))() ; &#125;, &#125;, // ...&#125;; 我总是把可计算的属性用到d3的函数中，因此当某些参数更改时，Vue会重新计算它们并更新我们的组件。 现在我们拥有了显示地图所需的一切，我们来渲染生成的图块：123456789101112131415161718192021222324252627export default &#123; render () &#123; if (this.width &lt;= 0 || this.height &lt;= 0) &#123; return &lt;div class=\"map\" /&gt;; &#125; return ( &lt;div class=\"map\"&gt; &lt;svg viewBox=&#123;`0 0 $&#123;this.width&#125; $&#123;this.height&#125;`&#125;&gt; &lt;g&gt; &#123;this.tiles.map(t =&gt; ( &lt;image key=&#123;`$&#123;t.x&#125;_$&#123;t.y&#125;_$&#123;t.z&#125;`&#125; class=\"map__tile\" xlinkHref=&#123;`https://a.tile.openstreetmap.org/$&#123;t.z&#125;/$&#123;t.x&#125;/$&#123;t.y&#125;.png `&#125; x=&#123;(t.x + this.tiles.translate[0]) * this.tiles.scale&#125; y=&#123;(t.y + this.tiles.translate[1]) * this.tiles.scale&#125; width=&#123;this.tiles.scale&#125; height=&#123;this.tiles.scale&#125; /&gt; ))&#125; &lt;/g&gt; &lt;/svg&gt; &lt;/div&gt; ); &#125;,&#125;; 在这里，我们由d3-tile生成切片,再从切片服务器请求图像。 您可以在这里找到其他服务商，或者甚至可以使用自定义样式托管自己的服务。 不要忘记添加版权。12345678&lt;div class=\"map__copyright\"&gt; ©&amp;nbsp; &lt;a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\" &gt;OpenStreetMap&amp;nbsp;&lt;/a&gt; contributors&lt;/div&gt; 1234567891011121314.map &#123; // ... position: relative; font-family: Arial, sans, sans-serif; &amp;__copyright &#123; position: absolute; bottom: 8px; right: 8px; padding: 2px 4px; background-color: rgba(#ffffff, .6); font-size: 14px; &#125;&#125; 现在我们有了卡萨布兰卡的静态地图。 第2步：添加地图控件对我来说最令人兴奋的是Vue如何简化创建交互式地图的方式。我们只是更新了投影参数，地图就会同步更新。我们将来制作缩放按钮和拖动方式的位置控制。 让我们从拖动开始吧。我们需要在组件数据中定义投影转换属性，在svg元素上定义一些鼠标事件监听（或者你可以在tiles组上监听它们）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script&gt;// ...export default &#123; // ... data () &#123; return &#123; // ... translateX: 0, translateY: 0, touchStarted: false, touchLastX: 0, touchLastY: 0, &#125;; &#125;, computed: &#123; projection () &#123; return d3.geoMercator() .scale(+this.scale / (2 * Math.PI)) .translate([this.translateX, this.translateY]) .center(this.center) ; &#125;, // ... &#125;, mounted () &#123; // ... this.translateX = this.width / 2; this.translateY = this.height / 2; &#125;, methods: &#123; onTouchStart (e) &#123; this.touchStarted = true; this.touchLastX = e.clientX; this.touchLastY = e.clientY; &#125;, onTouchEnd () &#123; this.touchStarted = false; &#125;, onTouchMove (e) &#123; if (this.touchStarted) &#123; this.translateX = this.translateX + e.clientX - this.touchLastX; this.translateY = this.translateY + e.clientY - this.touchLastY; this.touchLastX = e.clientX; this.touchLastY = e.clientY; &#125; &#125;, &#125;, render () &#123; // ... return ( &lt;div class=\"map\"&gt; &lt;svg viewBox=&#123;`0 0 $&#123;this.width&#125; $&#123;this.height&#125;`&#125; onMousedown=&#123;this.onTouchStart&#125; onMousemove=&#123;this.onTouchMove&#125; onMouseup=&#123;this.onTouchEnd&#125; onMouseleave=&#123;this.onTouchEnd&#125; &gt; // ... &lt;/svg&gt; // ... &lt;/div&gt; ); &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.map &#123; // ... &amp;__tile &#123; // reset pointer events on images to prevent image dragging in Firefox pointer-events: none; &#125; // ...&#125;&lt;/style&gt; 哇！我们只是更新了translate的值，新图块就已经加载了。我们可以探索世界了。但是还没有变焦控制，让我们来实现它。 我们把scale加到组件的data中，并添加zoom属性和渲染缩放按钮。 根据我的经验，最小和最大平铺的缩放级别是10和27（老实说，我不太确定这对所有服务商都是正确的）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;script&gt;// ...const MIN_ZOOM = 10;const MAX_ZOOM = 27;export default &#123; props: &#123; center: &#123; type: Array, default: () =&gt; [-7.584838, 33.561041], &#125;, initialZoom: &#123; type: [Number, String], default: 20, &#125;, &#125;, data () &#123; return &#123; // ... zoom: +this.initialZoom, scale: 1 &lt;&lt; +this.initialZoom, &#125;; &#125;, // ... watch: &#123; zoom (zoom, prevZoom) &#123; const k = zoom - prevZoom &gt; 0 ? 2 : .5; this.scale = 1 &lt;&lt; zoom; this.translateY = this.height / 2 - k * (this.height / 2 - this.translateY); this.translateX = this.width / 2 - k * (this.width / 2 - this.translateX); &#125;, &#125;, // ... methods: &#123; // ... zoomIn () &#123; this.zoom = Math.min(this.zoom + 1, MAX_ZOOM); &#125;, zoomOut () &#123; this.zoom = Math.max(this.zoom - 1, MIN_ZOOM); &#125;, &#125;, render () &#123; // ... return ( &lt;div class=\"map\"&gt; &lt;div class=\"map__controls\"&gt; &lt;button class=\"map__button\" disabled=&#123;this.zoom &gt;= MAX_ZOOM&#125; onClick=&#123;this.zoomIn&#125; &gt;+&lt;/button&gt; &lt;button class=\"map__button\" disabled=&#123;this.zoom &lt;= MIN_ZOOM&#125; onClick=&#123;this.zoomOut&#125; &gt;-&lt;/button&gt; &lt;/div&gt; //... &lt;/div&gt; ); &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;.map &#123; // ... &amp;__controls &#123; position: absolute; left: 16px; top: 16px; display: flex; flex-direction: column; justify-content: space-between; height: 56px; &#125; &amp;__button &#123; border: 0; padding: 0; width: 24px; height: 24px; line-height: 24px; border-radius: 50%; font-size: 18px; background-color: #ffffff; color: #343434; box-shadow: 0 1px 4px rgba(0, 0, 0, .4); &amp;:hover, &amp;:focus &#123; background-color: #eeeeee; &#125; &amp;:disabled &#123; background-color: rgba(#eeeeee, .4); &#125; &#125; // ...&#125;&lt;/style&gt; 只是两个步骤，我们就使用Vue，D3和OpenStreetMap创建了简单的交互式地图。 结论使用D3和Vue来创建自己的地图组件并不困难。最重要的事情之一就是完全控制DOM，而不是使用一些抽象的地图渲染器API。 当然，要制作一个功能强大的地图，我们需要实现更多功能，如平滑缩放，最大边界等。不过所有的功能都是可定制的，所以你可以尝试你想做或需要的一切。 资源 原文： https://dev.to/denisinvader/creating-an-interactive-map-with-d3-and-vue-4158 Source code: https://github.com/denisinvader/vue-d3-map Live preview: https://denisinvader.github.io/vue-d3-map/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.10.19","slug":"2018-10-19","permalink":"https://zj-john.github.io/tags/2018-10-19/"},{"name":"d3","slug":"d3","permalink":"https://zj-john.github.io/tags/d3/"},{"name":"vue","slug":"vue","permalink":"https://zj-john.github.io/tags/vue/"},{"name":"map","slug":"map","permalink":"https://zj-john.github.io/tags/map/"}]},{"title":"在JavaScript中搜索和排序含有变音符号的文本","date":"2018-10-23T03:33:00.000Z","path":"notes/ckbdbl42f00542ktyyrvxng5l.html","text":"最近我们忙着使用React重构之前的一个项目的前端代码，其中包括重构我们的浏览筛选功能，如下： 客户可以使用这些过滤器，品牌，颜色或价格等，来帮助他们更轻松地找到自己想要的产品。 因为我们的某些过滤器包含很多可选选项，所以需要让它们易于搜索和排序十分重要。 如果您希望用户可以从可能包含变音符号的数据列表中搜索结果，本文展示了一项很棒的技巧。 排序以下列品牌为例：123456789const brands = [ &#123; label: \"Côte et Ciel\", value: 1532 &#125;, &#123; label: \"Études\", value: 17 &#125;, &#123; label: \"AllSaints\", value: 2501 &#125;, &#123; label: \"Samsøe &amp; Samsøe\", value: 1571 &#125;, &#123; label: \"Ben Sherman\", value: 2124 &#125;, &#123; label: \"Drôle de Monsieur\", value: 137 &#125;, &#123; label: \"!Solid\", value: 668 &#125;,]; 怎么做才能直观地对它们进行排序呢？ 最初在JavaScript中对它们进行排序似乎很简单：只需对brands数组调用sort()，然后传递一个 比较两个标签的函数 进去即可，例如：1234567891011121314brands.sort((a, b) =&gt; &#123; return a.label &gt; b.label;&#125;);/* 结果：[ &#123; label: \"!Solid\", value: 668 &#125;, &#123; label: \"AllSaints\", value: 2501 &#125;, &#123; label: \"Ben Sherman\", value: 2124 &#125;, &#123; label: \"Côte et Ciel\", value: 1532 &#125;, &#123; label: \"Drôle de Monsieur\", value: 137 &#125;, &#123; label: \"Samsøe &amp; Samsøe\", value: 1571 &#125;, &#123; label: \"Études\", value: 17 &#125;,]*/ 除了Études错误地放置在列表底部之外，其它排序顺序是对的。JavaScript中是按字母顺序比较字符串的，不过这么说不太准确。实际上，它是用字符在Unicode表中的位置来确定其排序的。 如果我们查看字符z和é，我们可以看到以下内容： Character Encoding hex dec (bytes) dec binary z UTF-8 7A 122 122 01111010 é UTF-8 C3 A9 195 169 50089 11000011 10101001 注意字符的十进制值; é具有更高的值，所以它的顺序会排在z之后。 幸运的是，JavaScript有String.prototype.localeCompare函数：我们可以将上述函数简单重写为：1234567891011121314brands.sort((a, b) =&gt; &#123; return a.label.localeCompare(b.label);&#125;);/*[ &#123; label: \"!Solid\", value: 668 &#125;, &#123; label: \"AllSaints\", value: 2501 &#125;, &#123; label: \"Ben Sherman\", value: 2124 &#125;, &#123; label: \"Côte et Ciel\", value: 1532 &#125;, &#123; label: \"Drôle de Monsieur\", value: 137 &#125;, &#123; label: \"Études\", value: 17 &#125;, &#123; label: \"Samsøe &amp; Samsøe\", value: 1571 &#125;,]*/ 了解localeCompare的其他参数请阅读文档。 搜索排序很容易解决，但是搜索呢？ 我们提供了一个搜索input，可以方便的匹配您的输入，返回满足的列表，但搜索Cote不会产生结果Côte et Ciel。123456789101112131415161718192021222324252627const brands = [ &#123; label: \"Côte et Ciel\", value: 1532 &#125;, &#123; label: \"Études\", value: 17 &#125;, &#123; label: \"AllSaints\", value: 2501 &#125;, &#123; label: \"Samsøe &amp; Samsøe\", value: 1571 &#125;, &#123; label: \"Ben Sherman\", value: 2124 &#125;, &#123; label: \"Drôle de Monsieur\", value: 137 &#125;, &#123; label: \"!Solid\", value: 668 &#125;,];brands.filter(brand =&gt; &#123; return brand.label.indexOf(\"Cote\") &gt; -1;&#125;)/*=&gt; []*/brands.filter(brand =&gt; &#123; return brand.label.indexOf(\"Côte\") &gt; -1;&#125;)/*[ &#123; label: \"Côte et Ciel\", value: 1532 &#125;,]*/ 我们不能期望客户知道我们使用了变音符号的品牌拼写，也不能期望客户能够轻松输入正确的字符，因为这是不合理的。 因此，为了让客户能够找到这些品牌，我们需要从字符中删除变音符号，然后再将其与搜索查询进行比较。 我们可以分两部分来完成。 首先，我们需要“分解”字符串，以便任何带有变音符号的字符由其双字节对表示。这是UTF-8中使用的一种技术，将单个字符表示为一个双字节对。 我们可以使用JavaScript中的normalize函数执行此操作，并使用“NFD”格式。 通过文档，我们可以看到“NFD”代表“规范化形式规范分解”，重点是“分解”。 我们可以通过比较分解前后的字符串长度来看到效果：123456789\"Côte et Ciel\".length/*12*/\"Côte et Ciel\".normalize('NFD').length/*13*/ 这表明该ô字符现在由两个字节而不是一个字节表示。 然后，现在我们为字符和变音符号都规范化了字节，我们可以使用以下String.prototype.replace函数删除不需要的字符：12345678910111213141516171819const brands = [ &#123; label: \"Côte et Ciel\", value: 1532 &#125;, &#123; label: \"Études\", value: 17 &#125;, &#123; label: \"AllSaints\", value: 2501 &#125;, &#123; label: \"Samsøe &amp; Samsøe\", value: 1571 &#125;, &#123; label: \"Ben Sherman\", value: 2124 &#125;, &#123; label: \"Drôle de Monsieur\", value: 137 &#125;, &#123; label: \"!Solid\", value: 668 &#125;,];brands.filter(brand =&gt; &#123; const decomposedLabel = brand.label.normalize('NFD').replace(/[\\u0300-\\u036f]/g, ''); return decomposedLabel.indexOf(\"Cote\") &gt; -1;&#125;)/*[ &#123; label: \"Côte et Ciel\", value: 1532 &#125;,]*/ replace 函数中包含一系列Unicode点，从U+0300 到 U+036F，涵盖我们可能遇到的音调符号字节。 资源 原文 https://thread.engineering/2018-08-29-searching-and-sorting-text-with-diacritical-marks-in-javascript/ normalize: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize localeCompare: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.19","slug":"2018-10-19","permalink":"https://zj-john.github.io/tags/2018-10-19/"},{"name":"变音符号","slug":"变音符号","permalink":"https://zj-john.github.io/tags/变音符号/"},{"name":"localeCompare","slug":"localeCompare","permalink":"https://zj-john.github.io/tags/localeCompare/"},{"name":"normalize","slug":"normalize","permalink":"https://zj-john.github.io/tags/normalize/"}]},{"title":"智能打包，如何仅为旧版浏览器提供旧版代码","date":"2018-10-23T03:33:00.000Z","path":"notes/ckbdbl42l005e2ktyyy49oyuy.html","text":"虽然“有效打包资源”这个话题在网上一直很火，但不管如何打包，我们最终向不同用户提供的前端资源仍然几乎相同。 即使用来优化网站的构建工具从未如此优秀和先进，但网站随附的JavaScript和CSS资源的平均（大小）权重仍在不断上升。 随着常青浏览器(可自动升级到未来版本的浏览器，可以理解为持续更新)市场份额的快速增长以及浏览器对web新功能的同步支持，是时候要重新考虑下现代网络中的资源交付了。 如今，大部分的web流量都是通过常青浏览器访问的，它们大多都支持ES6 +，新的JavaScript标准，新的Web平台API和CSS属性 。但是，在可观望的未来，旧版浏览器仍需要去支持，因为它们的使用份额还不少，远不能达到忽略的程度。当然，这个需求最终取决于您的用户群。 从caniuse.com中各版本浏览器的使用情况可以看出，常青浏览器的使用占据了浏览器市场的绝大部分，超过75％。尽管如此，但标准的做法还是添加CSS前缀，将所有的JavaScript转换到ES5标准，并包含polyfill，从而支持我们的每一个用户。 虽然从过往的发展历史来看这是可以理解的，因为web一直是渐进式增强的。但问题仍然存在：我们需要为了支持越来越少的旧版浏览器，而让大多数用户一起放慢web的步伐吗？ 支持旧版浏览器带来的成本让我们试着从典型构建流程中了解，下面每个步骤是如何增加我们前端资源的负担的： 编译为ES5版本为了评估这种转换带来的负担，我拿了一些用ES6+编写的流行JavaScript库，并比较了它们在转换前后的包大小： Library Size(minified ES6) Size (minified ES5) Difference TodoMVC 8.4 KB 11 KB 24.5% Draggable 77.9 KB 53.5 KB 31.3% Luxon 75.4 KB 100.3 KB 24.8% Video.js 237.2 KB 335.8 KB 29.4% PixiJS 370.8 KB 452 KB 18% 平均而言，未转换的包（ES6）比转换后的ES5的包小约25％。这并不奇怪，因为ES6+提供了更加紧凑和富有表现力的逻辑方式，而且将这些功能中的某些特性转换为ES5可能需要大量代码。 ES6 + Polyfills虽然Babel确实对ES6+语法有一个很好的支持，但ES6+引入的一些内置功能，比如Promise, Map 和 Set，和新的数组和字符串的方法，仍然需要polyfilled来做转换。而babel-polyfill本身，差不多就有90 KB。 Web Platform Polyfills现代Web提供了大量新的浏览器API来简化我们的应用程序开发。通常使用的，例如fetch，用于请求资源，IntersectionObserver用于有效地观察元素的可见性，以及URL规范，使得在web上读取和操作URL更容易。 为这些新功能添加符合规范的polyfill会对包大小产生明显影响。 CSS Prefixing最后，让我们看一下CSS前缀的影响。虽然前缀不会像其他构建转换那样增加包的大小，特别是因为它们在Gzip压缩时压缩得很好，但这里仍然可以节省一些成本。 Library Size (minified, prefixed for last 5 browser versions) Size (minified, prefixed for last browser version) Difference Bootstrap 159 KB 132 KB 17% Bulma 184 KB 164 KB 10.9% Foundation 139 KB 118 KB 15.1% Semantic UI 622 KB 569 KB 8.5% 一个发送有效代码的实用指南做法是显而易见的。如果我们利用现有的构建管道，将这些兼容性层仅发送到需要它的浏览器，那就可以为其余用户（应该是大多数）提供更轻松的体验，同时保持了旧浏览器的兼容性。 这个想法并不是全新的。Polyfill.io等服务就尝试过在运行时动态填充（polyfill）浏览器环境的做法。但是这样的方法有一些缺点： 除非您自己托管和维护polyfill服务，否则polyfills的选择仅限于服务已经列出的那些。 由于polyfilling在运行时提供服务并且是阻塞操作，因此旧浏览器上的用户页面的加载时间可能会明显增加。 向每个用户提供定制的polyfill文件会向系统引入熵，这会在出现问题时更难排查。 而且，这并没有解决代码转换带来的大小问题，有时反而会更大。 目前为止，我们已经发现了很多造成臃肿的来源，下面让我们看看，如何能够解决这些问题。 我们需要的工具 Webpack这是我们选择的构建工具，你也可以选择其他构建工具（如Parcel和Rollup），它们使用起来很类似。 Browserslist有了这个，我们将管理和定义我们想要支持的浏览器。 With this, we’ll manage and define the browsers we’d like to support. 然后，我们将使用一些 支持Browserslist的插件 。 1. 定义“流行”和“过期”首先，我们要明确“流行”和“过期”浏览器的含义。这将有助于将浏览器分成两个独立的组而且便于维护和测试。我们把几乎不需要填充或转换的添加到“流行”列表的浏览器，并将其余部分放在我们的“过期”列表中。 项目根目录下的Browserslist配置中可以存储此信息。“Environment”子部分可用于记录两个浏览器组，如下所示： 12345678[modern]Firefox &gt;= 53Edge &gt;= 15Chrome &gt;= 58iOS &gt;= 10.1[legacy]&gt; 1% 此处给出的列表只是一个示例，您可以根据网站要求和时间进行自定义和更新。这个配置将作为我们接下来要创建的两组前端打包的判断依据：一个用于“流行”浏览器，另一个用于所有其他用户。 2. ES6+ Transpiling And Polyfilling为了以环境感知的方式转换我们的JavaScript，我们将使用babel-preset-env。让我们在项目的根目录下初始化一个.babelrc文件：12345&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot;&#125;] ]&#125; 启用该useBuiltIns标志允许Babel选择性地polyfill ES6+引入的的部分内置功能。因为它可以选择环境所需的polyfill，所以我们可以降低babel-polyfill的整体运输成本。 要使此标志起作用，我们还需要在入口引入 babel-polyfill。12// Inimport &quot;babel-polyfill&quot;; 这样做会将babel-polyfill整体引入替换为按我们所定位的浏览器环境进行过滤的部分引入。12345// Transformed outputimport &quot;core-js/modules/es7.string.pad-start&quot;;import &quot;core-js/modules/es7.string.pad-end&quot;;import &quot;core-js/modules/web.timers&quot;;… 3.Polyfilling Web Platform Features要向我们的用户发送适用Web平台功能的polyfill，我们需要为这两个环境分别创建入口点：123require(&apos;whatwg-fetch&apos;);require(&apos;es6-promise&apos;).polyfill();// … other polyfills 还有这个：12// polyfills for modern browsers (if any)require(&apos;intersection-observer&apos;); 这是我们流程中唯一需要一定程度手动维护的步骤。通过将eslint-plugin-compat 添加到项目中，我们可以使这个过程不那么容易出错。当我们使用尚未polyfilled的浏览器功能时，此插件会警告我们。 4. CSS浏览器前缀最后，让我们看看如何为不需要前缀的浏览器减少CSS前缀。因为在browserslist生态系统中，autoprefixer是支持从配置文件读取内容的第一批工具，所以我们在这里没有太多工作要做。 在项目的根目录下创建一个简单的PostCSS配置文件应该足够了：123module.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ],&#125; 组合在一起现在我们已经定义了所有必需的插件配置，我们可以合成一个webpack配置来读取上面的配置并输出两个单独的内置文件夹dist/modern和dist/legacy。 1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require('mini-css-extract-plugin')const isModern = process.env.BROWSERSLIST_ENV === 'modern'const buildRoot = path.resolve(__dirname, \"dist\")module.exports = &#123; entry: [ isModern ? './polyfills.modern.js' : './polyfills.legacy.js', \"./main.js\" ], output: &#123; path: path.join(buildRoot, isModern ? 'modern' : 'legacy'), filename: 'bundle.[hash].js', &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?$/, use: \"babel-loader\" &#125;, &#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] &#125; ]&#125;, plugins: &#123; new MiniCssExtractPlugin(), new HtmlWebpackPlugin(&#123; template: 'index.hbs', filename: 'index.html', &#125;), &#125;,&#125;; 然后，我们将在我们的package.json文件中创建一些构建命令：12345\"scripts\": &#123; \"build\": \"yarn build:legacy &amp;&amp; yarn build:modern\", \"build:legacy\": \"BROWSERSLIST_ENV=legacy webpack -p --config webpack.config.js\", \"build:modern\": \"BROWSERSLIST_ENV=modern webpack -p --config webpack.config.js\"&#125; 就是这些。现在，运行yarn build就会开始功能上等价的两个构建过程。 为用户提供合适的打包资源创建单独的构建只是有助于实现我们目标的前半部分。下面，我们需要识别并向用户提供正确的打包资源。 还记得我们之前定义的浏览器列表配置吗？如果我们可以使用相同的配置来确定用户属于哪个类别，那不是很好吗？ 了解下browserslist-useragent。顾名思义，browserslist-useragent可以读取我们的browserslist配置，然后将用户代理（User-Agent）与相关环境相匹配。使用Koa服务器演示以下示例：1234567891011121314151617const Koa = require('koa')const app = new Koa()const send = require('koa-send')const &#123; matchesUA &#125; = require('browserslist-useragent')var router = new Router()app.use(router.routes())router.get('/', async (ctx, next) =&gt; &#123; const useragent = ctx.get('User-Agent') const isModernUser = matchesUA(useragent, &#123; env: 'modern', allowHigherVersions: true, &#125;) const index = isModernUser ? 'dist/modern/index.html':'dist/legacy/index.html' await send(ctx, index);&#125;); 在这里，设置allowHigherVersions标志可以确保如果浏览器发布较新版本，即使是那些尚未进入Can I Use数据库的版本，它们仍然会报告为“流行”浏览器。 browserslist-useragent的其中一个功能是确保在匹配用户代理时考虑平台怪癖。例如，iOS上的所有浏览器（包括Chrome）都使用WebKit作为底层引擎，但在Browserslist查询中，会与相应的特定Safari浏览器进行匹配。 单纯依赖生产中user-agent解析的正确性可能并不谨慎。对未在“流行”列表中定义的浏览器和具有未知或不可解析的用户代理字符串的情况，我们通过回退到“过期”浏览器打包文件，来确保我们的网站仍然有效。 结论：值得吗？我们已经为客户传输最小的打包文件，设法覆盖到端到端的流量。看起来已经很棒了，但是，权衡项目的维护成本和利益是合理的。让我们评估一下这种方法的优缺点： 1.维护和测试只需要维护一个Browserslist配置即可为该构建中的所有工具提供支持。“流行”和“过期”浏览器的定义可以在将来的任何时候更新，且无需重构配置或代码。我认为这使维护的开销几乎可以忽略不计。 不过，通过Babel生成两个不同的，且都需要在各自的环境中正常工作的代码包有很小的理论风险。 虽然由于打包差异导致的错误可能很少，但监控这些错误有助于有效识别并缓解问题。 2. 花费构建时间 vs 花费运行时间与当今流行的其他技术(比如，上文提到的Polyfill.io)不同，所有这些优化都在构建时发生，并且对客户端是不可见的。 3. 逐步提高速度在这种方式下，使用“流行”浏览器的用户会比以前感觉速度更快，而旧版浏览器上的用户继续像以前一样，也没有任何负面效果。 4. 轻松使用现代浏览器功能在这种方式之前，我们经常会由于担心所需的polyfill的太大，而不敢使用新的浏览器功能，甚至有时候会选择较小的不符合规格的polyfill来节省尺寸。这种新方法允许我们使用符合规范的polyfill，而不必担心影响所有用户。 生产服务中的差异化打包鉴于其显着的优势，我们在为印度最大的家具和装饰零售商之一Urban Ladder的客户创建新的移动结账体验时采用了这种构建方式。 在我们已经优化的打包中，对于移动用户，我们能够将Gzip压缩过的CSS和JavaScript资源再节省大约20％。因为超过80％的用户都使用这些常青浏览器上，所以付出的努力非常值得。 资源 原文: https://www.smashingmagazine.com/2018/10/smart-bundling-legacy-code-browsers/ 当前浏览器市场份额表： Can I Use Browserslist “Tools” @babel/preset-env Loading Polyfills Only When Needed","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.19","slug":"2018-10-19","permalink":"https://zj-john.github.io/tags/2018-10-19/"},{"name":"browsers","slug":"browsers","permalink":"https://zj-john.github.io/tags/browsers/"},{"name":"performance","slug":"performance","permalink":"https://zj-john.github.io/tags/performance/"}]},{"title":"为什么使用reduce来解决顺序Promises问题","date":"2018-10-23T03:33:00.000Z","path":"notes/ckbdbl42q005m2kty4v7qn3n8.html","text":"不使用Promise对象的来编写异步JavaScript的情况非常类似于闭着眼睛烘烤蛋糕。虽然能做到，但它会变得混乱，你可能会把自己玩坏。 我可没说 必须 用Promise，但你理解我的意思。它真的很棒。但有时候，它需要一些帮助来解决一些独特的挑战，例如当你试图按顺序，解决一串promises时。这样的例子很常见，例如，当您需要对一批AJAX返回的数据排序时，您希望服务器处理这些事情，但不能同时处理，而是按照时间顺序一件件处理。 如果不使用有助于简化此任务的软件包（如Caolan McMahon的异步库），那么解决顺序promise问题的最普遍的方案是使用Array.prototype.reduce()。你可能听说过它。它接收一组参数，对参数中的每个元素应用函数，最终将其简化为单个值并返回，如下所示： 12345let result = [1,2,5].reduce((accumulator, item) =&gt; &#123; return accumulator + item;&#125;, 0); // &lt;-- Our initial value.console.log(result); // 8 不过，对于上面提过的顺序promise问题使用reduce()，代码看起来是这样的：1234567let userIDs = [1,2,3];userIDs.reduce( (previousPromise, nextID) =&gt; &#123; return previousPromise.then(() =&gt; &#123; return methodThatReturnsAPromise(nextID); &#125;);&#125;, Promise.resolve()); 或者，以更新的格式：123456let userIDs = [1,2,3];userIDs.reduce( async (previousPromise, nextID) =&gt; &#123; await previousPromise; return methodThatReturnsAPromise(nextID);&#125;, Promise.resolve()); 这很整洁！但是在最长的时间里，我只是囫囵使用这个解决方案并将代码复制到我的应用程序中，并没有去深入理解。所以，在这篇文章中，我来通过探索两件事情来深入理解： 为什么可行？ 为什么我们不能用其他Array方法做同样的事情呢？ 为什么可行请记住，reduce()的主要目的是将一堆东西“减少”为一个东西，这是通过在循环运行中将结果存储在accumulator来实现的。但这accumulator不一定是数字。循环可以返回它想要的任何内容（如promise），并在每次迭代时通过回调把该值循环使用。值得注意的是，无论accumulator的值是什么，循环本身的行为都不会改变（包括其执行速度）。它会在线程允许的情况下持续整个行为。 这可能很难理解，因为它可能违背了你对循环中发生的事情的认知。当我们使用reduce()来解决顺序promises时，循环实际上并没有减慢。它是完全同步的，尽可能快地完成，就像往常一样。 请看以下代码段，并注意循环进度根本不会受回调中返回的promise的阻碍。12345678910111213141516function methodThatReturnsAPromise(nextID) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`Resolve! $&#123;dayjs().format('hh:mm:ss')&#125;`); resolve(); &#125;, 1000); &#125;);&#125;[1,2,3].reduce( (accumulatorPromise, nextID) =&gt; &#123; console.log(`Loop! $&#123;dayjs().format('hh:mm:ss')&#125;`); return accumulatorPromise.then(() =&gt; &#123; return methodThatReturnsAPromise(nextID); &#125;);&#125;, Promise.resolve()); 在我们的控制台：123456\"Loop! 11:28:06\"\"Loop! 11:28:06\"\"Loop! 11:28:06\"\"Resolve! 11:28:07\"\"Resolve! 11:28:08\"\"Resolve! 11:28:09\" promises按照我们的预期顺序执行，而且循环本身是快速，稳定和同步的。建议看下MDN中为reduce()做的polyfill,这样能帮助你理解。下面是polyfill中的部分后台逻辑代码，可以看出while()一遍又一遍循环触发callback()，整个过程没有异步：123456while (k &lt; len) &#123; if (k in o) &#123; value = callback(value, o[k], k, o); &#125; k++;&#125; 考虑到以上因素，这个例子中真正有意思的事情发生在这里：123return previousPromise.then(() =&gt; &#123; return methodThatReturnsAPromise(nextID)&#125;); 每当我们的回调触发时，我们都会返回一个promise做为 另一个 promise的resolve。虽然reduce()不触发任何实际逻辑函数，但它确实提供了能够在每次运行后将某些内容传递回同一个回调的功能，这是reduce()的一项独特功能。因此，我们能够构建一系列promise，然后resolve进更多的promise，使一切变得美观和有秩序：12345678910111213new Promise( (resolve, reject) =&gt; &#123; // Promise #1 resolve();&#125;).then( (result) =&gt; &#123; // Promise #2 return result;&#125;).then( (result) =&gt; &#123; // Promise #3 return result;&#125;); // ... and so on! 所有这也揭示了为什么我们不能每次迭代都返回 一个新的promise。因为循环是同步运行的，所以每个promise都会立即触发，而不是等待它之前创建的那些。1234567891011[1,2,3].reduce( (previousPromise, nextID) =&gt; &#123; console.log(`Loop! $&#123;dayjs().format('hh:mm:ss')&#125;`); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`Resolve! $&#123;dayjs().format('hh:mm:ss')&#125;`); resolve(nextID); &#125;, 1000); &#125;);&#125;, Promise.resolve()); 在我们的控制台：123456\"Loop! 11:31:20\"\"Loop! 11:31:20\"\"Loop! 11:31:20\"\"Resolve! 11:31:21\"\"Resolve! 11:31:21\"\"Resolve! 11:31:21\" 是否可以等到所有前置处理完成后再做某项事情？答案是肯定的。reduce()的同步性并不意味着在完成所有项目的处理后你不能继续做点其他事。看下面代码：123456789101112131415161718function methodThatReturnsAPromise(id) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`Processing $&#123;id&#125;`); resolve(id); &#125;, 1000); &#125;);&#125;let result = [1,2,3].reduce( (accumulatorPromise, nextID) =&gt; &#123; return accumulatorPromise.then(() =&gt; &#123; return methodThatReturnsAPromise(nextID); &#125;);&#125;, Promise.resolve());result.then(e =&gt; &#123; console.log(\"Resolution is complete! Let's party.\")&#125;); 因为我们在回调函数中返回的所有内容都是一个链式promise，所以我们在循环完成时得到的全部内容只是一个promise。在循环完成之后，我们可以按照我们想要的方式后续处理它。 为什么我们不能用其他Array方法做同样的事情呢？请记住，在reduce()中，进入下一次迭代之前，我们不会等待回调完成。它是完全同步的。所有其他这些方法都是如此： Array.prototype.map() Array.prototype.forEach() Array.prototype.filter() Array.prototype.some() Array.prototype.every() 但reduce()很特别。 我们发现，reduce()对我们有用的原因是因为我们能够在相同的回调中将某些东西返回（即promise），然后我们可以通过将其resolve到另一个promise的方式来构建。但是，使用所有其他方法，我们无法将从回调函数返回的参数再传递给下一个回调。相反，每个回调参数都是预先确定的，这是我们无法利用它们来解决顺序promise问题的原因。1234[1,2,3].map((item, [index, array]) =&gt; [value]);[1,2,3].filter((item, [index, array]) =&gt; [boolean]);[1,2,3].some((item, [index, array]) =&gt; [boolean]);[1,2,3].every((item, [index, array]) =&gt; [boolean]); 资源 原文 https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/ Reduce https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.19","slug":"2018-10-19","permalink":"https://zj-john.github.io/tags/2018-10-19/"},{"name":"browsers","slug":"browsers","permalink":"https://zj-john.github.io/tags/browsers/"},{"name":"performance","slug":"performance","permalink":"https://zj-john.github.io/tags/performance/"}]},{"title":"5个技巧，让你在JS中编写更好的条件语句","date":"2018-10-22T06:34:58.000Z","path":"notes/ckbdbl406000t2ktyv7pf6pkb.html","text":"当使用JavaScript时，我们总会遇到许多条件语句。本文中，有针对条件语句的5个技巧，可以让你的代码更清晰。 对多条件的判断语句使用Array.includes我们来看下面的例子：123456// conditionfunction test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 乍一看，上面的代码还不错。但是，当我们的水果集中有更多的红色水果，比如cherry和cranberries？我们要使用更多的||来扩展声明吗？ 事实上，我们可以使用[(Array.includes)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)来重写上面的条件语句。12345678function test(fruit) &#123; // extract conditions to array const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 我们将red fruits（判断条件）提取到数组中，通过Array.includes来使用它。这样写，代码看起来更整洁。 少嵌套，早返回让我们扩展下前面的示例，给它增加2个额外的条件： 如果水果参数为空，抛出错误 接收水果数量参数，如果数量超过10，则打印。 1234567891011121314151617181920212223function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // condition 1: fruit must has value if (fruit) &#123; // condition 2: must be red if (redFruits.includes(fruit)) &#123; console.log('red'); // condition 3: must be big quantity if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125;// test resultstest(null); // error: No fruitstest('apple'); // print: redtest('apple', 20); // print: red, big quantity 在上面的代码中，我们有： 1个过滤无效条件的if/else语句 1个3级嵌套的if语句（条件1,2和3） 在处理此类问题时，我个人遵循的一般规则是 在发现无效条件时提前返回 。 123456789101112131415161718/_ return early when invalid conditions found _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // condition 1: throw error early if (!fruit) throw new Error('No fruit!'); // condition 2: must be red if (redFruits.includes(fruit)) &#123; console.log('red'); // condition 3: must be big quantity if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 这样做可以使我们减少一个级别的嵌套。而且这种编码风格很好，特别是当你有很长的if语句时，你无需滚动到最底层才知道有一个else语句。 通过反转判断条件并提前返回，我们可以进一步减少嵌套。请查看下面的第2个条件语句，看看我们是如何做到的：123456789101112131415/_ return early when invalid conditions found _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // condition 1: throw error early if (!redFruits.includes(fruit)) return; // condition 2: stop when fruit is not red console.log('red'); // condition 3: must be big quantity if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 通过反转第2个条件语句的条件，我们的代码不再嵌套语句。特别是，当我们代码逻辑很长时，及时返回非常有用。 但是，这并不是一个硬性标准，你要自己来判断优劣。 对我来说，我更喜欢带有嵌套的条件语句。这是因为： 代码逻辑简短直接，嵌套if更清晰 反转条件可能会引发更多的思考过程（增加认知负荷） 因此，旨在减少嵌套和尽早返回，但不要过度。如果您感兴趣，下面的一篇文章和StackOverflow中的讨论会进一步讨论： Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 使用默认的函数参数和解构我想下面的代码可能看起来很熟悉，在JS中我们总是需要检查null / undefined值和分配默认值： 12345678910function test(fruit, quantity) &#123; if (!fruit) return; const q = quantity || 1; // if quantity not provided, default to one console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 实际上，我们可以通过给函数分配默认参数来消除变量q。12345678function test(fruit, quantity = 1) &#123; // if quantity not provided, default to one if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125;//test resultstest('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 更简单直观不是吗？请注意，每个参数都可以指定自己的函数默认参数。例如，我们也可以指定fruit的默认值：function test(fruit = &#39;unknown&#39;, quantity = 1)。 如果fruit是一个对象怎么办？我们可以指定默认参数吗？ 12345678910111213function test(fruit) &#123; // printing fruit name if value provided if (fruit &amp;&amp; fruit.name) &#123; console.log (fruit.name); &#125; else &#123; console.log('unknown'); &#125;&#125;//test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 看看上面的例子，如果水果的名称属性可用，则打印，否则打印unknown。我们可以使用使用函数默认参数和解构来替代fruit &amp;&amp; fruit.name的条件检查。 12345678910// destructing - get name property only// assign default empty object &#123;&#125;function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125;//test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 因为我们只需要name属性，所以可以使用解构参数{name}，然后我们可以使用变量name在代码中代替fruit.name。 我们还将空对象{}指定为默认值。如果不这样做，你在执行时会报错test(undefined) - Cannot destructure property name of &#39;undefined&#39; or &#39;null&#39;..因为undefined中没有name属性。 如果您不介意使用第三方库，有几种方法可以减少空检查： 使用Lodash get函数 使用Facebook开源的idx（与Babeljs结合使用） 以下是使用Lodash的示例： 123456789// Include lodash library, you will get _function test(fruit) &#123; console.log(_.get(fruit, 'name', 'unknown')); // get property name, if not available, assign default value 'unknown'&#125;//test resultstest(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 您可以在此处运行演示代码。此外，如果您是函数式编程（FP）的粉丝，您可以选择使用Lodash fp，Lodash的函数式版本（方法为get或getOr）。 选择Map/Object而不是Switch语句让我们看看下面的例子，我们想根据颜色打印水果：1234567891011121314151617function test(color) &#123; // use switch case to find fruits in color switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;//test resultstest(null); // []test('yellow'); // ['banana', 'pineapple'] 上面的代码没有语法错误，但我觉得它很冗长。使用对象字面量可以实现相同的结果：12345678910// use object literal to find fruits in color const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;;function test(color) &#123; return fruitColor[color] || [];&#125; 您还可以使用Map来实现相同的结果：123456789// use Map to find fruits in color const fruitColor = new Map() .set('red', ['apple', 'strawberry']) .set('yellow', ['banana', 'pineapple']) .set('purple', ['grape', 'plum']);function test(color) &#123; return fruitColor.get(color) || [];&#125; Map 是ES2015标准中可用的对象类型，允许您存储键值对。 我们应该禁止使用switch语句吗？就我个人而言，我尽可能使用对象字面量，但我不会设置硬规则来阻止它。你需要根据具体情形选择。 Todd Motto有一篇文章深入研究switch语句与对象文字，你可以在[这里]here阅读。 重构对于上面的例子，我们实际上可以使用Array.filter来重构我们的代码。1234567891011121314 const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;];function test(color) &#123; // use Array filter to find fruits in color return fruits.filter(f =&gt; f.color == color);&#125; 总有不止一种方法可以达到相同的效果，这就是编码的乐趣！ 使用Array.every和Array.some最后一个提示是利用新的（但也没那么新的）Javascript Array函数来减少代码行。看下面的代码，我们想检查是否所有水果都是红色的：1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; let isAllRed = true; // condition: all fruits must be red for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 代码太长了！我们可以通过Array.every减少行数：123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ];function test() &#123; // condition: short way, all fruits must be red const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 现在精简多了。以类似的方式，如果我们想测试水果中是否有红色，我们可以用Array.some来实现它。123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;];function test() &#123; // condition: if any fruit is red const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125; 资源 原文：https://scotch.io/bar-talk/5-tips-to-write-better-conditionals-in-javascript","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"if","slug":"if","permalink":"https://zj-john.github.io/tags/if/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.19","slug":"2018-10-19","permalink":"https://zj-john.github.io/tags/2018-10-19/"}]},{"title":"调试hover效果，如tooltip等","date":"2018-10-19T07:30:26.000Z","path":"tips/ckbdbl45t00bs2ktyyg89w8ix.html","text":"在chrome上调试hover效果是一个很麻烦的事情，因为鼠标移动，hover的效果（dom结构）就没了，怎么保持住hover效果，然后调试dom呢？ 方法是:在页面上要调试的元素上，hover后，右键，选择“检查”， 此时，就可以在dom结构中调试hover出来的dom结构了。 打开开发者工具时，尽量让开发者窗口贴着要调试的元素。因为离得远的话，很可能把鼠标移动到dom结构之前，就触发了其它的页面效果，导致希望的hover效果丢失。","tags":[{"name":"tooltip","slug":"tooltip","permalink":"https://zj-john.github.io/tags/tooltip/"},{"name":"hover","slug":"hover","permalink":"https://zj-john.github.io/tags/hover/"},{"name":"调试","slug":"调试","permalink":"https://zj-john.github.io/tags/调试/"}]},{"title":"Nuxt.js入门","date":"2018-10-17T04:51:15.000Z","path":"notes/ckbdbl41t003r2ktyuxhvlc4i.html","text":"Nuxt.js是一个基于 Vue.js 的通用应用框架（包括前端和后端），其主要目的是构建一个可扩展的，高品质的Vue.js应用程序。Nuxt有哪些优点，是如何实现的，该如何安装它，以及如何在下一个项目中使用它呢？ 本文为您答疑解惑。 Nuxt.js是基于Vue.js，Vue Router，Vuex, Vue Server Renderer和vue-meta插件的一个通用框架，它提供了丰富的工具集，来满足构建任何类型的Web应用程序。 它之所以被称为通用框架，是因为它的构建足够灵活，可以满足从静态站点到单页应用程序的任何项目。 它主要关注开发的UI渲染方面，同时试图抽象出客户端/服务器分布。 是什么让Nuxt.js如此特别？ 基于Vue： Nuxt.js是基于Vue.js构建的，所以继承了vue本身的所有优势。事实上，Nuxt.js旨在使您能够编写最佳的Vue.js代码。 自动路由处理 ：Nuxt.js基于Vue-router处理路由，改进点是会根据pages文件夹中的Vue文件结构自动生成所需的configuration/routes配置/路由。这意味着你不必费心去设置Vue-router配置，因为Nuxt会为你做这件事。 服务器端渲染：Nuxt.js使用Vue Server Renderer插件来处理服务器端的渲染，但是像之前提过的那样，它封装了所有艰涩的操作并提供自动处理，同时还可轻松修改meta标记的属性。 静态站点：Nuxt.js有一个nuxt generate命令，可以为路由中的每个页面生成HTML静态版本，并将它们存储在一个文件中，您可以在任何静态托管平台上托管该文件。 基于Webpack：Nuxt.js使用带有vue-loader和babel-loader的webpack来打包，压缩，转换ES6/ES7并对代码进行代码分割，能满足你遇到的所有情况。 HTTP/2：Nuxt.js为我们提供了一个属性，可以在我们的应用程序中激活HTTP/2推送头。HTTP/2 Push是一种功能，它允许服务器在没有相应请求的情况下将资源推送到客户端（即没有对该资源的立即请求）。 开发中的热模块替换：由于webpack和vue-loader，Nuxt.js在应用运行时，对对代码所做的更改实时更新视图，而无需重新加载整页。 安装Nuxt.jsNuxt.js团队在Vue CLI 3上创建了一个初始化模板，通过这个模板，可以快速使用Vue CLI来构建启动Nuxt.js项目，而无需担心分散复杂的开发环境和依赖。 因为该模板是适配Vue CLI构建的，所以如果您尚未安装Vue Cli，则请先安装。 要安装Vue CLI，请启动终端并运行以下命令：1npm install -g @vue/cli @vue/cli-init 接下来，安装初始化模板并使用它来生成新项目： project-name不能包含大写字母哦 1vue init nuxt-community/starter-template &lt;project-name&gt; 当安装完成并创建项目后，将目录切换到创建的新项目文件夹并安装所有依赖项。12cd &lt;project-name&gt; // Change Directorynpm install // Install dependencies 最后，当所有以上步骤完成后，我们使用npm run dev启动项目。应用程序应该成功运行在http://localhost:3000。 文件目录结构浏览下新项目，我们注意到已经创建了一些文件夹/文件; 它们旨在为我们的应用程序提供一个很好的模板结构。 让我们快速浏览每个文件夹的内容。 Assets: 存放我们所有的外部资源文件（例如图像，CSS和我们的应用程序可能需要的任何其他文件）。 Components:： 包含可在我们的应用程序中使用的可重用组件（例如按钮，输入，侧边栏等）。 Layouts: 包含我们的布局文件，这些布局将在我们的应用程序中全面重用。 注意: 此文件夹不能也不应该重命名。 Middleware: 顾名思义，它包含了我们应用程序的中间件。中间件是在呈现组件之前需要运行的函数（例如，在显示页面之前检查用户是否已登录）。 Pages: 此文件夹包含我们的应用程序的视图和路由，因为Nuxt.js会读取此文件夹中的所有文件，并根据文件自动创建我们的应用程序路由。注意: 此文件夹也无法重命名。 Plugins: 包含我们在程序根Vue.js运行之前需要运行的所有JavaScript插件（前置依赖）。 Static: 它与Assets文件夹非常相似，区别是Assets文件夹用于需要由webpack解析的文件（即需要某种编译[SASS→CSS]或处理的文件），而Static文件夹用于已经处理或处于最终状态的资源和文件。 添加Assets 感谢webpack，vue-loader，file-loader和url-loader，Nuxt.js简化了我们在项目文件夹中使用资源的方式。 要使用assets文件夹中的文件，您需要在Assets文件夹名称之前添加〜/，如下所示：1&lt;img src=\"~/assets/image.png\"&gt; 但是，如果要使用Static文件夹中的文件，您只需使用/，就好像这些文件存在于根目录中一样。1&lt;img src=\"/image.png\"&gt; 你可能想知道为什么。 好吧，Assets文件夹中的文件需要特殊字符〜，主要是因为默认情况下webpack中的Vue-loader插件会将文件解析为模块依赖项，而〜只是一个别名，告诉Vue-loader Assets文件夹所在的位置。 使用Vue-loader解析资源的一个很酷的部分是，它还有助于处理资源的版本控制以获得更好的缓存处理，同时，如果某个资源小于1KB，它们将处理为内联base-64的数据以减少这些较小文件的HTTP请求数。 另一方面，Static文件夹由Nuxt自动提供，并在构建生产时移动到项目的根目录中。12345&lt;!-- Image in the static folder --&gt;&lt;img src=\"/image.png\"/&gt;&lt;!-- Image in the assets Folder --&gt;&lt;img src=\"~/assets/image-2.png\"/&gt; 组件组件是通过名称可重用Vue实例。当我们在Nuxt中创建页面时，我们也创建了一个组件，并且每个组件都有一系列使其工作的函数。 Nuxt.js引入了一些额外的功能，属性或方法，以提供更多功能来帮助组件的开发。您可以视情况使用。 这些额外属性是什么？ asyncData: asyncData钩子允许您在渲染页面之前，从服务器上获取页面所需的数据。 这样，当Google尝试索引您的网页时，网页会始终包含内容 - asyncData钩子会为其提供数据。 fetch: 此方法处理与store的交互。它允许您即使在渲染组件之前，也可以自由地向Vuex store提供数据。 这对于在呈现所述组件之前另一个组件需要来自另一个组件的数据时是完美的。This is perfect for when another component needs data from say another component before said component is rendered. loading: Nuxt.js在应用中提供加载状态，此方法允许您中断加载状态并手动控制它。 layout: 设置应在中使用layouts目录中的哪个布局。 transition: 允许您为页面组件设置特定转换。 scrollToTop: 此方法允许您指定是否希望在渲染页面之前自动滚动到页面顶部。 validate: validate钩子允许您创建一个验证器方法，该方法检查动态路由中传递的参数类型。 当你想要确保它传递给url参数的是数字而不是字符串时，这很有用，反之亦然。 middleware: 允许您指定该组件的中间件。 路由Nuxt.js中的路由非常有趣。它会查看Pages文件夹中的文件结构，并根据该结构自动决定路由配置。 您所要做的就是按照您希望的URL的结构构建Pages文件夹。 它利用Vue Router插件生成路由; 因此，生成的配置与您已知的在Vue.js应用程序中使用Vue Router配置相同。 虽然有一点点扭曲：你可以使用而不是像通常那样使用。 Nuxt.js还会处理404页面请求错误，例如当页面或路由不可用但用户导航到它时。Nuxt有一个默认的404页面，但也提供了自定义或使用自己的404页面的方法。 现在，让我们深入研究一些例子，因为我相信你已经想知道如何处理动态路由等等问题了。 基本路由基本的文件目录结构是一个文件夹下包含需要的视图文件，如下所示：1234567891011pages/--| work/-----| index.vue-----| progress.vue-----| telerik.vue--| index.vue Nuxt会基于上面的目录结构生成以下路由：123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: 'index', path: '/', component: 'pages/index.vue' &#125;, &#123; name: 'work', path: '/work', component: 'pages/user/index.vue' &#125;, &#123; name: 'work-progress', path: '/work/progress', component: 'pages/work/progress.vue' &#125;, &#123; name: 'work-telerik', path: '/work/telerik', component: 'pages/work/telerik.vue' &#125; ]&#125; 动态路由动态路由是在其URL中采用动态参数的路由。为此，我们必须使用下划线为.vue文件或文件夹的名称添加前缀。 12345678910111213pages/--| _slug/-----| comments.vue-----| index.vue--| users/-----| _id.vue--| index.vue 路由如下：12345678910111213141516171819202122232425router: &#123; routes: [ &#123; name: &apos;index&apos;, path: &apos;/&apos;, component: &apos;pages/index.vue&apos; &#125;, &#123; name: &apos;users-id&apos;, path: &apos;/users/:id?&apos;, component: &apos;pages/users/_id.vue&apos; &#125;, &#123; name: &apos;slug&apos;, path: &apos;/:slug&apos;, component: &apos;pages/_slug/index.vue&apos; &#125;, &#123; name: &apos;slug-comments&apos;, path: &apos;/:slug/comments&apos;, component: &apos;pages/_slug/comments.vue&apos; &#125; ]&#125; 嵌套路由123456789pages/--| work/-----| _id.vue-----| index.vue--| work.vue 路由如下： 1234567891011121314151617181920router: &#123; routes: [ &#123; path: &apos;/work&apos;, component: &apos;pages/work.vue&apos;, children: [ &#123; path: &apos;&apos;, component: &apos;pages/work/index.vue&apos;, name: &apos;work&apos; &#125;, &#123; path: &apos;:id&apos;, component: &apos;pages/work/_id.vue&apos;, name: &apos;work-id&apos; &#125; ] &#125; ]&#125; 设置页面元标记Nuxt.js为我们提供了能够更新页面的标题，meta和HTML属性的属性。它在后台使用vue-meta来完成所有这些伟大的工作。 要在页面组件中设置头元素（如meta和链接），您必须使用nuxt.js提供的页面组件中的head属性。 123456789101112131415161718192021222324&lt;template&gt; &lt;section class=\"container\"&gt; &lt;div&gt; &lt;h1 class=\"title\"&gt;Nuxt.js Page&lt;/h1&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; head: &#123; meta: [ &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125; ], link: [ &#123; rel: 'stylesheet', href: 'https://fonts.googleapis.com/css?family=Open+Sans' &#125; ] &#125;, data() &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt; 自定义错误页面默认情况下，Nuxt.js配置了自己的错误页面，但它也允许您指定自己的自定义错误页面。 您需要做的就是进入layouts文件夹并创建一个名为error.vue的vue组件，并且：当任何时候出现404或500错误时，Nuxt会向客户端显示这个新的错误页面。 部署Nuxt.js应用程序根据您要构建的内容，有三种不同的模式可用于准备我们的生产发布。 服务器端渲染要构建应用程序，您只需运行以下代码即可：1npm run build 这个命令深入我们的代码，分析，生成路由，编译需要编译的文件，然后创建一个名为.nuxt的文件夹，并把所有这些生产需要的文件移动到这里。 现在我们有了一个完全服务器端渲染的Vue.js应用程序。 带有server.js，可以在node下一键启动服务器端和server端 静态站点生成tatic Site Generated要将我们的应用程序生成为静态文件，我们必须运行以下命令： 1npm run generate 此命令编译我们的代码，生成路由并内联生成的每个静态页面中的所有URL，并将它们存储在dist文件夹中。 单页应用程序使用nuxt.js生成单个页面应用程序可以通过两种方式完成。 添加模式’spa’到nuxt.config.js。 在package.json中将–spa标志添加到脚本中，如下所示： 12345678\"scripts\": &#123; \"dev\": \"nuxt --spa\", \"build\": \"nuxt build --spa\", \"start\": \"nuxt start\", \"generate\": \"nuxt generate\", \"lint\": \"eslint --ext .js,.vue --ignore-path .gitignore .\", \"precommit\": \"npm run lint\" &#125;, 资源 原文 https://www.telerik.com/blogs/getting-started-with-nuxtjs nuxt https://zh.nuxtjs.org/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://zj-john.github.io/tags/vue/"},{"name":"2018.10.12","slug":"2018-10-12","permalink":"https://zj-john.github.io/tags/2018-10-12/"},{"name":"nuxt","slug":"nuxt","permalink":"https://zj-john.github.io/tags/nuxt/"}]},{"title":"告别一千次崩溃,一个消除常见React性能问题的清单","date":"2018-10-15T07:49:15.000Z","path":"notes/ckbdbl41j00392ktyr1cpyuwv.html","text":"一个务实的逐步指导，以消除常见的反应性能问题。A pragmatic step-by-step guide to eliminating common react performance issues. 你肯定想过怎么让你的React应用更快，你会列一个常用的用于检查性能的清单，然后逐一去排查吗？ 在本文中，我将逐步向您介绍一个个实用指导，以消除常见的react性能问题。 首先，我将向您展示这些常见的性能问题，然后为他们提供解决方案。您可以讲相同的排查过程应用到您的实际项目。 本文不是冗长的理论，而是一个个可以快速在您的应用程序中马上使用的建议。 让我们开始吧！ 示例项目为了使本文尽可能实用，我将在一个React应用程序中引导您处理各种情况。 我把这个应用叫做 Cardie. 这里是Github repo地址。 Cardie是一个简单的应用程序。它所做的就是显示用户的个人资料信息。 此外，通过单击按钮可以更改用户的职业。 单击应用程序底部的按钮后，用户的职业就会更改。 你可能会嘲笑这是一个没有任何现实意义且简单的应用程序，但看下去你可能会惊讶地发现通过这个示例中获得的追捕性能问题所获得的知识适用于任何真实的应用程序。 所以，保持冷静，继续阅读。 下面是要检查的清单！ 1. 识别浪费的渲染识别react应用程序中的渲染浪费是识别大多数性能问题的完美开端。 有几种不同的方法可以解决这个问题，但最简单的方法是在React开发工具中切换“突出显示更新”选项。 这个选项可以使应用程序交互时，屏幕上会以绿色闪烁突出显示更新。 绿色闪烁的框框显示了应用程序中由React重新呈现的组件。 可以看到，在Cardie中，更改用户职业时，似乎整个父组件App都重新渲染了。 这看起来有点问题。 虽然应用程序运行正常，但是当要更新的只有一小部分时，实际上没有理由重新渲染整个组件。 更理想的效果应如下所示： 在更复杂的应用程序中，浪费的渲染的影响可能是巨大的！因为重新渲染的组件可能大到足以促进性能问题。 针对这个问题，有什么解决方案吗？ 2. 将经常更新的区域提取为单独的组件一旦您在应用程序中直观地注意到渲染的浪费，一个好的解决方式是尝试拆分组件树以隔离经常更新的部分。 在Cardie中，App组件通过react-redux的connect函数连接到redux store。从store中，它接收到这些属性：name, location, likes 和 description。 其中description属性表示用户的当前职业。 基本上，正在发生的事情是，只要通过单击按钮更改用户职业，就会更改description属性。然后，props中的这种更改会导致App组件重新渲染。 对React组件，只要组件的props或state发生更改，就会触发重新渲染。 为了不使组件无意义地重新渲染，我们把要更新的元素改为特定的React组件。 例如，我们可以创建一个新的组件Profession，该组件渲染自己的DOM元素。 此时，Profession组件将呈现用户职业的描述，例如“我是编码员”。 组件树现在看起来像这样： 这里的重点是，我们把&lt;App/&gt;下的profession属性问题，变成了&lt;Profession/&gt;组件的问题。 无论你是否使用redux，这里的要点是App不再由于profession属性的变化而重新渲染，但&lt;Profession/&gt;组件将是。 要查看代码更改，请参阅repo中的isolated-component branch分支。 3. 适当使用纯组件任何关于React性能的文章都很可能会提到纯组件。 但是，什么情况下需要使用纯组件呢？ 理论上，你可以把每个组件都变成纯组件，但是请记住，使用了shouldComponentUpdate函数的组件不在情况之列。 成为纯组件的前提是，当且仅当组件的props与先前的props和state不同时，组件才重新渲染。 构建纯组件的简单方法是使用React.PureComponent，而不是默认的 React.Component 针对 Cardie 的特定情况，让我们将Profession组件的渲染元素分解为更小的组件。 所以，这是Profession之前的内容： 1234567const Description = (&#123; description &#125;) =&gt; &#123; return ( &lt;p&gt; &lt;span className=\"faint\"&gt;I am&lt;/span&gt; a &#123;description&#125; &lt;/p&gt; );&#125; 然后我们将其更改为：12345678910const Description = (&#123; description &#125;) =&gt; &#123; return ( &lt;p&gt; &lt;I /&gt; &lt;Am /&gt; &lt;A /&gt; &lt;Profession profession=&#123;description&#125; /&gt; &lt;/p&gt; );&#125;; 现在，该Description组件涵盖了4个子组件。 请注意，Description组件接收profession属性。然后，它只将此属性传递给Profession组件。所以从技术上讲，其他3个组件都不关心这个profession属性。 这些新组件的内容非常简单。例如，&lt;I /&gt;组件只返回带有“I”文本的span元素：&lt;span &gt;I &lt;/span&gt; 运行一下，结果正常。 有趣的是，在改变description属性时，每个Description的子组件也会被重新渲染。 我在每个子组件的render方法中添加了一些日志- 正如您所看到的，它们确实都被重新渲染。 您还可以使用react开发工具高亮显示更新的部分。 这个结果是可以解释的。当组件props或state 更改时，它呈现的元素树将被重新计算，即重新渲染。 在这个特定的例子中，我们都知道&lt;I/&gt;, &lt;Am/&gt; 和 &lt;A/&gt;子组件被重新渲染是完全没有意义的，虽然，&lt;Description/&gt;中的props确实更改了。试想，如果这是一个足够大的应用程序，则此行为可能会造成一些性能威胁。 如果我们将这些子组件转换为纯组件，情况会不会好一点呢？ 考虑&lt;I/&gt;组件： 123456789101112131415import React, &#123;Component, PureComponent&#125; from \"react\"//beforeclass I extends Component &#123; render() &#123; return &lt;span className=\"faint\"&gt;I &lt;/span&gt; &#125;;&#125;//afterclass I extends PureComponent &#123; render() &#123; return &lt;span className=\"faint\"&gt;I &lt;/span&gt; &#125;;&#125; 通过这种写法，等同于在后台通知React：这样如果这些子组件的prop值没有改变，就不需要重新渲染它们。 是的，即使父元素的属性发生了变化，也不要重新渲染它们！ 在重构后，您可以看到其它子组件不再重新渲染了。只重新渲染了实际更改的prop的Profession组件。 在更大的应用程序中，您可以通过仅使某些组件成为纯组件来发现巨大的性能优化。 要查看代码更改，请参阅repo中的pure-component branch分支。 4. 避免将新对象作为属性传递再次记住，只要props发生变化，组件就会发生重新渲染。 如果您的组件props没有改变但React认为它确实改变了怎么办？ 好吧，这也会导致一次重新渲染！ 但这不是很奇怪吗？ 这种看似奇怪的行为是因为Javascript的工作原理以及React如何处理新老prop值之间的比较而发生的。 让我举个例子。 这是Description组件的内容： 12345678910const Description = (&#123; description &#125;) =&gt; &#123; return ( &lt;p&gt; &lt;I /&gt; &lt;Am /&gt; &lt;A /&gt; &lt;Profession profession=&#123;description&#125; /&gt; &lt;/p&gt; );&#125;; 现在，我们将重构该I组件,使他需要一个确定的i属性。i是如下形式的对象：123const i = &#123; value: \"i\"&#125;; 无论i是什么值，都将传递给I组件并显示。12345class I extends PureComponent &#123; render() &#123; return &lt;span className=\"faint\"&gt;&#123;this.props.i.value&#125; &lt;/span&gt;; &#125;&#125; 在Description组件中，i属性被创建并传入，如下所示：123456789101112131415class Description extends Component &#123; render() &#123; const i = &#123; value: \"i\" &#125;; return ( &lt;p&gt; &lt;I i=&#123;i&#125; /&gt; &lt;Am /&gt; &lt;A /&gt; &lt;Profession profession=&#123;this.props.description&#125; /&gt; &lt;/p&gt; ); &#125;&#125; 我会花点时间解释这个。 这是完全正确的代码，它也工作正常 - 但有一个问题。 即使I是纯组件，但只要用户的职业发生变化，它就会重新渲染！ 这是为什么？ 一旦Description组件接收新的属性，render函数就被调用来创建它的元素树。 在调用render函数时，它会创建一个新的i常量：123const i = &#123; value: \"i\"&#125;; 当React评估&lt;I i={i} /&gt;这行代码时，它会将属性i视为不同的属性，一个新对象 - 因此重新渲染。 React会对上一个和下一个属性进行浅层比较。 即标量值（如字符串和数字）按值进行比较。对象通过引用比较。 也就是说，即使常量i在重新渲染之间具有相同的值，但它们的引用也不相同，因为在内存中的地址变了。 所以，每次渲染时都会新创建对象。因此，prop传递给&lt;I/&gt;的值被视为“新”，因此重新渲染。 在大型应用程序中，这可能会导致渲染浪费和潜在的性能缺陷。 避免这样做。 这适用于每个prop包括事件处理程序。 如果你可以避免它，你不应该这样做：12345...render() &#123; &lt;div onClick=&#123;() =&gt; &#123;//do something here&#125;&#125;&#125;... 因为，您每次在渲染中创建一个新的函数对象。下面这样做更好：1234567...handleClick:() =&#123;&#125;render() &#123; &lt;div onClick=&#123;this.handleClick&#125;&#125;... 了解了吗？ 同样，我们可以重构&lt;I /&gt;中传入属性的方式，如下所示：123456789101112131415class Description extends Component &#123; i = &#123; value: \"i\" &#125;; render() &#123; return ( &lt;p&gt; &lt;I i=&#123;this.i&#125; /&gt; &lt;Am /&gt; &lt;A /&gt; &lt;Profession profession=&#123;this.props.description&#125; /&gt; &lt;/p&gt; ); &#125;&#125; 现在，引用总是一样的，都是this.i。 在渲染时也不会创建新对象。 要查看代码更改，请从repo中查看new-objects branch分支。 5. 使用生产版本部署到生产时，始终使用生产构建。这是一个非常简单但很棒的做法。 如果您已经使用create-react-app引导您的应用，运行生产版本请使用以下命令：npm run build。 这将生成用于生产的优化的打包文件。 6. 使用代码拆分打包应用程序时，您可能将整个应用程序打包在一个大块中。 这个问题是随着你的应用程序的增长，打的包也会越来越大。 代码拆分主张不是一次将大块代码直接发送给用户，而是在需要时动态地向用户发送。 一个常见的例子是基于路由的代码拆分。在此方法中，代码根据应用程序中的路由拆分为块。 另一种方法是基于组件的代码分割。在此方法中，如果当前组件未显示，则可能会把其代码延迟发送给用户。 无论您坚持哪种方法，都必须了解权衡因素并且不会降低应用程序的用户体验。 代码拆分很棒，它可以提高应用程序的性能。 我只是笼统的解释了代码分割。如果您需要更多技术支持，请查看官方的React文档。他们在解释技术概念方面做得不错。 结论现在，您已经有了一个像样的清单来跟踪和修复react应用中的常见性能问题。去构建一些更加快速的应用程序吧！ 资源 原文 https://logrocket-blog.ghost.io/death-by-a-thousand-cuts-a-checklist-for-eliminating-common-react-performance-issues/ Github https://github.com/ohansemmanuel/Cardie-performace","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"web development","slug":"web-development","permalink":"https://zj-john.github.io/tags/web-development/"},{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"2018.10.12","slug":"2018-10-12","permalink":"https://zj-john.github.io/tags/2018-10-12/"}]},{"title":"如何利用Angular 6和Material Design构建新闻应用程序","date":"2018-10-12T04:04:15.000Z","path":"note/ckbdbl429004q2kty06glk1dd.html","text":"在本文中，我们将使用Angular 6和Google的Material Design构建一个新闻应用程序，这将帮助您在Web浏览器和移动设备中使用Angular达到很赞的效果。 您是否希望将Google的 Material Design与Angular相结合？ 在本教程中，我们将使用两个最强大和最受欢迎的资源Angular 6和Material Design来构建一个新闻应用程序。您将学习如何将Google的Material Design组件应用到Angular应用程序模板中，以便以专业的方式更改和设置应用程序样式。本教程还帮助您如何使用News API发出HTTP请求以获取实时新闻文章数据。 在我们开始构建应用程序之前，让我们快速回顾一下我们将要使用的资源，Angular和Material Design。 Angular是什么?Angular - 根据官方文档 - 描述如下： “Angular可以帮您在Web平台上轻松构建应用程序。Angular结合了声明性模板，依赖注入，端到端工具以及一些集成好的最佳实践来解决开发挑战。Angular使开发人员能够构建Web，移动设备或桌面上的应用程序。” 简而言之，它是用于构建高度交互式和动态Web应用程序的最强大的JavaScript框架之一。 “如前所述，Angular不仅功能强大，而且很受欢迎，目前使用它的公司有Upwork，Freelancer，Udemy，YouTube，Paypal，Nike，Google，Telegram，Weather，iStockphoto，AWS，Crunchbase等。” Google’s Material Design是什么?Material Design是Google于2014年夏季为Android的新操作系统引入的一种设计语言。虽然它最初的重点是基于触摸的移动应用程序，但现在它的功能已经扩展到网络设计世界。 它是一个适应性强系统，可以作为指南，组件和工具，支持用户界面设计的最佳实践。它还得到了开源代码的支持，并得到了大量设计师和开发人员的支持，他们正在合作共同构建漂亮的产品。 为什么选择Angular和谷歌的Material Design？这是一个选择问题。没有JavaScript框架是完美的。这完全取决于您的项目需求。编程语言也是如此。 现在，我不打算概述Angular的优点和功能。而是，我将与您分享为什么我选择Angular专门用于构建新闻应用程序。 与任何新闻应用程序一样，通过HTTP协议与后端服务进行通信是至关重要的部分。最新的Angular中的 HttpClient 模块，它是旧Http的改进版本，可以帮助我们轻松地与服务API交互。 当将存储在对象中的远程数据绑定到我们的应用程序模板中时，Angular 的 model-view-viewmodel（MVVM）将非常方便，其中组件扮演控制器/视图模型的一部分，模板代表视图。这就是我们所说的Angular模板语言。 双向绑定系统，这意味着应用程序状态的任何更改都将自动反映到视图中，反之亦然。您会注意到，从侧边菜单中选择新闻来源时，这将改变我们新闻文章列表的状态。 我最喜欢的是Angular的 SPA技术。仅加载需要更改的部分页面有助于我们的应用程序加载并更快速，更顺畅地执行。 当然，Angular还有许多其他优点和功能，您可以在线搜索。 UI方面怎么样？我们选择了Material Design，因为它的语言非常适合Angular，并且易于实现。 它也是一种非常流行的视觉语言; 它响应迅速，大多数Google应用程序都是用它构建的。我们希望我们的应用尽可能像Google应用。 我们的介绍到此为止。现在是时候查看项目概述，然后跳转到构建过程。 项目概况 先决条件 创建Angular项目 安装依赖项 获取免费的API密钥 处理组件 定义Material的默认样式 定义模板 结论 项目概况 “从各种来源获取最新的直播新闻文章，包括BBC新闻，CNN，TechCrunch，赫芬顿邮报等，类别不限于技术，体育，商业，科学和娱乐等。” 这是您的应用程序完成后的外观： 不错吧，让我们从构建应用程序开始。 先决条件这是您实践本教程所需的内容： 已安装Node.js和npm; 已安装Angular CLI; Angular 基本知识. 一旦这些东西不碍事，我们就可以继续了。 创建Angular项目在本节中，我们将使用Angular命令行界面（CLI）生成一个新的Angular项目。为此，请转到CLI并运行以下命令：1ng new news-app 接下来，通过运行以下命令将命令行指向项目的根文件夹：1cd news-app 安装依赖项要设置我们的依赖项，我们只需要使用一个命令即可。别担心，我会在下面快速解释一下： 1npm install --save @angular/material @angular/animations @angular/cdk 我们使用此命令安装了三个软件包。 @angular/material这是专为Angular框架使用的官方Material Design包。 @angular/animations某些material组件需要访问动画库，这就是我们在此处安装它的原因。(通过cli生成的项目，自带了@angular/animations包，如果package.json中已有此包，上面install的时候可以去掉这一项) @angular/cdk因为现代Web技术的发展都是基于组件的，所以有了 CDK 这样的“组件开发工具包”，这为我们提供了为您的组件高品质的预定义的行为， 当您想要将Google的material design与Angular应用结合时，建议安装下Angular CDK。 要了解有关Angular CDK的更多信息，请查看此文章。 让我们运行我们的应用程序，看看一切正常。您可以通过运行以下命令来启动开发服务器：1ng serve 现在，如果您在浏览器中访问http://localhost:4200/，您应该看到以下页面： ] 现在，在代码编辑器中，导航到该文件/src/app/app.module.ts，然后添加我们刚刚安装的以下包：123… Other imports …import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';import &#123; MatButtonModule, MatCardModule, MatMenuModule, MatToolbarModule, MatIconModule, MatSidenavModule, MatListModule &#125; from '@angular/material'; 重要的是要了解这里发生了什么。首先，我们将导入动画包来为我们的应用程序增加动画效果。 下一个重要的是Angular material的独特之处。之前，我们只需要包含一个material整体模块。但现在，我们必须导入我们打算使用的每个material组件。 如您所见，我们在这里添加了七个不同的模块，按钮，卡片，菜单，工具栏，列表，侧面导航和图标。 将这些包添加到您的app.module.ts文件后，请确保您的文件与以下内容匹配：123456789101112131415161718192021222324252627282930import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; HttpClientModule &#125; from '@angular/common/http';import &#123; NewsApiService &#125; from './news-api.service';import &#123; BrowserAnimationsModule &#125; from '@angular/platform-browser/animations';import &#123; MatButtonModule, MatCardModule, MatMenuModule, MatToolbarModule, MatIconModule, MatSidenavModule, MatListModule &#125; from '@angular/material';import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, BrowserAnimationsModule, HttpClientModule, MatButtonModule, MatMenuModule, MatCardModule, MatToolbarModule, MatIconModule, MatSidenavModule, MatListModule, ], providers: [NewsApiService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 注意：上述文件中的 import { HttpClientModule } from @angular/common/http 不是自动生成的，而是手动添加的。所以，请确保你也这样做。并且不要担心 NewsApiService 服务提供商，因为我们稍后会处理这个问题。 您可能想知道，我怎么知道要导入的模块的名称？官方Angular material文档为您提供导入每个模块所需的确切代码。 如果单击左侧菜单中的任何组件，然后单击“API”选项卡，它将为您提供需要使用的确切导入行。 ] 到目前为止，在真正开始在模板中使用和集成material components之前，我们需要做的就是这些。 您只需导入每一个您计划使用的 唯一 组件。 获取免费的API密钥我们将使用News API的JSON数据为我们提供一些新闻标题，我们将在应用程序模板中实现这些数据。 什么是News API服务？ News API是一个简单的HTTP REST API，用于搜索和检索来自整个Web的实时文章。 既然您知道新闻API是什么，下一步就是获得一个免费的API密钥，它将帮助我们向服务器发出一些请求并获取新闻文章。 您只需注册30秒即可。您只需提供您的名字，电子邮件地址和密码即可。就这样。 注册后，您将在dashboard中找到已为您生成的API密钥。只需将其保存在桌面上的某个文本文件中即可; 因为我们将在下一章中使用它。 处理组件在开始处理组件之前，您需要创建服务提供程序来管理与News API服务的交互。 创建服务提供商输入此命令以生成新的服务提供者：1ng generate service NewsApi 之后，转到生成的/src/app/news-api.service.ts文件，并将以下代码添加到其中：12345678910111213141516171819202122import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient &#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root'&#125;)export class NewsApiService &#123; api_key = 'PUT_YOUR_API_KEY_HERE'; constructor(private http:HttpClient) &#123; &#125; initSources()&#123; return this.http.get('https://newsapi.org/v2/sources?language=en&amp;apiKey='+this.api_key); &#125; initArticles()&#123; return this.http.get('https://newsapi.org/v2/top-headlines?sources=techcrunch&amp;apiKey='+this.api_key); &#125; getArticlesByID(source: String)&#123; return this.http.get('https://newsapi.org/v2/top-headlines?sources='+source+'&amp;apiKey='+this.api_key); &#125;&#125; 是时候使用我们的 API密钥 了。只需将其粘贴到“Put_YOUR_API_KEY_HERE”字样即可。 我们已导入HttpClient，它将负责对我们的端点进行API调用并为我们提取新闻标题。 现在，对于该initSources功能，我们只需使用一些新闻来源准备我们的左侧菜单。之后，我们创建了另一个函数，initArticles，它在应用程序启动后从 TechCrunch 中检索第一篇文章。 至于最后一个函数，getArticlesByID,它会根据参数获取一些文章。 The Main Component服务提供商已完成。让我们转到该/src/app/app.component.ts文件并添加以下代码：1234567891011121314151617181920212223242526272829303132import &#123; Component &#125; from '@angular/core';import &#123; NewsApiService &#125; from './news-api.service';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; mArticles:Array&lt;any&gt;; mSources:Array&lt;any&gt;; constructor(private newsapi:NewsApiService)&#123; console.log('app component constructor called'); &#125; ngOnInit() &#123; //load articles this.newsapi.initArticles().subscribe(data =&gt; this.mArticles = data['articles']); //load news sources this.newsapi.initSources().subscribe(data=&gt; this.mSources = data['sources']); &#125; searchArticles(source)&#123; console.log(\"selected source is: \"+source); this.newsapi.getArticlesByID(source).subscribe(data =&gt; this.mArticles = data['articles']); &#125;&#125; 我们在这里定义的两个属性：mArticles，保存新闻文章，和 mSources，保存新闻来源。两者都定义为数组。 在构造函数中，我们只是创建一个NewsAPIService实例。 接下来，我们在 ngOnInit() 函数上使用该实例来初始化我们的两个属性。 对于 searchArticles 函数，只要用户从左侧菜单中选择特定新闻来源，就会触发它。然后我们将此参数传递给 getArticlesByID 服务以检索它的文章。 定义Material的默认样式在我们由Angular CLI生成的/src/styles.css文件中，让我们添加以下内容：12345@import '~@angular/material/prebuilt-themes/indigo-pink.css';body &#123; padding: 2em 23em; background:lightgray;&#125; 根据您的偏好，您可以更改indigo-pink.css为： deeppurple-amber.css indigo-pink.css pink-bluegrey.css purple-green.css 我还在body标签中添加了一些CSS ，只是为了演示这种布局。这有助于它看起来更像一个App，即使在桌面上。 我们还在 /src/index.html 结束head标记之前向我们的文件中添加两行：12&lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\" rel=\"stylesheet\"&gt;&lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic\"&gt; 第一行导入material design图标字体，第二行是Roboto字体，material design团队使用该字体。 定义模板让我们首先在/src/app/app.component.html文件中添加以下模板：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;mat-toolbar color=\"primary\"&gt; &lt;button mat-button (click)=\"sidenav.open ()\" &gt;&lt;mat-icon&gt;menu&lt;/mat-icon&gt;&lt;/button&gt; &lt;span&gt;News Headlines&lt;/span&gt; &lt;span class=\"example-spacer\"&gt;&lt;/span&gt; &lt;button mat-button [matMenuTriggerFor]=\"appMenu\"&gt;&lt;mat-icon&gt;settings&lt;/mat-icon&gt;&lt;/button&gt;&lt;/mat-toolbar&gt;&lt;mat-menu #appMenu=\"matMenu\"&gt; &lt;button mat-menu-item&gt; Settings &lt;/button&gt; &lt;button mat-menu-item&gt; Help &lt;/button&gt;&lt;/mat-menu&gt;&lt;mat-sidenav-container class=\"example-container\"&gt; &lt;mat-sidenav #sidenav class=\"example-sidenav\"&gt; &lt;mat-list class=\"list-nav\"&gt; &lt;mat-list-item class=\"list-item\" *ngFor=\"let source of mSources\" (click)=\"searchArticles(source.id);sidenav.close();\"&gt; &lt;div mat-card-avatar [ngStyle]=\"&#123;'background-image': 'url(../assets/images/'+ source.id +'.png)'&#125;\" class=\"example-header-image\"&gt;&lt;/div&gt; &lt;span class=\"source-name\"&gt; &#123;&#123;source.name&#125;&#125;&lt;/span&gt; &lt;/mat-list-item&gt; &lt;/mat-list&gt; &lt;/mat-sidenav&gt; &lt;mat-card class=\"example-card\" *ngFor=\"let article of mArticles\"&gt; &lt;mat-card-header&gt; &lt;div mat-card-avatar [ngStyle]=\"&#123;'background-image': 'url(../assets/images/'+ article.source.id +'.png)'&#125;\" class=\"example-header-image\"&gt;&lt;/div&gt; &lt;mat-card-title class=\"title\"&gt;&#123;&#123;article.title&#125;&#125;&lt;/mat-card-title&gt; &lt;mat-card-subtitle&gt;&#123;&#123;article.source.name&#125;&#125;&lt;/mat-card-subtitle&gt; &lt;/mat-card-header&gt; &lt;img mat-card-image class=\"img-article\" src=&#123;&#123;article.urlToImage&#125;&#125; alt=\"\"&gt; &lt;mat-card-content&gt; &lt;p&gt; &#123;&#123;article.description&#125;&#125; &lt;/p&gt; &lt;/mat-card-content&gt; &lt;mat-card-actions class=\"action-buttons\"&gt; &lt;button mat-button color=\"primary\"&gt;&lt;mat-icon&gt;thumb_up_alt&lt;/mat-icon&gt; 12 Likes&lt;/button&gt; &lt;button mat-button color=\"primary\"&gt;&lt;mat-icon&gt;comment&lt;/mat-icon&gt; Comments&lt;/button&gt; &lt;button mat-button color=\"primary\"&gt;&lt;mat-icon&gt;share&lt;/mat-icon&gt; Share&lt;/button&gt; &lt;a mat-button color=\"primary\" href=&#123;&#123;article.url&#125;&#125; target=\"_blank\" &gt;&lt;mat-icon&gt;visibility&lt;/mat-icon&gt; More&lt;/a&gt; &lt;/mat-card-actions&gt; &lt;/mat-card&gt;&lt;/mat-sidenav-container&gt; 那么，我们在这做了什么？ 首先，我们定义一个带有左侧菜单的工具栏，以及应用程序的主标题和设置的右侧菜单。 接下来，我们把*ngFor用在来源和文章上，使我们的左侧菜单中保存新闻来源，主要内容将保存新闻文章。 需要注意的是，在click列表项的事件中，我们添加了两个函数，第一个功能是searchArticles我们已经解释过的，第二个功能是sidenav.close()在用户选择来源后自动关闭我们的左侧菜单。 设计我们的组件最后一件事就是访问该/src/app.component.css文件并将以下代码粘贴到其中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.example-spacer &#123; flex: 1 1 auto;&#125;.example-card&#123; margin-top: 4px;&#125;.example-header-image &#123; background-size: cover;&#125;.title&#123; font-weight: bold;&#125;.img-article&#123; height: 350px;&#125;.action-buttons&#123; text-align: center;&#125;.example-container &#123; width: 100%; height: auto; border: 1px solid rgba(111, 111, 111, 0.50);&#125;.example-sidenav-content &#123; display: flex; height: 75%; align-items: center; justify-content: center;&#125;.example-sidenav &#123; padding: 20px;&#125;.source-name &#123; margin-left:5px;&#125;.list-item:hover&#123; cursor: pointer; background-color: #3f51b5; color: white;&#125; 设置新闻资源的图像移动到/src/assets目录，并创建一个名为的新文件夹images。然后，从Google云端硬盘链接或GitHub存储库下载这些图像。 它们是我们新闻来源的logo。下载后，将所有图像文件复制并粘贴到 images刚刚创建的文件夹中。 一切都完成后，运行：1ng serve 现在，您的应用应该如下面的截图。太棒了，呵呵！ ] 一切都完成后启动应用程序 (预览) 请注意，当新闻片段加载到主页面上时，“更多”按钮（如上图所示）会让用户阅读全部故事。 结论我希望这个教程很有用，你很享受能够构建这个应用程序。与此同时，Angular Material文档非常酷。它为您提供了每个组件的概述，API和示例。 这个应用程序的完整源代码可以在GitHub上找到。您还可以查看此网站，该网站已实现本教程中使用的服务API。 资源 原文：https://www.smashingmagazine.com/2018/10/news-application-with-angular-and-material-design/ Angular Material：https://material.angular.io/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.05","slug":"2018-10-05","permalink":"https://zj-john.github.io/tags/2018-10-05/"},{"name":"angular6","slug":"angular6","permalink":"https://zj-john.github.io/tags/angular6/"},{"name":"material","slug":"material","permalink":"https://zj-john.github.io/tags/material/"},{"name":"application","slug":"application","permalink":"https://zj-john.github.io/tags/application/"}]},{"title":"自定义元素简介","date":"2018-10-11T07:48:15.000Z","path":"notes/ckbdbl40y00272ktywbnfrdig.html","text":"介绍自定义元素是Web组件功能下的一个子集，在我看来是最酷的web功能之一。相较之前使用React，Angular，Vue等中间库或框架构建组件，它允许我们构建原生Web的组件。 在本文中，我希望向您展示自定义元素是什么，如何构建它以及如何将它放在页面上。 Web组件的基础所有自定义元素都包含一些常用方法，下面是一个简单例子：12345678910111213141516171819class MyComponent extends HTMLElement &#123; static get observedAttributes() &#123; return []; &#125; constructor(...args) &#123; super(...args); &#125; connectedCallback() &#123;&#125; disconnectedCallback() &#123;&#125; adoptedCallback() &#123;&#125; attributeChangedCallback(attrName, oldVal, newVal) &#123;&#125;&#125;window.customElements.define('my-component', MyComponent); 让我们逐步分析一下。 constructor 理论上，构造函数必须声明，并将接收到的所有参数传递给父级。 一般情况下，构造函数中通常会绑定元素上所有事件的侦听，例如：12345678...constructor(...args) &#123; super(...args); this.addEventListener('click', this.handleClick);&#125;handleClick(event) &#123;&#125;... connectedCallback 每次将元素插入DOM时调用。 每次将组件添加到页面中时，它都会触发此函数。 disconnectedCallback 每次从DOM中删除元素时调用。 例如，如果我们在DOM树中删除自定义组件的节点或其父节点，则此函数将触发。 当自定义元素移动到文档或在新页面的其他地方时（目前没有此类情况，见adoptedCallback中的说明），disconnectedCallback()也会运行。 adoptedCallback 每次将自定义元素移动到新文档时调用。 如果将自定义元素移动到新页面或文档，则将触发此回调。当前没有API可以直接触发此函数，因为已有的Dom的操作都是先删后增，不存在直接移动的情况） attributeChangedCallback(attrName, oldVal, newVal) 添加，删除，更新或替换元素的属性时会触发此函数。 但是，只有当组件上处于 观察状态 的属性发生变化时,才会触发此函数。这就引入了下一个函数observedAttributes()。 observedAttributes() 自定义元素中我们确实要观察的属性 正如你所看到的，这个方法被声明为static get observedAttributes()，这明显不同于其他方法声明，这是因为我们希望它不被任何子类/组件继承，我们只想在引用它的时候声明一次。 此函数应返回一个字符串数组，其中每个字符串都是您要观察的属性的名称，例如：12345...static get observedAttributes() &#123; return ['id', 'my-custom-attribute', 'data-something', 'disabled'];&#125;... 自定义元素规范中还有一些其他功能，但上面这些功能是我们日常主要使用的功能。 一个简单的组件Demo让我们构建一个向用户打招呼的基本组件。 The html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Custom Elements 101&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;hello-component data-name=\"James\"&gt;&lt;/hello-component&gt; &lt;script src=\"./hello-component.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; The javascript1234567891011121314151617181920212223242526class HelloComponent extends HTMLElement &#123; static get observedAttributes() &#123; return ['data-name']; &#125; // custom methods render() &#123; this.innerHTML = `Hello $&#123;this.name&#125;`; &#125; get name() &#123; return this.getAttribute('data-name'); &#125; // lifecycle hooks connectedCallback() &#123; this.render(); &#125; attributeChangedCallback(attrName, oldVal, newVal) &#123; this.render(); &#125;&#125;// add into the 'real' dom as a valid tagwindow.customElements.define('hello-component', HelloComponent); 加载index.html，您应该会在页面上看到“Hello James”。 现在，打开浏览器的DevTools，并将data-name属性更改为除James之外的其他属性。你会发现实时更新！很棒吧？ 当然，这只是一个非常基本的，非最佳实践的教程实现。我们也只是提供了一个粗略的介绍，以便可以在以后的文章中使用。 浏览器支持下图是当前主流浏览器对Web组件以及所有支持它们的API，包括Shadow DOM，自定义元素（我们本文中学到的内容），HTML Templates和Slots以及HTML导入的支持情况： 结论自定义元素允许我们在需要时以无框架的方式实现实时更新的UI组件 。虽然现在功能还不够完善，但是请先试着用用。特别是结合其它Web Component API，可以事倍功半的让我们建立更酷，更强大的实时更新的UI组件。 资源 原文：https://dev.to/jamesrweb/an-introduction-to-custom-elements-5327 Web组件 - MDN 自定义元素 - MDN Shadow DOM - MDN HTML Templates and Slots - MDN","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"customelements","slug":"customelements","permalink":"https://zj-john.github.io/tags/customelements/"},{"name":"html","slug":"html","permalink":"https://zj-john.github.io/tags/html/"},{"name":"2018.10.05","slug":"2018-10-05","permalink":"https://zj-john.github.io/tags/2018-10-05/"}]},{"title":"再见JS，Webassembly你好","date":"2018-10-10T03:16:35.000Z","path":"notes/ckbdbl41y00432ktyklxvg92y.html","text":"一种新的Web开发形式开始出现，它有望提供JavaScript的替代方案：这就是WebAssembly。 Web开发一直是JavaScript开发的代名词。从诞生直到现在。现在，一种新的Web开发形式开始出现，它有望提供JavaScript的替代方案。作为一名拥有15年Web开发经验的软件开发人员，这一新方向引起了我的兴趣。 WebAssembly（Wasm）是Web浏览器的二进制指令格式，旨在为C＃等高级语言提供编译。最近，微软开始尝试使用WebAssembly，使用Mono引擎把.NET引入浏览器。Mono提供了在WebAssembly上运行的.NET库（.dll）的管道。运行在Mono之上的是Blazor，一个基于.NET的单页Web应用程序框架，通过Mono的WebAssembly引擎运行在在浏览器中。WebAssembly-Mono-Blazor技术栈使得具有完全.NET技术栈开发能力的Web开发人员能够在不使用JavaScript或浏览器插件的情况下开发完整web应用的潜力。 引入这个新概念会立即带来问题，这是理所当然的。 WebAssembly提供了哪些内容是JavaScript或TypeScript没有的呢？ What Does WebAssembly Provide That JavaScript or TypeScript Doesn’t?我的答案伴随着大量的偏见和意见，我觉得应该并非所有的开发人员，项目和工具都是一样的。对我来说答案很明确，简短的回答是“选择”。开放超越JavaScript的Web开发意味着选择和自由选择不仅是JavaScript或.NET，而是更广泛的选择。更确切地说，就我个人而言，我可以选择使用我已在其他地方使用的工具和语言来开发Web应用程序。 npm和WebPack特别的，对.NET开发敞开WEB开发大门的好处之一，是我们把npm和WebPack变为了可选答案。作为很长一段时间的.NET开发人员，对于使用NuGet（包管理器）和MSBuild我很开心。对我来说，这些技术问题更少，更熟悉，而且效率更高。虽然没有什么是完美的，但我与NuGet和MSBuild的关系大多是积极的。One of the benefits of opening up the web to .NET in particular is that we now have alternatives to npm and WebPack. As a long time .NET developer, I’m greeting NuGet (package manager) and MSBuild with excitement. For me, these technologies are less problematic, more familiar, and far more productive. While nothing is ever perfect, my relationship with NuGet and MSBuild has been mostly positive. 起初，这可能会给人的印象是npm和Webpack有点不好，而且我主张放弃这些工具，但事实恰恰相反。npm和WebPack是很棒的工具，它们可能会存在很长一段时间。如果您的JavaScript工具适合您和您创建的应用程序，那么这是一件很棒的事情。拥有悠久的网络经验，我了解为什么npm和WebPack存在并欣赏他们拥有和将要完成的事情。At first this may come with the impression that npm and Webpack are somehow bad, and that I’m advocating to abandon those tools, but the opposite holds true. npm and WebPack are great tools and they will likely be around for quite some time. If your JavaScript tools work well for you and the apps you create then this is a wonderful thing. Having a long history of experience with the web, I have an understanding of why npm and WebPack exist and appreciation for what they have and will accomplish. 减少学习曲线Blazor让我感到震惊的一件事是它的使用感觉非常简单。为了不偏不倚，我承认它不是完整的功能，还没有大规模测试。Blazor将Razor（UI）的易用性与其他.NET Core概念结合在一起，例如：依赖注入，配置和路由。它借用了流行的JavaScript框架（如Angular和React）中的最佳模式，同时利用了Razor模板，并提供了与其他.NET约定的奇偶校验。这些功能组合允许以前所未有的方式重用技能。对于使用一种语言和熟悉完整JavaScript技术栈的Node开发人员来说，情况也是如此。One thing that shocked me about Blazor is how genuinely simple it feels to use. In an attempt to be unbiased, I’ll admit that it’s not feature complete and it’s yet to be tested at scale. Blazor combines the ease of Razor (UI) with other .NET Core concepts like: dependency injection, configuration, and routing. It has borrowed the best patterns from popular JavaScript frameworks like Angular and React while leveraging Razor templates, and provided parity with other .NET conventions. This combination of features allows for the reuse of skills in a way that was unavailable before. The same could be said for Node developers who use one language and familiar concepts in full stack JavaScript apps. 你仍需要JavaScript使用WebAssembly并不意味着可以避免使用JavaScript。WebAssembly当前必须由JavaScript加载和编译。（是的，我可以听到记录划痕。）虽然将来计划允许像ES6模块一样加载WebAssembly模块，但JavaScript可以引导WebAssembly。JavaScript的必要性也不止于此。WebAssembly无权访问任何平台API。为了访问平台API，需要JavaScript。Using WebAssembly doesn’t mean that JavaScript can be avoided. WebAssembly must currently be loaded and compiled by JavaScript. (Yes, I can hear the record-scratch.) While there are future plans to allow WebAssembly modules to be loaded just like ES6 modules, JavaScript is there to bootstrap WebAssembly. The necessity for JavaScript doesn’t stop there either. WebAssembly doesn’t have access to any platform APIs. In order to access platform APIs JavaScript is required. Blazor InteropWebAssembly应用程序可以调用JavaScript，为纯WebAssembly无法访问的API提供迁移路径。此功能也用于Blazor框架。由于Blazor是新的和实验性的，Blazor interop 允许开发人员在WebAssembly本身存在缺陷时，或者因为Blazor框架尚未成熟时依赖JavaScript。此外，interop是许多开发人员将在C＃中使用的抽象层，他们不必担心底层技术仍在执行JavaScript代码。随着WebAssembly的成熟，随着时间的推移，对抽象的需求将会减少。WebAssembly applications can make calls to JavaScript, providing a migration path for APIs that are beyond the reach of pure WebAssembly. This feature is used in the Blazor framework as well. Because Blazor is new and experimental, the Blazor interop allows developers to fall back on JavaScript when there are shortcomings of WebAssembly itself, or because the Blazor framework is not yet mature. In addition, the interop is an abstraction layer that many developers will work with in C#, and they will not need to worry that underlying technology is still executing JavaScript code. Over time the need for abstractions will decrease as WebAssembly matures. 再见不是永远的 Goodbye Isn’t ForeverProgress对使用Angular，React，Vue和jQuery的JavaScript进行了大量投资。Progress旗下最令人兴奋的开源框架之一是NativeScript。NativeScript是一个使用JavaScript为iOS和Android创建原生移动应用程序的框架。NativeScript让我想起了WebAssembly，它为开发人员创建选择的方式。借助NativeScript，JavaScript开发人员可以重用其现有技能进入移动开发领域，从而使其在员工队伍中更具价值。NativeScript的目标是赋予开发人员权力，而不是降低Swift，Objective-C或Java的价值。Progress has huge investments in JavaScript with Angular, React, Vue, and jQuery. One of the most exciting open source frameworks under the Progress umbrella is NativeScript. NativeScript is a framework for creating native mobile applications for iOS and Android using JavaScript. NativeScript reminds me of WebAssembly in the way that it creates choices for developers. With NativeScript JavaScript developers can reuse their existing skills to enter the mobile development space, thus making them more valuable in the workforce. NativeScript’s goal is to empower developers, not diminish the value of Swift, Objective-C, or Java. 我觉得WebAssembly也有类似的目标。实际上，该目标在WebAssembly官方文档中说明。I feel that WebAssembly shares a similar goal. In fact, that goal is stated on the official WebAssembly documentation. WebAssembly是否试图取代JavaScript？没有！WebAssembly旨在作为JavaScript的补充而非替代。随着时间的推移，WebAssembly将允许将许多语言编译到Web上，而JavaScript具有令人难以置信的动力，并且仍将是Web的单一特权（如上所述）动态语言。此外，预计JavaScript和WebAssembly将在许多配置中一起使用……No! WebAssembly is designed to be a complement to, not replacement of, JavaScript. While WebAssembly will, over time, allow many languages to be compiled to the Web, JavaScript has an incredible amount of momentum and will remain the single, privileged (as described above) dynamic language of the Web. Furthermore, it is expected that JavaScript and WebAssembly will be used together in a number of configurations… 向前进 Moving Forward如果你对使用JavaScript替代方案开发Web有兴趣，那么WebAssembly和像基于ASP.NET内核的Blazor这样的框架值得投入一些 时间。这些仍然是WebAssembly和基于WebAssembly的技术的早期阶段，但是扩大生态系统的承诺引起了我的注意。作为Web开发的忠实粉丝，我希望看到它向前发展并扩展应用程序如何为平台编写的想法。利用多年的.NET经验来构建应用程序以提高我的工作效率的前景令人兴奋。此外，我已经为JavaScript技能打下了坚实的基础，我每天都在不断成长。通过这种多样性，技能可以作为工程师解决问题的视角和独特方式。 If developing for the web using JavaScript alternatives interests you then WebAssembly and frameworks like ASP.NET Core’s Blazor are worth investing some time in. These are still early days for WebAssembly and WebAssembly based technologies, but the promise of a widening ecosystem has gotten my attention. As a huge fan of web development I want to see it move forward and expand ideas of how apps are written for the platform. The prospect of leaning on years of .NET experience to build apps in a way that makes me more productive is exciting to say the least. In addition, I have built a solid foundation of JavaScript skills as well, that I continue to grow each day. With this variety skills comes perspective and unique ways to solve problems as an engineer. WebAssembly会让您感兴趣吗？你打算测试Blazor吗？或者您是像Ruby或Python这样的背景的开发人员，想要在管道中使用WebAssembly？在下面的评论中分享您的想法。Is WebAssembly something that interests you? Do you plan on testing out Blazor? Or are you a developer from a background like Ruby or Python that would like to use WebAssembly in your pipeline? Share you thoughts in the comments below. 链接 原文：https://www.telerik.com/blogs/goodbye-javascript-hello-webassembly","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"javascript","slug":"javascript","permalink":"https://zj-john.github.io/tags/javascript/"},{"name":"2018.10.05","slug":"2018-10-05","permalink":"https://zj-john.github.io/tags/2018-10-05/"},{"name":"webassembly","slug":"webassembly","permalink":"https://zj-john.github.io/tags/webassembly/"}]},{"title":"Create React App 2.0发布- Babel 7, Sass, and More","date":"2018-10-09T06:12:45.000Z","path":"notes/ckbdbl415002l2ktyuv6zrzuv.html","text":"Create React App 2.0已于2018.10.01发布，在本次版本升级中极大地更新完善了产品功能和体验。 Create React App 2.0 has been released today, and it brings a year’s worth of improvements in a single dependency update. 虽然使用React本身不需要任何构建相关的依赖性，但编写一个含有快速测试模块，生产用压缩工具和模块化代码库的复杂应用程序仍然具有挑战性。从第一个版本开始，Create React App的目标就是帮助您专注于最重要的事项 - 您的应用程序代码 - 并为您处理构建和测试的相关设置。 While React itself doesn’t require any build dependencies, it can be challenging to write a complex app without a fast test runner, a production minifier, and a modular codebase. Since the very first release, the goal of Create React App has been to help you focus on what matters the most — your application code — and to handle build and testing setup for you. 它依赖的许多工具到现在为止已经发布了包含新功能和性能改进的新版本：Babel 7)，webpack 4和Jest 23。但是，手动更新它们并使它们一起协同工作需要花费很多精力。这正是Create React App 2.0贡献者在过去几个月一直忙于的事情：迁移配置和依赖项，这样您就不需要自己动手了。 Many of the tools it relies on have since released new versions containing new features and performance improvements: Babel 7, webpack 4, and Jest 23. However, updating them manually and making them work well together takes a lot of effort. And this is exactly what Create React App 2.0 contributors have been busy with for the past few months: migrating the configuration and dependencies so that you don’t need to do it yourself. 现在Create React App 2.0已经脱离了测试版，让我们看看有什么新东西以及如何尝试它！Now that Create React App 2.0 is out of beta, let’s see what’s new and how you can try it! 注意 不要为升级感到有压力。如果您对当前在用的版本的性能和可靠性感到满意，则可以继续使用当前版本！在生产中切换到2.0之前，让2.0版本稳定一点可能也是一个好主意。 Don’t feel pressured to upgrade anything. If you’re satisfied with the current feature set, its performance, and reliability, you can keep using the version you’re currently at! It might also be a good idea to let the 2.0 release stabilize a little bit before switching to it in production. 新功能以下是此版本中新功能的简短摘要： 🎉更多样式选项：您可以直接使用Sass和CSS模块。 🐠我们更新到Babel 7，包括对React fragment syntax 和许多bugfixes的支持。 📦我们更新到webpack 4，它可以更智能地自动拆分JS包。 🃏我们更新到Jest 23，其中包括用于查看快照的交互模式)。 💄我们添加了PostCSS，因此您可以在旧浏览器中使用新的CSS功能。 💎您可以使用Apollo，Relay Modern，MDX和其他第三方Babel Macros变换。 🌠现在可以将SVG作为React组件导入)，并在JSX中使用它。 🐈您可以尝试实验性的Yarn Plug’n’Play mode，将删除的node_modules。 🕸现在，您可以在开发中插入自己的代理实现)，以匹配您的后端API。 🚀您现在可以使用最新Node版本编写的包而不会破坏构建。 ✂️如果您只打算适配现代浏览器，现在可以选择获得较小的CSS包。 👷♀️Service workers现在可以选择性加入，它使用Google的Workbox构建。 🎉 More styling options: you can use Sass and CSS Modules out of the box. 🐠 We updated to Babel 7, including support for the React fragment syntax and many bugfixes. 📦 We updated to webpack 4, which automatically splits JS bundles more intelligently. 🃏 We updated to Jest 23, which includes an interactive mode for reviewing snapshots. 💄 We added PostCSS so you can use new CSS features in old browsers. 💎 You can use Apollo, Relay Modern, MDX, and other third-party Babel Macros transforms. 🌠 You can now import an SVG as a React component, and use it in JSX. 🐈 You can try the experimental Yarn Plug’n’Play mode that removes node_modules. 🕸 You can now plug your own proxy implementation in development to match your backend API. 🚀 You can now use packages written for latest Node versions without breaking the build. ✂️ You can now optionally get a smaller CSS bundle if you only plan to target modern browsers. 👷‍♀️ Service workers are now opt-in and are built using Google’s Workbox. 所有这些功能都是开箱即用的 - 要启用它们，请按照以下说明操作。 All of these features work out of the box — to enable them, follow the below instructions. 使用Create React App 2.0开启项目您无需更新任何特殊内容。从今天开始，当您运行create-react-app时，它默认情况下将使用2.0版本的模板。用的开心！ You don’t need to update anything special. Starting from today, when you run create-react-app it will use the 2.0 version of the template by default. Have fun! 如果由于某种原因想要使用旧的1.x模板，可以通过将--scripts-version=react-scripts@1.x作为参数来实现create-react-app。 If you want to use the old 1.x template for some reason, you can do that by passing --scripts-version=react-scripts@1.x as an argument to create-react-app. 更新项目以创建React App 2.0将non-ejected项目升级到Create React App 2.0通常应该很简单。打开项目的根目录中的package.json，找到 react-scripts， Upgrading a non-ejected project to Create React App 2.0 should usually be straightforward. Open package.json in the root of your project and find react-scripts there. 然后将其版本更改为2.0.3：Then change its version to 2.0.3:12// ... other dependencies ...\"react-scripts\": \"2.0.3\" 运行npm install（或者yarn，如果您使用它）。对于许多项目，这种一行代码的更改足以升级！ Run npm install (or yarn, if you use it). For many projects, this one-line change is sufficient to upgrade! 这里有一些技巧可以帮助您入门。 Here’s a few more tips to get you started. 当您在升级后第一次运行npm start时，您会收到一个提示，询问您希望支持哪些浏览器。按y接受默认值。它们会写入您的package.json，您可以随时编辑它们。Create React App将使用此信息生成较小或polyfilled的CSS包，具体取决于您是以现代浏览器还是旧浏览器为目标。 When you run npm start for the first time after the upgrade, you’ll get a prompt asking about which browsers you’d like to support. Press y to accept the default ones. They’ll be written to your package.json and you can edit them any time. Create React App will use this information to produce smaller or polyfilled CSS bundles depending on whether you target modern browsers or older browsers. 如果升级后npm start仍然无法正常工作， 请查看发行说明中更详细的迁移说明。此版本中是有几个重大的变动，但他们的范围是有限的，所以不应该花费超过几个小时进行梳理。请注意，现在可以选择支持旧版浏览器 是可选的，通过它可以减少polyfill大小。 If npm start still doesn’t quite work for you after the upgrade, check out the more detailed migration instructions in the release notes. There are a few breaking changes in this release but the scope of them is limited, so they shouldn’t take more than a few hours to sort out. Note that support for older browsers is now opt-in to reduce the polyfill size. 如果您之前ejected但现在想要升级，一个常见的解决方案是找到您ejected的提交（以及任何后续提交更改配置），还原它们，升级，然后再选择再次eject。您现在支持开箱即用的功能（可能是Sass或CSS模块？）也是可能的。 If you previously ejected but now want to upgrade, one common solution is to find the commits where you ejected (and any subsequent commits changing the configuration), revert them, upgrade, and later optionally eject again. It’s also possible that the feature you ejected for (maybe Sass or CSS Modules?) is now supported out of the box. Note 由于npm中可能存在的bug，您可能会看到有关未满足的对等依赖项的警告。你应该可以忽略它们。据我们所知，Yarn没有这个问题。 Due to a possible bug in npm, you might see warnings about unsatisfied peer dependencies. You should be able to ignore them. As far as we’re aware, this issue isn’t present with Yarn. 突破性变化以下是此版本中重大更改的简短列表：Here’s a short list of breaking changes in this release: 不再支持Node 6。 对旧版浏览器（例如IE 9到IE 11）的支持现在通过使用单独的软件包来选择。 现在通过import()来进行代码分割的行为更接近于规范，同时require.ensure()被禁用。 默认的Jest环境现在包含jsdom。 支持将指定对象设置为proxy设置已替换为对自定义代理模块的支持。 对.mjs扩展的支持被删除，直到它的生态系统稳定下来。 PropTypes定义会自动从生产版本中删除。 Node 6 is no longer supported. Support for older browsers (such as IE 9 to IE 11) is now opt-in with a separate package. Code-splitting with import() now behaves closer to specification, while require.ensure() is disabled. The default Jest environment now includes jsdom. Support for specifying an object as proxy setting was replaced with support for a custom proxy module. Support for .mjs extension was removed until the ecosystem around it stabilizes. PropTypes definitions are automatically stripped out of the production builds. 如果这些点中的任何一个对您有影响，则2.0.3发行说明包含更详细的说明。If either of these points affects you, 2.0.3 release notes contain more detailed instructions. 更多您可以在发行说明中找到完整的更改日志。这是一个很大的更新，我们可能错过了一些东西。请向我们的提issue报告任何问题，我们会尽力提供帮助。 You can find the full changelog in the release notes. This was a large release, and we may have missed something. Please report any problems to our issue tracker and we’ll try to help. Note 如果您一直在使用2.x alpha版本，我们会为它们提供单独的迁移说明 If you’ve been using 2.x alpha versions, we provide separate migration instructions for them. 链接 https://reactjs.org/blog/2018/10/01/create-react-app-v2.html","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.10.05","slug":"2018-10-05","permalink":"https://zj-john.github.io/tags/2018-10-05/"},{"name":"create react app","slug":"create-react-app","permalink":"https://zj-john.github.io/tags/create-react-app/"},{"name":"react-scripts","slug":"react-scripts","permalink":"https://zj-john.github.io/tags/react-scripts/"}]},{"title":"JavaScript原型入门指南","date":"2018-10-08T06:13:35.000Z","path":"notes/ckbdbl414002i2kty42jkveuu.html","text":"如果不能很好的处理对象，你将无法在JavaScript中获得很大的成就。它们几乎是JavaScript编程语言各个方面的基础。在这篇文章中，您将了解用于实例化新对象的各种模式，在学习中，您将逐渐深入了解JavaScript的原型。 基础如果不能很好的处理对象，你将无法在JavaScript中获得很大的成就。它们几乎是JavaScript编程语言各个方面的基础。事实上，学习如何创建对象可能是你刚开始学习的第一件事。话虽如此，为了最有效地学习JavaScript中的原型，我们将从基础开始。 首先，对象是键/值对。创建对象的最常用方法是使用花括号{}，并使用点表示法向对象添加属性和方法。 123456789101112131415161718let animal = &#123;&#125;animal.name = 'Leo'animal.energy = 10animal.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;animal.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;animal.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125; 这很简单。现在，我们需要创建多个动物。所以将上面的逻辑封装在函数中，以便我们随时调用。我们将此模式称为函数实例化 ，将函数本身称为“构造函数”，因为它负责“构造”一个​​新对象。 函数实例化12345678910111213141516171819202122232425function Animal (name, energy) &#123; let animal = &#123;&#125; animal.name = name animal.energy = energy animal.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; animal.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; animal.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125; return animal&#125;const leo = Animal('Leo', 7)const snoop = Animal('Snoop', 10) 现在，每当我们想要创建一个新动物（或者更广泛地说是一个新的“实例”）时，我们所要做的就是调用我们的Animal函数，然后把 name和energy参数传递进去。这非常有效，而且非常简单。但是，你能发现这种模式的缺点吗？最大也是我们会尝试解决的一个和三种方法 eat，sleep和play有关。这些方法中的每一种都不仅是动态的，而且它们也是完全通用的。这意味着没有理由重新创建这些方法，正如我们在创建新动物时所做的那样。我们只是在浪费内存，让每个动物物体都比它需要的更大。你能想到一个解决方案吗？如果不是每次创建新动物时重新创建这些方法，我们将它们移动到自己的对象然后我们可以让每个动物引用该对象，该怎么办？我们可以将这种模式称为 使用共享方法的函数实例化。 使用共享方法的函数实例化12345678910111213141516171819202122232425262728const animalMethods = &#123; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125;, sleep(length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125;, play(length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;function Animal (name, energy) &#123; let animal = &#123;&#125; animal.name = name animal.energy = energy animal.eat = animalMethods.eat animal.sleep = animalMethods.sleep animal.play = animalMethods.play return animal&#125;const leo = Animal('Leo', 7)const snoop = Animal('Snoop', 10) 通过将共享方法移动到它们自己的对象并在我们的Animal 函数内部引用该对象，我们现在已经解决了内存浪费和过大的动物对象的问题。 Object.create让我们使用Object.create再次改进我们的例子。简而言之，Object.create允许您创建一个对象，该对象将在失败的查找中委托给另一个对象。换句话说，Object.create允许您创建一个对象，只要该对象上的属性查找失败，它就可以查询另一个对象以查看该另一个对象是否具有该属性。我们来看一些代码。 12345678910111213const parent = &#123; name: 'Stacey', age: 35, heritage: 'Irish'&#125;const child = Object.create(parent)child.name = 'Ryan'child.age = 7console.log(child.name) // Ryanconsole.log(child.age) // 7console.log(child.heritage) // Irish 因此，在上面的示例中，因为child是通过Object.create(parent)创建的，只要在child上有失败的属性查找，JavaScript就会将该查找委托给该parent对象。这意味着即使child没有heritage属性，当你查找child.heritage时你会得到它parent的heritage属性Irish。 现在，通过使用Object.create，我们如何来简化我们之前的Animal代码呢？好吧，我们可以使用Object.create来继承animalMethods对象，而不是像现在一样逐一向动物添加所有共享方法。这听起来很智能，让我们称之为使用共享方法和Object.create进行函数实例化 使用共享方法和Object.create进行函数实例化12345678910111213141516171819202122232425262728const animalMethods = &#123; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125;, sleep(length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125;, play(length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;function Animal (name, energy) &#123; let animal = Object.create(animalMethods) animal.name = name animal.energy = energy return animal&#125;const leo = Animal('Leo', 7)const snoop = Animal('Snoop', 10)leo.eat(10)snoop.play(5) 所以现在当我们调用时leo.eat，JavaScript将eat在leo对象上查找方法。那个查找将失败，因为Object.create，它将委托给animalMethods对象，然后它将找到eat。 到现在为止还挺好。尽管如此，我们仍然可以做出一些改进。为了跨实例共享方法，必须管理一个单独的对象（animalMethods）似乎有点“骇客” 。但这似乎是您希望在语言本身中实现的常见功能。其实它一直都在，这也是你在这里的原因 - 原型。 那究竟什么是JavaScript中的原型呢？好吧，简单地说，JavaScript中的每个函数都有一个prototype引用对象的属性。亲自测试一下。 12function doThing () &#123;&#125;console.log(doThing.prototype) // &#123;&#125; 如果不是创建一个单独的对象来管理我们的方法（就像我们正在做的那样animalMethods），我们只是将每个方法放在Animal函数的原型上呢？然后，我们所要做的就是不使用Object.create代理animalMethods，我们可以使用它来委托Animal.prototype。我们称之为这种模式原型实例化。 原型实例化12345678910111213141516171819202122232425262728function Animal (name, energy) &#123; let animal = Object.create(Animal.prototype) animal.name = name animal.energy = energy return animal&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = Animal('Leo', 7)const snoop = Animal('Snoop', 10)leo.eat(10)snoop.play(5) 希望你有一个很大的“啊哈”时刻。同样，prototype它只是JavaScript中每个函数都具有的属性，并且如上所述，它允许我们在函数的所有实例之间共享方法。我们所有的功能仍然是相同的，但现在我们不必为所有方法管理一个单独的对象，我们可以使用内置于Animal函数本身的另一个对象，Animal.prototype。 让我们更深入到目前为止，我们知道三件事： 如何创建构造函数。 如何将方法添加到构造函数的原型中。 如何使用Object.create将失败的查找委托给函数的原型。这三个任务似乎是任何编程语言的基础。JavaScript是否真的那么糟糕，没有更简单，“内置”的方式来完成同样的事情？正如你可能在这一点上猜测的那样，它是通过使用new关键字来实现的。 我们采取的缓慢，有条理的方法有什么好处，你现在可以深入了解new关键字在JavaScript中的底层做了什么。 回顾一下我们的Animal 构造函数，最重要的两个部分是创建对象和返回它。如果不创建对象Object.create，我们将无法在失败的查找上委托函数的原型。如果没有该return语句，我们将永远不会收回创建的对象。 1234567function Animal (name, energy) &#123; let animal = Object.create(Animal.prototype) animal.name = name animal.energy = energy return animal&#125; 这是很酷的事情new - 当你使用new关键字调用一个函数时，这两行是隐式地完成的，并且调用创建的对象this。 使用注释来显示在幕后发生的事情并假设Animal使用new关键字调用构造函数，可以将其重写为此。 1234567891011function Animal (name, energy) &#123; // const this = Object.create(Animal.prototype) this.name = name this.energy = energy // return this&#125;const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10) 没有注释的情况12345678910111213141516171819202122function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10) 这个满足要求以及this为指向我们的创建对象的原因是因为我们使用new关键字调用了构造函数。如果在调用函数时不使用new，则this这个对象永远不会创建，也不会隐式返回。我们可以在下面的示例中看到这个问题。1234567function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;const leo = Animal('Leo', 7)console.log(leo) // undefined 这种模式的名称是伪初始化。 如果JavaScript不是您的第一种编程语言，您可能会有点不安。 “WTF，这个家伙只是重新创造了一个更糟糕的版本” - 你 对于那些不熟悉的人，使用Class（类）允许您为对象创建模板。然后，无论何时创建该类的实例，都会获得一个具有模板中定义的属性和方法的对象。 听起来有点熟？这基本上就是我们对上面Animal的构造函数所做的。我们只是使用常规的旧JavaScript函数重新创建相同的功能，而不是使用关键字class。当然，它需要一些额外的工作以及一些关于JavaScript“后台”发生的事情的知识，但结果是一样的。 这里有个好消息。JavaScript不是一种死语言。它不断得到改进，并由TC-39委员会补充。这意味着即使JavaScript的初始版本不支持类，也不影响后续将它们添加到官方规范中。事实上，这正是TC-39委员会所做的。2015年，发布了EcmaScript（官方JavaScript规范）6，支持Classes和class关键字。让我们看看Animal上面的构造函数如何使用新的类语法。 123456789101112131415161718192021class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep(length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play(length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10) 很干净吧？ 因此，如果这是创建类的新方法，为什么我们花了这么多时间来翻过旧的方式呢？之所以这样，是因为新的方式（使用class关键字）主要只是我们称之为伪古典模式的现有方式的“语法糖”。为了完全理解ES6类的便捷语法，首先必须理解伪古典模式。 在这一点上，我们已经介绍了JavaScript原型的基础知识。本文的其余部分将致力于理解与其相关的其他“幸好知道了这件事”主题。在另一篇文章中，我们将看看如何利用这些基础知识并使用它们来理解继承在JavaScript中的工作原理。 数组方法我们在上面深入讨论了如果要在类的实例之间共享方法，您应该将这些方法放在类（或函数）原型上。如果我们了解Array类型，我们可以看到同样的模式。从历史上看，您可能已经创建了这样的数组1const friends = [] 事实证明，这是通过new创造一个Array类实例的语法糖。 123const friendsWithSugar = []const friendsWithoutSugar = new Array() 你可能从来没有想过一件事是怎样一个array的每个实例都具有所有这些内置的方法（splice，slice，pop等）？ 正如您现在所知，这是因为这些方法存在Array.prototype，当您创建新实例时Array，您使用new关键字将Array.prototype失败的查找设置为委托。 我们可以通过查看Array.prototype简单的查看所有数组的方法。 1234567891011121314151617181920212223242526272829303132333435console.log(Array.prototype)/* concat: ƒn concat() constructor: ƒn Array() copyWithin: ƒn copyWithin() entries: ƒn entries() every: ƒn every() fill: ƒn fill() filter: ƒn filter() find: ƒn find() findIndex: ƒn findIndex() forEach: ƒn forEach() includes: ƒn includes() indexOf: ƒn indexOf() join: ƒn join() keys: ƒn keys() lastIndexOf: ƒn lastIndexOf() length: 0n map: ƒn map() pop: ƒn pop() push: ƒn push() reduce: ƒn reduce() reduceRight: ƒn reduceRight() reverse: ƒn reverse() shift: ƒn shift() slice: ƒn slice() some: ƒn some() sort: ƒn sort() splice: ƒn splice() toLocaleString: ƒn toLocaleString() toString: ƒn toString() unshift: ƒn unshift() values: ƒn values()*/ 对象也存在完全相同的逻辑。所有的对象将失败的查找委托给Object.prototype，这就是为什么所有对象都有类似toString和hasOwnProperty的方法。 静态方法到目前为止，我们已经介绍了为什么以及如何在类的实例之间共享方法。但是，如果我们有一个对Class很重要但不需要跨实例共享的方法呢？例如，如果我们有一个函数接受一个Animal实例数组并确定下一个要被吃的的需求该怎么办？我们称之为nextToEat。 1234567function nextToEat (animals) &#123; const sortedByLeastEnergy = animals.sort((a,b) =&gt; &#123; return a.energy - b.energy &#125;) return sortedByLeastEnergy[0].name&#125; 这是没有意义有nextToEat依托于Animal.prototype，因为我们不希望所有实例之间共享。相反，我们可以将其视为辅助方法。所以，如果nextToEat不应该依托于Animal.prototype，我们应该把它放在哪里？那么显而易见的答案是我们可以把nextToEat与我们Animal类放到相同的范围，然后在我们正常需要时引用它。 12345678910111213141516171819202122232425262728293031class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep(length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play(length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125;&#125;function nextToEat (animals) &#123; const sortedByLeastEnergy = animals.sort((a,b) =&gt; &#123; return a.energy - b.energy &#125;) return sortedByLeastEnergy[0].name&#125;const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10)console.log(nextToEat([leo, snoop])) // Leo 现在这可行，但有更好的方法。 要有一个特定于类本身的方法，但不需要在该类的实例之间共享，就可以将其添加为static类的属性。 12345678910111213141516171819202122232425class Animal &#123; constructor(name, energy) &#123; this.name = name this.energy = energy &#125; eat(amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount &#125; sleep(length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length &#125; play(length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length &#125; static nextToEat(animals) &#123; const sortedByLeastEnergy = animals.sort((a,b) =&gt; &#123; return a.energy - b.energy &#125;) return sortedByLeastEnergy[0].name &#125;&#125; 现在，因为我们在类上添加nextToEat了一个static属性，它就存在于Animal类本身（而不是它的原型）上，可以使用它来访问Animal.nextToEat。 1234const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10)console.log(Animal.nextToEat([leo, snoop])) // Leo 因为我们在这篇文章中都遵循了类似的模式，让我们来看看如何使用ES5完成同样的事情。在上面的例子中，我们看到了如何使用static关键字将方法直接放在类本身上。使用ES5，同样的模式就像手动将方法添加到函数对象一样简单。 1234567891011121314151617181920212223242526272829303132function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;Animal.nextToEat = function (nextToEat) &#123; const sortedByLeastEnergy = animals.sort((a,b) =&gt; &#123; return a.energy - b.energy &#125;) return sortedByLeastEnergy[0].name&#125;const leo = new Animal('Leo', 7)const snoop = new Animal('Snoop', 10)console.log(Animal.nextToEat([leo, snoop])) // Leo 获取对象的原型无论您使用哪种模式创建对象，都可以使用该Object.getPrototypeOf方法完成获取该对象的原型。123456789101112131415161718192021222324252627function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal('Leo', 7)const prototype = Object.getPrototypeOf(leo)console.log(prototype)// &#123;constructor: ƒ, eat: ƒ, sleep: ƒ, play: ƒ&#125;prototype === Animal.prototype // true 上面的代码有两个重要的要点。 首先，你会发现，proto是以个含有4种方法的对象，constructor，eat，sleep，和play。这就说得通了。我们使用getPrototypeOf方法进入到实例，leo返回实例的原型，这是我们所有方法都存在的地方。这告诉我们还有一件事prototype我们还没有谈过。默认情况下，该prototype对象将具有一个constructor属性，该属性指向原始函数或创建实例的类。这也意味着因为JavaScript默认情况下会在属性上放置一个constructor属性，所以任何实例都可以通过instance.constructor它访问它们的构造函数。 从上面得到的第二个重要内容是Object.getPrototypeOf(leo) === Animal.prototype。这也是有道理的。该Animal构造函数有一个原型属性，在那里我们可以分享的所有实例的方法和getPrototypeOf让我们看到了实例本身的原型。 1234567function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;const leo = new Animal('Leo', 7)console.log(leo.constructor) // Logs the constructor function 为了配合我们之前讨论的内容Object.create，其工作原因是因为任何实例Animal都将委托给Animal.prototype失败的查找。因此，当您尝试访问时leo.prototype，leo没有prototype属性，因此它会将该查找委托给Animal.prototype确实具有constructor属性的查找。如果这一段不太了解，请回过头来阅读Object.create上述内容。 您可能已经看过proto之前用于获取实例的原型。这是过去的遗物。相反，如上所述使用Object.getPrototypeOf(instance)。 确定属性是否存在于原型上在某些情况下，您需要知道属性是否存在于实例本身上，还是存在于对象委托的原型上。我们可以通过循环遍历leo我们一直在创建的对象来看到这一点。假设目标是循环leo并记录其所有键和值。使用for in循环，可能看起来像这样。 12345678910111213141516171819202122232425function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal('Leo', 7)for(let key in leo) &#123; console.log(`Key: $&#123;key&#125;. Value: $&#123;leo[key]&#125;`)&#125; 你期望看到什么？最有可能的是，它是这样的12Key: name. Value: LeoKey: energy. Value: 7 但是，如果你运行代码，你看到的是这个 - 1234567891011121314Key: name. Value: LeoKey: energy. Value: 7Key: eat. Value: function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Key: sleep. Value: function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Key: play. Value: function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125; …这是为什么？一个for in循环将循环遍历对象本身以及它所委托的原型的所有可枚举属性。因为默认情况下将添加到函数的原型任何属性可枚举，我们不仅看到了name和energy，但我们也看到所有的原型方法- eat，sleep和play。要解决这个问题，我们需要指定所有原型方法都是不可枚举的，或者如果属性位于leo对象本身上，我们需要一种只有console.log的方法，而不是leo在失败的查找中委托给的原型。这是hasOwnProperty可以帮助我们的地方。 hasOwnProperty是每个对象上的属性，它返回一个布尔值，指示对象是否具有指定的属性作为其自己的属性，而不是对象委托给的原型。这正是我们所需要的。现在有了这些新知识，我们可以修改我们的代码以利用循环hasOwnProperty内部的优势for in。 123456789...const leo = new Animal('Leo', 7)for(let key in leo) &#123; if (leo.hasOwnProperty(key)) &#123; console.log(`Key: $&#123;key&#125;. Value: $&#123;leo[key]&#125;`) &#125;&#125; 现在我们看到的只是leo对象本身的属性，而不是原型leo委托。12Key: name. Value: LeoKey: energy. Value: 7 如果你仍然有点困惑hasOwnProperty，这里有一些代码可以清除它。123456789101112131415161718192021222324252627function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;Animal.prototype.eat = function (amount) &#123; console.log(`$&#123;this.name&#125; is eating.`) this.energy += amount&#125;Animal.prototype.sleep = function (length) &#123; console.log(`$&#123;this.name&#125; is sleeping.`) this.energy += length&#125;Animal.prototype.play = function (length) &#123; console.log(`$&#123;this.name&#125; is playing.`) this.energy -= length&#125;const leo = new Animal('Leo', 7)leo.hasOwnProperty('name') // trueleo.hasOwnProperty('energy') // trueleo.hasOwnProperty('eat') // falseleo.hasOwnProperty('sleep') // falseleo.hasOwnProperty('play') // false 检查对象是否是类的实例有时您想知道对象是否是特定类的实例。为此，您可以使用instanceof运算符。用例非常简单，但如果您以前从未见过它，实际的语法有点奇怪。它的工作原理如下 1object instanceof Class 如果object是Class的实例，则上述语句将返回true，否则返回false。回到我们的Animal例子，我们有类似的东西。 1234567891011function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;function User () &#123;&#125;const leo = new Animal('Leo', 7)leo instanceof Animal // trueleo instanceof User // false 它的instanceof工作方式是检查constructor.prototype对象原型链中是否存在。在上面的例子中，leo instanceof Animal是true因为Object.getPrototypeOf(leo) === Animal.prototype。另外，leo instanceof User是false因为Object.getPrototypeOf(leo) !== User.prototype。 创建新的不可知构造函数你能发现下面代码中的错误吗？123456function Animal (name, energy) &#123; this.name = name this.energy = energy&#125;const leo = Animal('Leo', 7) 即使是经验丰富的JavaScript开发人员有时也会因为上面的例子而被绊倒。因为我们正在使用我们之前学到的pseudoclassical pattern，所以当Animal调用构造函数时，我们需要确保使用new关键字调用它。如果我们不这样做，那么this关键字将不会被创建，也不会被隐式返回。 作为复习，注释掉的行是new在函数上使用关键字时幕后发生的事情。 12345678function Animal (name, energy) &#123; // const this = Object.create(Animal.prototype) this.name = name this.energy = energy // return this&#125; 这似乎是一个非常重要的细节，让其他开发人员记住。假设我们正在与其他开发人员合作，我们是否有办法确保Animal始终使用new关键字调用构造函数？事实证明，这是通过使用我们之前学到的instanceof操作来实现的。 如果使用new关键字调用构造函数，那么构造函数体内部的this将是instanceof构造函数本身。这里可以聊很多。这是一些代码。 12345678function Animal (name, energy) &#123; if (this instanceof Animal === false) &#123; console.warn('Forgot to call Animal with the new keyword') &#125; this.name = name this.energy = energy&#125; 现在不是仅仅向函数的使用者记录警告，如果我们重新调用该函数，但是这次使用new关键字怎么办？12345678function Animal (name, energy) &#123; if (this instanceof Animal === false) &#123; return new Animal(name, energy) &#125; this.name = name this.energy = energy&#125; 现在无论是否Animal使用new关键字调用它，它仍然可以正常工作。 重新创建Object.create在这篇文章中，我们非常依赖于Object.create创建委托给构造函数原型的对象。此时，您应该知道如何Object.create在代码中使用，但有一件事您可能没有想到的是Object.create实际上是如何工作的。为了让你真正了解它是如何Object.create工作的，我们将自己重新创建它。首先，我们对如何Object.create运作了解多少？ 它接受一个类型为对象的参数。 它创建一个对象，该对象在失败的查找中委托给参数对象。 它返回新创建的对象。. 让我们从＃1开始吧。123Object.create = function (objToDelegateTo) &#123;&#125; 很简单。 现在＃2 - 我们需要创建一个对象，该对象将在失败的查找中委托给参数对象。这个有点棘手。为此，我们将使用我们对new关键字和原型如何在JavaScript中工作的知识。首先，在我们Object.create实现的主体内部，我们将创建一个空函数。然后，我们将该空函数的原型设置为等于参数对象。然后，为了创建一个新对象，我们将使用new关键字调用我们的空函数。如果我们返回新创建的对象，那么它也将完成＃3。 12345Object.create = function (objToDelegateTo) &#123; function Fn()&#123;&#125; Fn.prototype = objToDelegateTo return new Fn()&#125; 让我们来看看吧。 当我们创建一个新函数时，Fn在上面的代码中，它带有一个prototype属性。当我们用new关键字调用它时，我们知道我们将得到的是一个对象，它将在失败的查找中委托给函数的原型。如果我们覆盖函数的原型，那么我们可以决定在失败的查找中委托哪个对象。因此，在我们上面的示例中，我们Fn使用Object.create调用时传入的对象覆盖原型objToDelegateTo。 请注意，我们只支持Object.create的单个参数。官方实现还支持第二个可选参数，该参数允许您向创建的对象添加更多属性。 箭头 Functions箭头函数没有自己的this关键字。因此，箭头函数不能是构造函数，如果您尝试使用new关键字调用箭头函数，它将抛出错误。 123const Animal = () =&gt; &#123;&#125;const leo = new Animal() // Error: Animal is not a constructor 另外，因为我们在上面说明了pseudoclassical pattern不能与箭头函数一起使用，所以箭头函数也没有prototype属性。 12const Animal = () =&gt; &#123;&#125;console.log(Animal.prototype) // undefined 链接 https://tylermcginnis.com/beginners-guide-to-javascript-prototype/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zj-john.github.io/tags/JavaScript/"},{"name":"2018.10.05","slug":"2018-10-05","permalink":"https://zj-john.github.io/tags/2018-10-05/"},{"name":"prototype","slug":"prototype","permalink":"https://zj-john.github.io/tags/prototype/"}]},{"title":"你不（可能不）需要Moment.js","date":"2018-09-17T12:36:38.000Z","path":"notes/ckbdbl40t001x2ktyuanm5bck.html","text":"Moment.js 是一个很棒的时间和日期库，具有许多强大的功能和实用程序。但是，如果您正在处理性能敏感的Web应用程序，则由于其复杂的API和较大的捆绑包大小，可能会导致巨大的性能开销。 Moment.js的问题： 它高度基于OOP API，这使得它无法使用树抖动，从而导致巨大的捆绑包大小和性能问题。 它是可变的，因为OOP API和非纯函数会导致错误:https://github.com/moment/moment/blob/develop/src/test/moment/add_subtract.js#L244-L286 如果您没有使用时区，而只使用了moment.js中的一些简单函数，这可能会使您的应用程序膨胀，因此被视为过度杀伤。dayjs有一个较小的核心，并且具有非常相似的API，因此它非常容易迁移。 date-fns 可以实现 tree-shaking and other benefits 因此它可以与React，Sinon.js和webpack等一起使用。请参阅 https://github.com/moment/moment/issues/2373 以获取有关原因和方式的更多信息。人们从moment.js切换到其他解决方案。 简要比较 名称 尺寸（gzip的） Tree-shaking Popularity Methods richness Pattern Timezone Support Locale Moment.js 329K(69.6K) No 38k High OO Good(moment-timezone) 123 date-fns 78.4k(13.4k) without tree-shaking Yes 13k High Functional Not yet 32 dayjs 6.5k(2.6k) without plugins No 14k Medium OO Not yet 23 开发者之声 Removed moment.js to replace with date-fns - build output reduced by 40% &mdash;Jared Farago from webnode project. Make use of native JavaScript object and array utilities before going big.Good library if you’re looking to replace Moment.js for one reason or another. Immutable too. &mdash;Dan Abramov, Author of Redux and co-author of Create React App. Building tools for humans. I strongly recommend using date-fns over Moment.js, it’s has a nicer API and you can include only parts you need! &mdash;Matija Marohnić, a design-savvy frontend developer from Croatia. Just yesterday changed momentjs to this lib in out project. Cut the size of our js bundle almost in half 😱 &mdash;Sergey Petushkov, a javaScript developer from Moscow, Russia • Currently in Berlin, Germany. ESLint插件如果你正在使用ESLint, 你可以安装一个插件来帮助你识别代码库中你没有（可能不需要）Moment.js的地方。 安装插件…… Install the plugin… 1npm install --save-dev eslint-plugin-you-dont-need-momentjs …然后更新您的配置 1\"extends\" : [\"plugin:you-dont-need-momentjs/recommended\"], Quick LinksParse String + Date Format String + Time Format String + Format + locale Get + Set Millisecond/Second/Minute/Hour Date of Month Day of Week Day of Year Week of Year Days in Month Weeks in Year Maximum of the given dates Minimum of the given dates Manipulate Add Subtract Start of Time End of Time Display Format Time from now Time from X Difference Query Is Before Is Same Is After Is Between Is Leap Year Is a Date ⚠️ Note that the provided examples of date-fns are for v2 which is in pre-release right now. See v1 docs for the current release. ParseString + Date FormatReturn the date parsed from date string using the given format string. 123456789101112// Moment.jsmoment('12-25-1995', 'MM-DD-YYYY');// =&gt; \"1995-12-24T13:00:00.000Z\"// date-fnsimport parse from 'date-fns/parse';parse('12-25-1995', 'MM-dd-yyyy', new Date());// =&gt; \"1995-12-24T13:00:00.000Z\"// dayjsdayjs('12-25-1995');// =&gt; \"1995-12-24T13:00:00.000Z\" String + Time FormatReturn the date parsed from time string using the given format string. 12345678910// Moment.jsmoment('2010-10-20 4:30', 'YYYY-MM-DD HH:mm');// =&gt; \"2010-10-19T17:30:00.000Z\"// date-fnsimport parse from 'date-fns/parse';parse('2010-10-20 4:30', 'yyyy-MM-dd H:mm', new Date());// =&gt; \"2010-10-19T17:30:00.000Z\"// dayjs ❌ does not support custom format parse String + Format + localeReturn the date parsed from string using the given format string and locale. 1234567891011// Moment.jsmoment('2012 mars', 'YYYY MMM', 'fr');// =&gt; \"2012-02-29T13:00:00.000Z\"// date-fnsimport parse from 'date-fns/parse';import fr from 'date-fns/locale/fr';parse('2012 mars', 'yyyy MMMM', new Date(), &#123; locale: fr &#125;);// =&gt; \"2012-02-29T13:00:00.000Z\"// dayjs ❌ does not support custom format parse Get + SetMillisecond / Second / Minute / HourGet the Millisecond/Second/Minute/Hour of the given date. 12345678910111213141516171819202122232425// Moment.jsmoment().seconds();// =&gt; 49moment().hours();// =&gt; 19// Nativenew Date().getSeconds();// =&gt; 49new Date().getHours();// =&gt; 19// date-fnsimport getSeconds from 'date-fns/getSeconds';import getHours from 'date-fns/getHours';getSeconds(new Date());// =&gt; 49getHours(new Date());// =&gt; 19// dayjsdayjs().second();// =&gt; 49dayjs().hour();// =&gt; 19 Set the Millisecond/Second/Minute/Hour of the given date. 12345678910111213141516171819202122232425// Moment.jsmoment().seconds(30);// =&gt; \"2018-09-09T09:12:30.695Z\"moment().hours(13);// =&gt; \"2018-09-09T03:12:49.695Z\"// Nativenew Date(new Date().setSeconds(30));// =&gt; \"2018-09-09T09:12:30.695Z\"new Date(new Date().setHours(13));// =&gt; \"2018-09-09T03:12:49.695Z\"// date-fnsimport setSeconds from 'date-fns/setSeconds';import setHours from 'date-fns/setHours';setSeconds(new Date(), 30);// =&gt; \"2018-09-09T09:12:30.695Z\"setHours(new Date(), 13);// =&gt; \"2018-09-09T03:12:49.695Z\"// dayjsdayjs().set('second', 30);// =&gt; \"2018-09-09T09:12:30.695Z\"dayjs().set('hour', 13);// =&gt; \"2018-09-09T03:12:49.695Z\" Date of MonthGets or sets the day of the month. 12345678910111213141516171819202122232425// Moment.jsmoment().date();// =&gt; 9moment().date(4);// =&gt; \"2018-09-04T09:12:49.695Z\"// Nativenew Date().getDate();// =&gt; 9new Date().setDate(4);// =&gt; \"2018-09-04T09:12:49.695Z\"// date-fnsimport getDate from 'date-fns/getDate';import setDate from 'date-fns/setDate';getDate(new Date());// =&gt; 9setDate(new Date(), 4);// =&gt; \"2018-09-04T09:12:49.695Z\"// dayjsdayjs().date();// =&gt; 9dayjs().set('date', 4);// =&gt; \"2018-09-04T09:12:49.695Z\" Day of WeekGets or sets the day of the week. 12345678910111213141516171819202122232425// Moment.jsmoment().day();// =&gt; 0 (Sunday)moment().day(-14);// =&gt; \"2018-08-26T09:12:49.695Z\"// Nativenew Date().getDay();// =&gt; 0 (Sunday)new Date().setDate(new Date().getDate() - 14);// =&gt; \"2018-08-26T09:12:49.695Z\"// date-fnsimport getDay from 'date-fns/getDay';import setDay from 'date-fns/setDay';getDay(new Date());// =&gt; 0 (Sunday)setDay(new Date(), -14);// =&gt; \"2018-08-26T09:12:49.695Z\"// dayjsdayjs().day();// =&gt; 0 (Sunday)dayjs().set('day', -14);// =&gt; \"2018-08-26T09:12:49.695Z\" Day of YearGets or sets the day of the year. 123456789101112131415// Moment.jsmoment().dayOfYear();// =&gt; 252moment().dayOfYear(256);// =&gt; \"2018-09-13T09:12:49.695Z\"// date-fnsimport getDayOfYear from 'date-fns/getDayOfYear';import setDayOfYear from 'date-fns/setDayOfYear';getDayOfYear(new Date());// =&gt; 252setDayOfYear(new Date(), 256);// =&gt; \"2018-09-13T09:12:49.695Z\"// dayjs ❌ does not support day of year Week of YearGets or sets the week of the year. 1234567891011121314151617181920// Moment.jsmoment().week();// =&gt; 37moment().week(24);// =&gt; \"2018-06-10T09:12:49.695Z\"// date-fnsimport getWeek from 'date-fns/getWeek';import setWeek from 'date-fns/setWeek';getWeek(new Date());// =&gt; 37setWeek(new Date(), 24);// =&gt; \"2018-06-10T09:12:49.695Z\"// dayjs ⚠️ requires weekOfYear pluginimport weekOfYear from 'dayjs/plugin/weekOfYear';dayjs.extend(weekOfYear);dayjs().week();// =&gt; 37// dayjs ❌ does not support set week of year Days in MonthGet the number of days in the current month. 123456789101112// Moment.jsmoment('2012-02', 'YYYY-MM').daysInMonth();// =&gt; 29// date-fnsimport getDaysInMonth from 'date-fns/getDaysInMonth';getDaysInMonth(new Date(2012, 1));// =&gt; 29// dayjsdayjs('2012-02').daysInMonth();// =&gt; 29 Weeks in YearGets the number of weeks in the current year, according to ISO weeks. 12345678910// Moment.jsmoment().isoWeeksInYear();// =&gt; 52// date-fnsimport getISOWeeksInYear from 'date-fns/getISOWeeksInYear';getISOWeeksInYear(new Date());// =&gt; 52// dayjs ❌ does not support weeks in the year Maximum of the given datesReturns the maximum (most distant future) of the given date. 1234567891011121314151617181920const array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9),];// Moment.jsmoment.max(array.map(a =&gt; moment(a)));// =&gt; \"2018-03-11T13:00:00.000Z\"// Nativenew Date(Math.max.apply(null, array)).toISOString();// =&gt; \"2018-03-11T13:00:00.000Z\"// date-fnsimport max from 'date-fns/max';max(array);// =&gt; \"2018-03-11T13:00:00.000Z\"// dayjs ❌ does not support the maximum of the given dates Minimum of the given datesReturns the minimum (most distant future) of the given date. 1234567891011121314151617181920const array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9),];// Moment.jsmoment.min(array.map(a =&gt; moment(a)));// =&gt; \"2016-01-08T13:00:00.000Z\"// Nativenew Date(Math.min.apply(null, array)).toISOString();// =&gt; \"2016-01-08T13:00:00.000Z\"// date-fnsimport min from 'date-fns/min';min(array);// =&gt; \"2016-01-08T13:00:00.000Z\"// dayjs ❌ does not support the minimum of the given dates ManipulateAddAdd the specified number of days to the given date. 123456789101112// Moment.jsmoment().add(7, 'days');// =&gt; \"2018-09-16T09:12:49.695Z\"// date-fnsimport addDays from 'date-fns/addDays';addDays(new Date(), 7);// =&gt; \"2018-09-16T09:12:49.695Z\"// dayjsdayjs().add(7, 'day');// =&gt; \"2018-09-16T09:12:49.695Z\" SubtractSubtract the specified number of days from the given date. 123456789101112// Moment.jsmoment().subtract(7, 'days');// =&gt; \"2018-09-02T09:12:49.695Z\"// date-fnsimport subDays from 'date-fns/subDays';subDays(new Date(), 7);// =&gt; \"2018-09-02T09:12:49.695Z\"// dayjsdayjs().subtract(7, 'day');// =&gt; \"2018-09-02T09:12:49.695Z\" Start of TimeReturn the start of a unit of time for the given date. 123456789101112// Moment.jsmoment().startOf('month');// =&gt; \"2018-08-31T14:00:00.000Z\"// date-fnsimport startOfMonth from 'date-fns/startOfMonth';startOfMonth(new Date());// =&gt; \"2018-08-31T14:00:00.000Z\"// dayjsdayjs().startOf('month');// =&gt; \"2018-08-31T14:00:00.000Z\" End of TimeReturn the end of a unit of time for the given date. 123456789101112// Moment.jsmoment().endOf('day');// =&gt; \"2018-09-09T13:59:59.999Z\"// date-fnsimport endOfDay from 'date-fns/endOfDay';endOfDay(new Date());// =&gt; \"2018-09-09T13:59:59.999Z\"// dayjsdayjs().endOf('day');// =&gt; \"2018-09-09T13:59:59.999Z\" DisplayFormatReturn the formatted date string in the given format. 123456789101112131415161718// Moment.jsmoment().format('dddd, MMMM Do YYYY, h:mm:ss A');// =&gt; \"Sunday, September 9th 2018, 7:12:49 PM\"moment().format('ddd, hA');// =&gt; \"Sun, 7PM\"// date-fnsimport format from 'date-fns/format';format(new Date(), 'eeee, MMMM do YYYY, h:mm:ss aa');// =&gt; \"Sunday, September 9th 2018, 7:12:49 PM\"format(new Date(), 'eee, ha');// =&gt; \"Sun, 7PM\"// dayjsdayjs().format('dddd, MMMM D YYYY, h:mm:ss A');// =&gt; \"Sunday, September 9 2018, 7:12:49 PM\" ⚠️ not support 9thdayjs().format('ddd, hA');// =&gt; \"Sun, 7PM\" Time from nowReturn time from now. 123456789101112131415// Moment.jsmoment(1536484369695).fromNow();// =&gt; \"4 days ago\"// date-fnsimport formatDistance from 'date-fns/formatDistance';formatDistance(new Date(1536484369695), new Date(), &#123; addSuffix: true &#125;);// =&gt; \"4 days ago\"// dayjs ⚠️ requires relativeTime pluginimport relativeTime from 'dayjs/plugin/relativeTime';dayjs.extend(relativeTime);dayjs(1536484369695).fromNow();// =&gt; \"5 days ago\" ⚠️ the rounding method of this plugin is different from moment.js and date-fns, use with care. Time from xReturn time from x. 1234567891011121314// Moment.jsmoment([2007, 0, 27]).to(moment([2007, 0, 29]));// =&gt; \"in 2 days\"// date-fnsimport formatDistance from 'date-fns/formatDistance';formatDistance(new Date(2007, 0, 27), new Date(2007, 0, 29));// =&gt; \"2 days\"// dayjs ⚠️ requires relativeTime pluginimport relativeTime from 'dayjs/plugin/relativeTime';dayjs.extend(relativeTime);dayjs('2007-01-27').to(dayjs('2007-01-29'));// =&gt; \"in 2 days\" DifferenceGet the unit of time between the given dates. 12345678910111213141516171819// Moment.jsmoment([2007, 0, 27]).diff(moment([2007, 0, 29]));// =&gt; -172800000moment([2007, 0, 27]).diff(moment([2007, 0, 29]), 'days');// =&gt; -2// date-fnsimport differenceInMilliseconds from 'date-fns/differenceInMilliseconds';differenceInMilliseconds(new Date(2007, 0, 27), new Date(2007, 0, 29));// =&gt; -172800000import differenceInDays from 'date-fns/differenceInDays';differenceInDays(new Date(2007, 0, 27), new Date(2007, 0, 29));// =&gt; -2// dayjsdayjs('2007-01-27').diff(dayjs('2007-01-29'), 'milliseconds');// =&gt; -172800000dayjs('2007-01-27').diff(dayjs('2007-01-29'), 'days');// =&gt; -2 QueryIs BeforeCheck if a date is before another date. 123456789101112// Moment.jsmoment('2010-10-20').isBefore('2010-10-21');// =&gt; true// date-fnsimport isBefore from 'date-fns/isBefore';isBefore(new Date(2010, 9, 20), new Date(2010, 9, 21));// =&gt; true// dayjsdayjs('2010-10-20').isBefore('2010-10-21');// =&gt; true Is SameCheck if a date is same another date. 123456789101112131415161718192021222324// Moment.jsmoment('2010-10-20').isSame('2010-10-21');// =&gt; falsemoment('2010-10-20').isSame('2010-10-20');// =&gt; truemoment('2010-10-20').isSame('2010-10-21', 'month');// =&gt; true// date-fnsimport isSameDay from 'date-fns/isSameDay';import isSameMonth from 'date-fns/isSameMonth';isSameDay(new Date(2010, 9, 20), new Date(2010, 9, 21));// =&gt; falseisSameDay(new Date(2010, 9, 20), new Date(2010, 9, 20));// =&gt; trueisSameMonth(new Date(2010, 9, 20), new Date(2010, 9, 21));// =&gt; true// dayjsdayjs('2010-10-20').isSame('2010-10-21');// =&gt; falsedayjs('2010-10-20').isSame('2010-10-20');// =&gt; true// dayjs ❌ does not support is same month Is AfterCheck if a date is after another date. 123456789101112// Moment.jsmoment('2010-10-20').isAfter('2010-10-19');// =&gt; true// date-fnsimport isAfter from 'date-fns/isAfter';isAfter(new Date(2010, 9, 20), new Date(2010, 9, 19));// =&gt; true// dayjsdayjs('2010-10-20').isAfter('2010-10-19');// =&gt; true Is BetweenCheck if a date is between two other dates. 1234567891011121314151617// Moment.jsmoment('2010-10-20').isBetween('2010-10-19', '2010-10-25');// =&gt; true// date-fnsimport isWithinInterval from 'date-fns/isWithinInterval';isWithinInterval(new Date(2010, 9, 20), &#123; start: new Date(2010, 9, 19), end: new Date(2010, 9, 25),&#125;);// =&gt; true// dayjs ⚠️ requires isBetween pluginimport isBetween from 'dayjs/plugin/isBetween';dayjs.extend(isBetween);dayjs('2010-10-20').isBetween('2010-10-19', '2010-10-25');// =&gt; true Is Leap YearCheck if a year is a leap year. 1234567891011121314// Moment.jsmoment([2000]).isLeapYear();// =&gt; true// date-fnsimport isLeapYear from 'date-fns/isLeapYear';isLeapYear(new Date(2000, 0, 1));// =&gt; true// dayjs ⚠️ requires isLeapYear pluginimport isLeapYear from 'dayjs/plugin/isLeapYear';dayjs.extend(isLeapYear);dayjs('2000').isLeapYear();// =&gt; true Is a DateCheck if a variable is a native js Date object. 12345678910// Moment.jsmoment.isDate(new Date());// =&gt; true// date-fnsimport isDate from 'date-fns/isDate';isDate(new Date());// =&gt; true// dayjs ❌ does not support is date 资源 原文 https://github.com/you-dont-need/You-Dont-Need-Momentjs","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.09.14","slug":"2018-09-14","permalink":"https://zj-john.github.io/tags/2018-09-14/"}]},{"title":"下一代包管理工具tink","date":"2018-09-17T12:30:02.000Z","path":"notes/ckbdbl426004j2ktyq83yun1x.html","text":"如果想要只用node，就可以让安装依赖快速到可以放到后台运行，而不用把进度显示在界面，该怎么办？如果想要依赖项中的每个文件都能确保和你注册它们时一模一样，该怎么办？如果依赖项中的每个文件都可以保证与注册表中的文件一点一点怎么办？如果在新项目上工作就像克隆和运行一样简单怎么办？如果你的构建工具不合适怎么办？ 本文介绍tink一个无安装安装程序的概念验证实现。 tink作为Node.js本身的替代品，使用现有的package-lock.json。在没有a的项目上试用它node_modules，你会发现require即使你从未运行过安装，你仍然可以使用任何依赖项。第一次运行将在下载并提取包tar包时花费几秒钟，但后续运行几乎是即时的，即使它仍在验证package-lock.json您的系统中的所有内容。 你会注意到的第一件事是这些模块都没有放入你的node_modules文件夹 - 事实上，你唯一能找到的就是一个.package-map.json文件。这包含已安装的每个包中所有文件的哈希值。这些在加载之前就已经过验证，因此您可以放心地获得所要求的内容（如果验证失败，则文件将从其原始源获取，全部透明）。 我们不会把婴儿扔出洗澡水。您仍然可以在node_modules文件夹中安装内容，这些版本将优先于缓存版本使用。这为依赖项的实时编辑（有时是必要的调试技术）打开了一条路径，并支持改变软件包分发的postinstall脚本。 tink是一个改变我们与Node.js项目和npm Registry相关的方式的机会。是否应该使用require或import不在您的模块package.json中将其添加到您的package.json？默认情况下，是否应该提供非常受欢迎的功能，例如与babel兼容的esm，typescript或jsx？这些是我们一直在问自己的问题，我们很想听听您对下一代体验的期望。请来npm.community告诉我们！ 资源 原文 https://blog.npmjs.org/post/178027064160/next-generation-package-management","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.09.14","slug":"2018-09-14","permalink":"https://zj-john.github.io/tags/2018-09-14/"},{"name":"tink","slug":"tink","permalink":"https://zj-john.github.io/tags/tink/"},{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"}]},{"title":"TypeScript 3.1 RC上线","date":"2018-09-17T12:12:01.000Z","path":"notes/ckbdbl40w00242kty4p8egew2.html","text":"2018-09-13日，我们很高兴地宣布TypeScript 3.1的候选版本（RC）可用了。发布RC的目的是为了收集任何意见和建议，以便确保我们正式版本的发布尽可能顺利。 如果您现在想试一试，可以通过NuGet获取RC ，或使用以下命令使用npm： 1npm install -g typescript @ rc 以下编译器也已支持RC版本 下载Visual Studio 2017（适用于15.2或更高版本） 下载Visual Studio 2015（使用Update 3） 遵循Visual Studio Code和Sublime Text的说明。 让我们来看看TypeScript 3.1中会出现什么！ 可映射的元组和数组类型遍历列表中的值是编程中最常见的模式之一。作为示例，我们来看看以下JavaScript代码： 123function stringifyAll(...elements) &#123; return elements.map(x =&gt; String(x));&#125; stringifyAll函数的功能是接受任意数量的参数，将每个元素转换为字符串，并将结果放在一个新数组中，然后返回该数组。如果我们希望支持各种类型转换的stringifyAll，我们可以将其声明为： 1declare function stringifyAll(...elements: unknown[]): Array&lt;string&gt;; 这个声明表示，“这个东西需要任意数量，不知道什么类型的元素，然后返回一个string类型的数组”; 但是，我们elements在这次转型中失去了一些信息。 具体来说，类型系统不记得用户传入的元素数量，因此我们的输出类型也没有已知的长度。我们可以通过重载做类似的事情： 12345declare function stringifyAll(...elements: []): string[];declare function stringifyAll(...elements: [unknown]): [string];declare function stringifyAll(...elements: [unknown, unknown]): [string, string];declare function stringifyAll(...elements: [unknown, unknown, unknown]): [string, string, string];// ... etc 呃。我们甚至没有涵盖四个参数的情况。当然，我们可以使用条件类型而不是重载，但是你会有一堆嵌套的条件类型。 如果只有一种方法可以在这里统一映射每种类型…… 好吧，TypeScript已经有了类似的功能。TypeScript有一个称为映射对象类型的概念，它可以从现有类型中生成新类型。例如，给定以下Person类型， 12345interface Person &#123; name: string; age: number; isHappy: boolean;&#125; 我们可能希望将每个属性转换为如上所示的字符串： 12345678910111213interface StringyPerson &#123; name: string; age: string; isHappy: string;&#125;function stringifyPerson(p: Person) &#123; const result = &#123;&#125; as StringyPerson; for (const prop in p) &#123; result[prop] = String(p[prop]); &#125; return result;&#125; 尽管stringifyPerson已经很普适。但我们可以抽象出在任何给定类型的属性上使用映射对象类型把类型Stringify-ing化的这种概念： 123type Stringify&lt;T&gt; = &#123; [K in keyof T]: string&#125;; 对于新手来说，这可以理解为：为T中的每一个属性K，产生与类型名称的string化的新特性。 并重写我们的函数来使用它： 123456789function stringifyProps&lt;T&gt;(p: T) &#123; const result = &#123;&#125; as Stringify&lt;T&gt;; for (const prop in p) &#123; result[prop] = String(p[prop]); &#125; return result;&#125;stringifyProps(&#123; hello: 100, world: true &#125;); // has type `&#123; hello: string, world: string &#125;` 好像我们有我们想要的东西！但是，如果我们尝试更改类型stringifyAll以返回Stringify： 1declare function stringifyAll&lt;T extends unknown[]&gt;(...elements: T): Stringify&lt;T&gt;; 然后尝试在数组或元组上调用它，我们只能获得在TypeScript 3.1之前几乎有用的东西。让我们来试试像旧版本的TypeScript 3.0： 12345let stringyCoordinates = stringifyAll(100, true);// No errors!let first: string = stringyCoordinates[0];let second: string = stringyCoordinates[1]; 看起来我们的元组索引已正确映射！让我们现在检查抓住长度并确保正确： 123let len: 2 = stringyCoordinates.length// ~~~// Type 'string' is not assignable to type '2'. 呃。string？好吧，让我们尝试迭代我们的坐标。 123stringyCoordinates.forEach(x =&gt; console.log(x));// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// Cannot invoke an expression whose type lacks a call signature. Type 'String' has no compatible call signatures. 咦？导致此严重错误消息的原因是什么？那么我们的Stringify映射类型不仅映射了我们的元组成员，它还映射了方法Array以及length属性！所以forEach，length两者都有类型string！ 虽然在技术上一致的行为，我们的大多数团队认为这个用例应该只是工作。在迭代元组和数组时，映射对象类型现在只是“做正确的事”，而不是引入用于映射元组的新概念。这意味着，如果你已经使用现有的映射类型，如Partial或Required从lib.d.ts，他们就自动元组和数组现在的工作。 函数声明的属性在JavaScript中，函数只是对象。这意味着我们可以随意将属性粘贴到它们上面： 1234567export function readFile(path) &#123; // ...&#125;readFile.async = function (path, callback) &#123; // ...&#125; TypeScript的传统方法是一种非常通用的结构，称为namespaces（如果你已经足够老了，也称为“内部模块”）。除了组织代码之外，命名空间还支持值合并的概念，您可以以声明方式向类和函数添加属性： 123456789export function readFile() &#123; // ...&#125;export namespace readFile &#123; export function async() &#123; // ... &#125;&#125; 虽然他们的时间可能很优雅，但这种结构并没有很好地老化。ECMAScript模块已成为在更广泛的TypeScript和JavaScript社区中组织新代码的首选格式，名称空间是特定于TypeScript的。此外，名称空间不与var，let或const声明合并，因此代码如下（由defaultPropsReact驱动）： 1234567export const FooComponent =&gt; (&#123; name &#125;) =&gt; ( &lt;div&gt;Hello! I am &#123;name&#125;&lt;/div&gt;);FooComponent.defaultProps = &#123; name: \"(anonymous)\",&#125;; 甚至不能简单地转换成 12345678910export const FooComponent =&gt; (&#123; name &#125;) =&gt; ( &lt;div&gt;Hello! I am &#123;name&#125;&lt;/div&gt;);// Doesn't work!namespace FooComponent &#123; export const defaultProps = &#123; name: \"(anonymous)\", &#125;;&#125; 所有这些都可能令人沮丧，因为它更难以迁移到TypeScript。 鉴于所有这些，我们认为让TypeScript对这些类型的模式更“智能”会更好。在TypeScript 3.1中，对于使用函数const初始化的任何函数声明或声明，类型检查器将分析包含的范围以跟踪任何添加的属性。这意味着两个示例 - 无论readFile是我们的FooComponent示例还是我们的示例 - 在TypeScript 3.1中无需修改即可运行！ 作为一个额外的好处，此功能与TypeScript 3.0的支持相结合，JSX.LibraryManagedAttributes使得无类型的React代码库迁移到TypeScript 变得非常容易，因为它了解哪些属性在以下情况下是可选的defaultProps： 123// TypeScript understands that both are valid:&lt;FooComponent /&gt;&lt;FooComponent name=\"Nathan\" /&gt; 突破性变化我们的团队总是努力避免引入重大变化，但不幸的是有些人需要注意TypeScript 3.1。 已删除特定于供应商的声明TypeScript 3.1现在lib.d.ts使用WHATWG DOM规范提供的Web IDL文件生成部分（和其他内置声明文件库）。虽然这意味着lib.d.ts更容易保持最新，但许多特定于供应商的类型已被删除。我们在维基上更详细地介绍了这一点。 缩小功能的差异使用typeof foo === &quot;function&quot;型保护用的由相对可疑联合类型相交时可提供不同的结果{}，Object或不受约束泛型。 12345function foo(x: unknown | (() =&gt; string)) &#123; if (typeof x === \"function\") &#123; let a = x() &#125;&#125; 您可以在我们的wiki的重大更改部分阅读更多内容。 未来我们期待听到您对RC的体验。与往常一样，请密切关注我们的路线图，以便在我们稳定时全面了解发布情况。我们希望在短短几周内发布我们的最终版本，所以现在就试试吧！ 资源 原文 https://blogs.msdn.microsoft.com/typescript/2018/09/13/announcing-typescript-3-1-rc/","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.09.14","slug":"2018-09-14","permalink":"https://zj-john.github.io/tags/2018-09-14/"},{"name":"typescript","slug":"typescript","permalink":"https://zj-john.github.io/tags/typescript/"}]},{"title":"评估任何新JavaScript库时需要考虑的12件事","date":"2018-09-17T07:51:01.000Z","path":"notes/ckbdbl434006e2ktywtkmk5k3.html","text":"您如何知道新技术是否值得投入时间？ 对于今年的JavaScript状态调查，我想深入挖掘一下，不仅知道人们使用了哪些工具和库，还知道他们使用它们的原因。 这意味着我必须找到一种方法将个人偏好转化为数据。经过一些研究，我提出了12分制，涵盖了挑选和使用任何技术的主要方面。 参加测验为了让您更容易将12分制应用于任何库，我准备了一个快速测验，将引导您完成所有12个因素并给出最终建议： ➡️参加12因素测验如果您不确定要评估什么，只需在您熟悉的库（React，Vue，jQuery ……）上进行评估，看看它的得分情况如何！ 或者，您可以继续阅读以了解有关每个因素的更多信息，并了解如何应用这些因素。 注意：关于JavaScript调查的状态就像我提到的那样，我最初开发这种得分制是为了获得年度JavaScript状态调查的更精细数据。 如果您想贡献并帮助确定JavaScript生态系统的最新趋势，请参加调查)！ 现在回到12分制。 因素这是完整列表： 🕹️特色 🐞稳定性 ⚡表现 🎁包装生态系统 🌎社区 👶学习曲线 📖文档 🔧工具 🏛️跟踪记录 👫团队 ⚖️兼容性 📈动量 我将解释每个因素的重要性，并为您提供一个评分方式，向您展示如何评估它。我们来看看清单吧！ 🕹️特色你选择任何技术的第一个原因可能就是它的作用。 但这里的关键问题是了解这个库的功能边界。React可能是目前最流行的前端库，但常见的抱怨是它做得还不够，比如它将路由和状态管理等内容留给第三方库，如React-Router和Redux。 事实上，这是React最大竞争对手Vue的一个重要吸引点。Vue通过为常见用例提供官方软件包，它可以提供更全面的解决方案并获得大量支持。 再说一次，边界太远（功能太多），你可能会得到一个臃肿，复杂的框架，试图成为每个人的唯一。 所以有时候，最简单的方法就是找需要的。像Lodash或Ramda这样的库可以让你用简洁的函数表达式替换乱糟糟的嵌套for循环，这足以使它们成为重要的工具。 同样，这一切都是为了寻找合适的平衡！ 评分系统 A：解锁之前无法实现的事情。 B：让你做与以前一样的事情，但是以更好的方式。 C：比现有解决方案少。 🐞稳定性您可以拥有最优雅，功能全面的框架，但如果开发人员使用时每两分钟发生一次错误，则不会拥有太多用户。 因此，当前JavaScript生态系统中的许多工具都专注于添加稳定性和安全性。只看TypeScript和Flow的成功，甚至是Reason等语言。 在数据层方面，GraphQL的类型系统也有助于确保一切顺利运行。 评分系统 A：更少的错误，问题变得更容易调试和解决。 B：采用该技术不会对软件的稳定性产生影响。 C：采用该技术的直接后果是出现了新的错误和问题。 ⚡表现如果你曾经训练过武术，你就会知道你可以拥有的最好的属性之一就是速度，而不是力量。 同样，如果您的应用需要15秒才能加载，那么世界上的所有功能都无济于事。到那个时候，用户已经关闭了标签，你甚至在它开始之前就已经失败了！ 在JavaScript生态系统中，只看Preact可以看到一个关注速度的例子：它的API与React完全相同，因此它不会试图在功能强度上进行竞争。但是，与React相比，它的重量更轻，加载更快，可以节省宝贵的毫秒数并提高webapp的性能。 评分系统 A：更轻的捆绑，更快的加载时间或其他性能改进。 B：采用该技术不会对您的软件性能产生影响。 C：采用这项技术可以显着降低您的应用程序速度。 🎁包装生态系统在投资任何新技术之前，重要的是要看看围绕它开发的生态系统。 一个充满活力的软件包生态系统不仅可以节省大量时间，因为它可以让您捎带其他人的工作，但这也表明该技术已经达到了一定的成熟度水平。出于这个原因，维护良好的第三方软件包是开发人员长期采用技术的最佳标志之一。 评分系统 A：生态系统对共同关注的问题有明确的解决方案; 第三方软件包维护良好且记录良好。 B：具有许多竞争新选项的萌芽包装生态系统。 C：没有包装生态系统可言，需要大量的手工工作。 🌎社区另一个要考虑的因素是整个社区。遇到问题时，专用论坛或Slack渠道可以提供巨大的帮助。频谱是聊天室和传统论坛之间日益流行的中间立场 拥有Stack Overflow现有的存储库以查找它也很有帮助。当然，维护良好的GitHub问题页面是必须的！ 评分系统 A：论坛和/或聊天室（Slack / Discord / etc。）与日常活动，GitHub问题在一天内解决。许多人回答了Stack Overflow的问题。 B：不经常活动的论坛和/或聊天室。 C：GitHub之外没有社区。 👶学习曲线简单的学习曲线使开发人员更有可能为您的框架或库提供一个机会。人们很容易认为，如果一项技术真正具有破坏性，那么人们就会克服任何障碍，但通常情况并非如此。 一个密切相关（但有时相反）的概念是“采用”曲线。首次推出时，Meteor非常易于使用（至少与现有替代品相比），但它要求您立即采用整个堆栈，这使得现有项目很难实施。 React也以其粗略的学习曲线而闻名：对于用于分离HTML和JavaScript的开发人员来说，不得不使用JSX可能很难。另一方面，Vue使得开始更容易，而不必重新思考您对前端编码的思考方式。 评分系统 A：可以在一天内开始。 B：在提高生产率之前需要大约一周的时间。 C：学习基础知识需要一周多的时间。 📖文档简单学习曲线的一个重要部分就是拥有出色的文档。这比听起来更难实现，因为撰写文档的人通常是经验最丰富的人; 这意味着他们也离开了新的开发者体验。 因此，编写好的文档需要忘记你所知道的一秒钟，并让自己置身于发现你的技术的人之中。 它还需要预测常见问题，了解用户的心理模型，最重要的是在代码库发生变化时保持最新状态！所有这些都需要宝贵的时间远离实际编码…… 鉴于所有这些因素，您可以理解为什么好的文档是一种罕见且有价值的东西！ 评分系统 A：专用文档站点，截屏视频，示例项目，教程，API文档和评论良好的代码。 B：基本自述文件和API文档。 C：非常简洁自述，了解如何使用库的唯一方法是查看其代码。 🔧工具就像文档一样，工具是这些事情中的一个，可能看起来像是一些维护者的次要分心，但实际上对于任何技术的普及和成功至关重要。 我相信Redux成功背后的一个重要原因是其令人惊叹的Devtools浏览器扩展，它允许您以非常用户友好的方式可视化Redux存储和操作。同样，VS Code的强大TypeScript支持也为它的采用创造了奇迹。 评分系统 A：两个或多个：浏览器扩展，文本编辑器扩展，CLI实用程序，专用的第三方SaaS服务。 B：其中之一：浏览器扩展，文本编辑器扩展，CLI实用程序，专用的第三方SaaS服务。 C：没有外部工具。 🏛️跟踪记录在一天结束的时候，即使是最优雅，记录最好的图书馆也会很容易被解雇，因为如果它只存在了六个月，那就不过是昙花一现了。 我们都可以讲述采用“下一件大事”的故事，只是在事情开始恶化的时候回到好的旧Rails / PHP / *插入试用过的技术*。 出于这个原因，没有任何东西可以击败坚实的记录。Express是其中一个例子：它最初是在2010年发布的，但仍然被认为是默认的Node.js服务器框架，尽管JavaScript生态系统的发展速度很快。 评分系统 A答：已经四年多了，收养了我的主要公司和知名的技术咨询公司。 B：已经存在了1-4年，被早期采用者和小规模咨询公司使用。 C：已经存在不到一年，还没有真正的采用。 👫团队并非所有项目都有现有的跟踪记录。当图书馆是全新的，你如何判断它的潜力？一种可靠的方式来看看它背后的人。 当React第一次出现时，除了Facebook背后的事实是一个很大的争论，至少要尝试一下。然后Facebook继续发布Relay和GraphQL，表明React的成功不是侥幸！ 大公司也有更多的投资资源：即使发布了更新的，不兼容的版本，谷歌也能够继续保持原有的Angular.js。 当然，这并不意味着单独的维护者也无法创造重大创新。这毕竟是Vue.js的诞生，更不用说99％的开源软件了。 评分系统 A：由一家拥有专门的开源团队的大公司维护。 B：由一个中等规模的工程师团队维护，拥有坚实的个人记录。 C：孤独的维护者独立工作。 ⚖️ 兼容性采用尖端库的好处在于它们通常发展得非常快。可悲的是，这也可能是一个重大的缺点！ 快速改进率也可能意味着频繁的突破性变化，因为新的最佳实践取代了旧的模式，让早期采用者支付重构成本。 当他们决定在版本3和版本4之间完全改变他们的API时，React Router产生了很多抱怨。当他们从Angular.js切换到新的“只是Angular”时，Angular也是如此。 当您刚刚开始一个新项目时，频繁更新很有趣也很令人兴奋，但是一旦您的应用程序启动并在生产中运行，您最不希望的是每次新版本的库来时都需要花费数周的重构和调试出。 评分系统 A：更新大多是向后兼容的，弃用是通过警告处理的，不兼容的旧版本可以维护两年或更长时间。 B：确实发生了突破性的变化，但有很好的记录，并逐步推出。 C：如果没有适当的指导，经常需要进行重大更新。 📈动量最后但同样重要的是，势头。换句话说，炒作。 炒作通常被认为是一件坏事（“不要成为炒作的受害者”），作为风格超过实质的指标。但并非总是如此。 有了足够的动力，一个新的软件项目可以吸引更多的用户和更多的贡献者，这意味着可以更快地找到和修复错误，一个包生态系统可以开发，每个人最终都会变得更好。 但是，是的，还有硬币的另一面：过早炒作太多可能会让潜在用户面临一个充满问题的未完成版本，并将其彻底解决。就像他们说的那样，你只有一次机会给人留下第一印象。 评分系统 A：超过9000的炒作水平：黑客新闻的顶部，成千上万的GitHub明星，在主要会议上进行会谈。 B：最初推出的一些兴趣，数百名GitHub明星。 C：孤独的开发商在默默无闻中辛勤劳作。有一天我会告诉他们！我会告诉他们所有!! 更新：更多因素你们中的一些人提出了一些值得关注的重要因素。要考虑潜在版本2.0的规模！ 可扩展性：该技术对大型项目的效果如何。 采用：目前还有谁在使用该技术？ 兼容性：该技术与其他现有技术的兼容性如何？ 解耦：如果您想停止使用它，迁移出技术有多容易？ 案例研究：Apollo客户让我们将我们的评分系统应用到一个真实的，真实的图书馆：Apollo Client。 Apollo是一个GraphQL客户端，换句话说，它是一个库，它将查询GraphQL端点并为您加载客户端上的数据。它还处理诸如缓存之类的事情，确保数据不会重复，并将所述数据发送到您选择的前端库。 让我们看看它在我们的评分系统中的作用！ 🕹️特点：BApollo为您提供了更好的查询数据的方法，因此它更多地是对现有工具的逐步改进。 🐞稳定性：A采用Apollo和GraphQL确实可以更轻松地推断您的数据并追踪问题。 ⚡表现：BApollo确实包含了优化数据加载的工具，但总体上不应该对应用程序的性能产生巨大影响。 🎁包装生态系统：AApollo支持称为链接的包，以启用额外的功能。 🌎社区：BApollo确实有一个非常活跃的Slack聊天室，但根据我的经验，问题有时可能无法回答，很难得到繁忙的核心团队成员的回复。 👶学习曲线：B学习阿波罗的所有细微差别实际上可能是一个挑战，特别是如果你正在学习同时使用GraphQL。 📖文件：A为多个前端框架以及示例代码库提供了良好，维护良好的文档。 🔧工具：A浏览器扩展和专用度量平台。 🏛️跟踪记录：BApollo本身仍然相当新，但一般来说GraphQL空间也是如此。 👫团队：A非常称职和资金充足的团队，具有启动其他开源项目（Meteor）的经验。 ⚖️稳定性：B打破从v1到v2的更新，但总体上良好的稳定性和向后兼容性。 📈动量：B阿波罗可能还不是一个家喻户晓的名字，但它仍然是其利基的主导者，尽管雷莱的先声夺人。 …… 总体成绩：A🥇在最多36分中得到29分，阿波罗最终表现得非常好！即使总会有需要改进的地方，也很容易理解为什么许多需要可靠方法处理GraphQL数据的团队才会采用它。 其他方法NPMS的人们已经实施了类似的评级系统，通过查看GitHub和NPM数据实现了自动化。这使得他们的得分不那么主观，但另一方面却没有涵盖文档或社区等内容。 在原始数据方面，您还可以通过NPM趋势获得一些很酷的统计数据： 并详细了解最佳JS上目前流行的库： 当然，去年的JS州调查结果总是如此： 你怎么样，你通常如何评估图书馆？发表评论让我知道！ 结论这个量表绝不是图书馆价值的绝对衡量标准。毕竟这将主要是主观的，并且很大程度上取决于您的项目和您的需求。 不过，我们希望它可以作为一个有用的起点。如果没有别的，它可以作为一个清单，以确保你没有忽略任何重要的事情，然后再进入未来的大跳跃！ 资源 原文 https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49","tags":[{"name":"JavaScript Weekly","slug":"JavaScript-Weekly","permalink":"https://zj-john.github.io/tags/JavaScript-Weekly/"},{"name":"2018.09.14","slug":"2018-09-14","permalink":"https://zj-john.github.io/tags/2018-09-14/"}]},{"title":"AMP","date":"2018-09-01T03:13:51.000Z","path":"notes/ckbdbl404000q2ktyrbijngub.html","text":"AMP(Accelerated Mobile Pages)技术 WHY加速页面 + 集成标准 + SEO 支持：google、百度、搜狗、Yahoo（Japan） 国内：MIP（Mobile Instant Page） 标示： 主要技术 AMP HTML(核心) AMP HTML在图像显示等方面使用与HTML不同的专用标签，另外还限制了HTML部分功能的使用 ，后缀名.html 或 .amp.html AMP JS： JS库，保证AMP HTML的正确和快速显示。除此之外，AMP JS还负责在只支持普通HTML的浏览器中担任桥梁，使其能正确支持AMP HTML的专用功能。AMP HTML中可以调用该函数库 AMP Cache： 是缓存并传输AMP页面的CDN，进一步提高AMP网页的性能。用户在搜索引擎中点击AMP网页时，实际上访问的是优化后的缓存页面。Google的AMP Cache名为Google AMP Cache。 内容 &lt;html&gt; - &gt; &lt;html amp&gt; &lt;head&gt;标签：charset（必须）、viewport元标签（必须），格式固定的&lt;style&gt;元素，以及读取AMP JS库的&lt;script&gt;元素等（其中一部分顺序也有规定）、meta、css（必须内联、不能外部、不能style，不能important，不能*，增加attr：layout=“responsive”，&lt;style amp-custom&gt;） 自定义元素：&lt;amp-img&gt;，&lt;amp-sidebar&gt;，&lt;amp-facebook&gt;，&lt;amp-ad&gt;，&lt;amp-analytics&gt; 选择分辨率+自动延迟加载 脚本：原则上任何第三方js不能使用，用自定义组件（内置组件和扩展组件）替换（但可用，不能通过验证，实际无效） 验证 验证meta、viewport 等标签 验证标签属性，如：charset, rel, amp等 不允许引入第三方的script标签 个人观点1.AMP是集成解决方案，适用于从0开始，或易于改造的项目，对于交互和设计强的应用，成本过高（开发新组件、重构） 2.技术是：cdn(免费) + 预加载 + 组件优化，除预加载外，其余都可以在现有技术下做掉或已经做掉。 3.先检测下当前页面可优化的空间 总结：新页面：业务功能 评估 老页面：成本高（HTML重构 + 重新布局 + 交互有限）VS SEO评估 目前AMP提供共80+内置和扩展组件，基本覆盖了一般页面的需求（增长速度比较快，社区活跃） 目前可以使用的交互方式是，页面上可以通过AMP中的bind组件，设置一些变量，通过对变量的赋值及简单操作，改变变量值，来实现组件的显示、隐藏，达到交互效果","tags":[{"name":"AMP","slug":"AMP","permalink":"https://zj-john.github.io/tags/AMP/"}]},{"title":"一次Centos虚机硬盘扩容的操作","date":"2018-08-27T03:05:28.000Z","path":"tips/ckbdbl45q00bn2ktyai2ysqqe.html","text":"硬盘当前不断有写入，磁盘空间不足，不能重启。给磁盘加了容量后，fdisk中已经看到，df中还没有。 下面是识别过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181[root@myVM ~]# parted /dev/sdaGNU Parted 2.1Using /dev/sdaWelcome to GNU Parted! Type 'help' to view a list of commands.// 目前已有3块主分区，最多再加一块。(parted) print Model: VMware Virtual disk (scsi)Disk /dev/sda: 290GBSector size (logical/physical): 512B/512BPartition Table: msdosNumber Start End Size Type File system Flags 1 1049kB 525MB 524MB primary ext4 boot 2 525MB 193GB 193GB primary lvm 3 193GB 225GB 32.2GB primary(parted) unit s (parted) print Model: VMware Virtual disk (scsi)Disk /dev/sda: 566231040sSector size (logical/physical): 512B/512BPartition Table: msdosNumber Start End Size Type File system Flags 1 2048s 1026047s 1024000s primary ext4 boot 2 1026048s 377479304s 376453257s primary lvm 3 377479305s 440401919s 62922615s primary// 在最后一块分区的最后一个位置（440401919s）加1处添加一块主分区(parted) mkpart primary 440401920s 100%Warning: WARNING: the kernel failed to re-read the partition table on /dev/sda (Device or resource busy). As a result, it may not reflect all of your changes until after reboot.(parted) print Model: VMware Virtual disk (scsi)Disk /dev/sda: 566231040sSector size (logical/physical): 512B/512BPartition Table: msdosNumber Start End Size Type File system Flags 1 2048s 1026047s 1024000s primary ext4 boot 2 1026048s 377479304s 376453257s primary lvm 3 377479305s 440401919s 62922615s primary 4 440401920s 566231039s 125829120s primary(parted) unit gb (parted) print Model: VMware Virtual disk (scsi)Disk /dev/sda: 290GBSector size (logical/physical): 512B/512BPartition Table: msdosNumber Start End Size Type File system Flags 1 0.00GB 0.53GB 0.52GB primary ext4 boot 2 0.53GB 193GB 193GB primary lvm 3 193GB 225GB 32.2GB primary 4 225GB 290GB 64.4GB primary(parted) q [root@myVM ~]# more /proc/partitionsmajor minor #blocks name 8 0 283115520 sda 8 1 512000 sda1 8 2 156771358 sda2 8 3 31461307 sda3 253 0 8388608 dm-0 253 1 179830784 dm-1//加入分区表[root@myVM ~]# addpart /dev/sda 4 440401920s 125829120s[root@myVM ~]# more /proc/partitionsmajor minor #blocks name 8 0 283115520 sda 8 1 512000 sda1 8 2 156771358 sda2 8 3 31461307 sda3 8 4 62914560 sda4 253 0 8388608 dm-0 253 1 179830784 dm-1// 创建PV[root@myVM ~]# pvcreate /dev/sda4 Physical volume \"/dev/sda4\" successfully created// 扩展VG[root@myVM ~]# vgextend /dev/VolGroup00 /dev/sda4 Volume group \"VolGroup00\" successfully extended[root@myVM ~]# vgdisplay -v Finding all volume groups Finding volume group \"VolGroup00\" --- Volume group --- VG Name VolGroup00 System ID Format lvm2 Metadata Areas 3 Metadata Sequence No 15 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 3 Act PV 3 VG Size 239.47 GiB PE Size 32.00 MiB Total PE 7663 Alloc PE / Size 5744 / 179.50 GiB Free PE / Size 1919 / 59.97 GiB VG UUID VmXybG-XlLj-89WX-xu7S-Wv2v-lcFm-RP2I80 --- Logical volume --- LV Path /dev/VolGroup00/lv_swap LV Name lv_swap VG Name VolGroup00 LV UUID agW1rd-InHh-00KJ-VtDq-qXzf-X20Y-2AAS8w LV Write Access read/write LV Creation host, time localhost.localdomain, 2016-08-15 02:13:38 +0800 LV Status available # open 1 LV Size 8.00 GiB Current LE 256 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 253:0 --- Logical volume --- LV Path /dev/VolGroup00/lv_root LV Name lv_root VG Name VolGroup00 LV UUID ehJEGy-Ln22-Gv2u-vswq-MK2f-f4Q5-DsR5rs LV Write Access read/write LV Creation host, time localhost.localdomain, 2016-08-15 02:13:38 +0800 LV Status available # open 1 LV Size 171.50 GiB Current LE 5488 Segments 2 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 253:1 --- Physical volumes --- PV Name /dev/sda2 PV UUID V4kpvd-4450-H6Ud-dLaH-0xyz-yebc-fxckbd PV Status allocatable Total PE / Free PE 4784 / 0 PV Name /dev/sda3 PV UUID ZNv0MZ-vLFv-5c0i-hxFA-8Xmq-TOW4-nuaVcp PV Status allocatable Total PE / Free PE 960 / 0 PV Name /dev/sda4 PV UUID oBbCrF-CzVU-8Xyq-3wei-wAL6-vkLu-T5b0EJ PV Status allocatable Total PE / Free PE 1919 / 1919// 扩展lv并加入文件系统[root@myVM ~]# lvextend -l +100%free -r /dev/VolGroup00/lv_root Extending logical volume lv_root to 231.47 GiB Logical volume lv_root successfully resizedresize2fs 1.41.12 (17-May-2010)Filesystem at /dev/mapper/VolGroup00-lv_root is mounted on /; on-line resizing requiredold desc_blocks = 11, new_desc_blocks = 15Performing an on-line resize of /dev/mapper/VolGroup00-lv_root to 60678144 (4k) blocks.The filesystem on /dev/mapper/VolGroup00-lv_root is now 60678144 blocks long.[root@myVM ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup00-lv_root 228G 149G 68G 69% /tmpfs 12G 0 12G 0% /dev/shm/dev/sda1 485M 60M 400M 14% /boot","tags":[{"name":"虚机","slug":"虚机","permalink":"https://zj-john.github.io/tags/虚机/"},{"name":"硬盘扩容","slug":"硬盘扩容","permalink":"https://zj-john.github.io/tags/硬盘扩容/"},{"name":"centos7","slug":"centos7","permalink":"https://zj-john.github.io/tags/centos7/"}]},{"title":"响应式Web设计 HTML5与CSS3实战","date":"2018-08-26T03:29:07.000Z","path":"notes/ckbdbl42u005w2kty0ziwytdm.html","text":"这本书很薄，总共220页。整体上讲，和响应式相关的内容只有2章左右的内容，剩下的篇幅都在介绍新技术点，比如Flex布局、HTML5新特性、CSS3新特性及动画等。 记录一些笔记如下： 响应式WEB设计基础响应式3要素：弹性布局、弹性图片、媒体查询浏览器支持：先写一个轻量级的代码架构，然后根据所需体验针对能力更强的浏览器进行扩展，包括视觉和功能。浏览器特性查询：地址 视口：viewport，呈现网页的区域1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 图片：123img &#123; max-width: 100%;&#125; 不针对流行的设备宽度设置断点，即不绑定特定设备屏幕，而由内容和设计本身决定 在手机等小屏幕设备下改变链接、字体大小 媒体查询css支持特性：width, height, orientation, device-width(废弃), device-height（废弃）, aspect-ratio(视口的宽高比：16/9), color, color-index, monochrome, resolution(分辨率), scan, grid支持前缀：min, max123@media screen and (min-width: 320px) &#123;&#125; html1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"srceen and (orientation: portrain) and (min-width: 800px), projection\" href=\"800wide-portrait-screen.css\"&gt; “,”号组合多个媒体查询，任何一个为真就执行。 meta12345&lt;meta name=\"viewport\" content=\"maximum-scale=3,minimum-scale=0.5\"&gt;// 不可缩放&lt;meta name=\"viewport\" content=\"initial-scale=1.0,user-scalable=no\"&gt;// more&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; 媒体查询4级script1234567@media (scripting: none) &#123;&#125;@media &#123;scripting: enabled&#125; &#123;&#125; pointercoarse, fine, none123456@media (pointer: coarse) &#123; // 非精确指针，普通触屏&#125;@media (pointer:fine) &#123; // 精确指针，手写笔等&#125; light-level123456789@media (light-level: normal) &#123; // 标准亮度&#125;@media (light-level: dim) &#123; // 光线较暗&#125;@media (light-level: washed) &#123; // 光线较强&#125; 弹性布局与响应式图片将固定像素大小转换为弹性比例大小，目标/上下文 CSS自动加前缀：Autoprefixer flexbox1display:flex 关键字： 方向、对齐、次序、弹性 容器flex-direction:flex-wrap:flex-flow:justify-content:主轴上元素对齐方式align-item:交叉轴上元素对齐方式align-content: Itemorder: -1 位于其它元素之前flex-grow: 空间足够的情况下，可放大的量flex-shrink: 空间不够的情况下，可缩小的量flex-basis: 基准flex: flex-grow flex-shrink flex-basisalign-self:元素独立的对齐方式 响应式图片1234567&lt;picture&gt; &lt;source media=\"&#123;min-width:30em&#125;\" srcset=\"small.jpg\"&gt; &lt;source media=\"&#123;min-width:60em&#125;\" srcset=\"big.jpg\"&gt; &lt;img src=\"default.jpg\" alt=\"pic\"&gt;&lt;/picture&gt;// 等同于&lt;img srcset=\"small.jpg 450w, big.jpg 900w\" size=\"&#123;min-width: 30em&#125; 100vw, &#123;min-width: 60em&#125; 50vw\" src=\"default.jpg\" alt=\"pic\"&gt; 450w 这里的w不是真实大小，只是对浏览器的一个提示，大致等于图片的“CSS像素”大小，srcset的值是浏览器自己决定选择哪一个。图片描述首先是图片名，然后是一个分辨率说明。 HTML5与响应式Web设计新增语义元素 main section nav aside figure, figcaption (注解、图示、照片、代码) detail, summary （自带折叠效果） header footer address WCAG 和 WAI-ARIAWCAGWAI-ARIA 外部服务内嵌框架在线服务，为YouTube视频、GoogleMap生成嵌入代码 CSS3响应式多列布局123456789101112main &#123; column-width: 12em&#125;// 或main &#123; column-count: 4;&#125;// 其它main &#123; column-gap:2em; column-rule: thin dotted #999;&#125; 12345678910// default.Item &#123; display: flex;&#125;// 特性查询@support ((display: flex) and (pointer: coarse) or (transform: translate3d(0,0,0))) &#123; .Item &#123; display: flex; &#125;&#125; 特性查询插件：modenizr H5之前，以数值开头的ID和类是无效的，css目前仍不允许以数值开头的选择器，但可以用属性选择器绕过 .span-class:nth-of-type(-2n+3): 每种element元素类型，单独运算 .Item:nth-child(4n+1):nth-last-child(-n+4): 等价于nth-child(4n+1) and nth-last-child(-n+4) 没有内容时的样式.thing:empty{ display:none} css自定义变量：:root { –MainFont: ‘Microsoft Yahei’} .Title { font-family: var(–MainFont)} css属性越靠下，优先级越高 HSL：hsl(315, 100%, 60%):315：黄色 60，绿色120，青色 180，蓝色240， 洋红300， 红360100%：饱和度60%： 亮度 CSS3高级技术渐变工具CSS纹理 括号外的决定了页面结构，括号内的决定了页面的性能 性能优化 SVGSVG生成工具svg-editdrawsvg from-svg-to-icon svg动画snapsvggreensockvelocityjs 优化SVGsvgo浏览器版svgo svg内部样式媒体查询1234567891011121314&lt;style type=\"text/css\"&gt; &lt;![CDATA[ #start_path &#123; stroke: red; &#125; // min--device-width 代替 min-width，min-width代表了svg的宽度 @media (min--device-width: 800px) &#123; #start_path &#123; stroke: violet; &#125; &#125; ]]&gt;&lt;/style&gt; CSS3过渡、变形和动画过渡调速函数：贝塞尔曲线 调速 hack方式123* &#123; transtition:all 1s&#125; matrix变形 让老式浏览器支持H5新特性新特性补丁 Form CSS3123456789input:required &#123;&#125;input:required:invalid + label:after&#123;&#125;input:required:valid &#123;&#125; 原型工具css断点与JS联系起来 避免在生产中使用类似bootstrap或foundation等CSS框架，1、过于冗余，2、没有美感，3、不了解原理 代码检查工具页面性能分析HTTP2 for frontend","tags":[{"name":"响应式设计","slug":"响应式设计","permalink":"https://zj-john.github.io/tags/响应式设计/"},{"name":"flexbox","slug":"flexbox","permalink":"https://zj-john.github.io/tags/flexbox/"}]},{"title":"5分钟搭建属于自己的mock server平台","date":"2018-08-22T09:12:03.000Z","path":"projects/ckbdbl46700cl2ktyf0u3nufo.html","text":"利用service worker 和 GitHub，5分钟搭建属于自己的mock server平台。 功能：Mock server 工具：servie worker, GitHub 难度等级: ★★ 项目地址: https://github.com/zj-john/GitHubMockServerSample 功能此项目配合MyMockData一起使用。 我们做了什么： 把GitHub项目作为我们的mock server的数据源，例如MyMockData 在项目中，通过service-worker.js，把数据源中的json数据，转化为json数据所描述的http响应，达到mock server的效果 可以通过json数据更改响应码、响应时间、响应头、校验post数据等功能 json举例：1234567891011&#123; \"RequestMethod\":[\"GET\"], \"ResponseHeaders\":&#123;&#125;, \"StatusCode\": \"200\", \"Response\": &#123; \"success\": true, \"message\": \"\", \"data\": \"This is a get mock data\" &#125;, \"ResponseTime\": 1000&#125; 结构说明123456789101112131415161718│ .gitignore│ README.md│ service-worker.js│└─demo │ app.js │ package.json │ ├─certificate │ ca.cer │ csr.pem │ private.pem │ └─public index.html index.js service-worker.js styles.css 整个目录结构分为2部分， service-worker.js我们用于解析mock data的文件，mock data的组成参考MyMockData项目。 在你的项目根文件(假设为index.html)中加入如下代码：123456789101112131415&lt;script&gt; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('service-worker.js').then(function(reg) &#123; if(reg.installing) &#123; console.log('Service worker installing'); &#125; else if(reg.waiting) &#123; console.log('Service worker installed'); &#125; else if(reg.active) &#123; console.log('Service worker active'); &#125; &#125;).catch(function(error) &#123; console.log('Registration failed with ' + error); &#125;); &#125;&lt;/script&gt; 更精简的版本：12345&lt;script&gt; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('service-worker.js'); &#125;&lt;/script&gt; 把service-worker.js 拷贝到项目根目录下即可。 demodemo文件夹下是一个可以运行的，基于node，使用https的web站点。此示例中可以看到mock server的完整用法。 地址 chrome环境配置：本地运行的https是不安全的，所以要想service-worker能够成功运行，需要配置下浏览器的启动参数。 windows下启动参数配置如下:1C：\\ Program Files（x86）\\ Google \\ Chrome \\ Application \\ chrome.exe --ignore-certificate-errors --unsafely-treat-insecure-origin-as-secure= https://localhost:8001 MacOS：1/ Applications / Google \\ Chrome.app/Contents/MacOS/Google \\ Chrome --user-data-dir = / tmp / foo --ignore-certificate-errors --unsafely-treat-insecure-origin-as-secure = https://localhost:8001 关于此配置的更多内容请参考：https://deanhume.com/testing-service-workers-locally-with-self-signed-certificates/","tags":[{"name":"service worker","slug":"service-worker","permalink":"https://zj-john.github.io/tags/service-worker/"},{"name":"mock server","slug":"mock-server","permalink":"https://zj-john.github.io/tags/mock-server/"}]},{"title":"利用service worker缓解DNS劫持","date":"2018-08-21T08:12:57.000Z","path":"projects/ckbdbl46c00ct2kty9njstzbl.html","text":"运营商DNS劫持是一种常见的客户故障场景，利用service worker可以缓解这种情况，在劫持后还能正常访问。 功能：DNS劫持缓解 工具：servie worker 难度等级: ★★ 项目地址: https://github.com/zj-john/RelieveDNSHijackingbySW SWForSolveDNSHijacking使用service worker缓解DNS被劫持的问题 功能通过service worker的配置，在域名被劫持或其它无响应的情况下，通过config文件中配置的备用域名进行替换访问，备用域名访问成功后会把资源加入缓存。 目录结构123456789101112131415161718192021222324│ .gitignore│ dnsconfig.json│ README.md│ service-worker.js│├─demo │ app.js │ package.json │ ├─certificate │ ca.cer │ csr.pem │ private.pem │ └─public │ dnsconfig.json │ index.html │ service-worker.js │ ├─css │ style.css │ └─js main.js 整个目录结构分为2部分， 主要功能部分service-worker.js在你的项目根文件(假设为index.html)中加入如下代码：123456789101112131415&lt;script&gt; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('service-worker.js').then(function(reg) &#123; if(reg.installing) &#123; console.log('Service worker installing'); &#125; else if(reg.waiting) &#123; console.log('Service worker installed'); &#125; else if(reg.active) &#123; console.log('Service worker active'); &#125; &#125;).catch(function(error) &#123; console.log('Registration failed with ' + error); &#125;); &#125;&lt;/script&gt; 更精简的版本：12345&lt;script&gt; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('service-worker.js'); &#125;&lt;/script&gt; 把service-worker.js 拷贝到项目根目录下即可。 dnsconfig.json域名主备配置1234567&#123; &quot;webresource.c-ctrip.com&quot;:&#123; &quot;backupType&quot;: &quot;domain&quot;, &quot;backup&quot;:[&quot;webresource.ctrip.com&quot;], &quot;addCache&quot;:true &#125;&#125; 使用时，把config配置为自己需要的内容，拷贝到项目根目录下即可。 demodemo文件夹下是一个可以运行的，基于node，使用https的web站点。 地址 chrome环境配置：本地运行的https是不安全的，所以要想service-worker能够成功运行，需要配置下浏览器的启动参数。 windows下启动参数配置如下:1C：\\ Program Files（x86）\\ Google \\ Chrome \\ Application \\ chrome.exe --ignore-certificate-errors --unsafely-treat-insecure-origin-as-secure= https://localhost:8001 MacOS：1/ Applications / Google \\ Chrome.app/Contents/MacOS/Google \\ Chrome --user-data-dir = / tmp / foo --ignore-certificate-errors --unsafely-treat-insecure-origin-as-secure = https://localhost:8001 关于此配置的更多内容请参考：https://deanhume.com/testing-service-workers-locally-with-self-signed-certificates/","tags":[{"name":"service woker","slug":"service-woker","permalink":"https://zj-john.github.io/tags/service-woker/"},{"name":"DNS劫持","slug":"DNS劫持","permalink":"https://zj-john.github.io/tags/DNS劫持/"}]},{"title":"service worker","date":"2018-08-20T03:47:52.000Z","path":"notes/ckbdbl42s005p2ktyd51gbm6s.html","text":"Service WorkerService worker是一个注册在指定源和路径下的事件驱动worker，本质上是WEB应用和浏览器，浏览器和网络之间的可编程代理 功能： 创建有效的离线体验（细粒度地缓存资源） VS AppCache,前者更灵活 离线有必要吗？ 原生APP vs WebAPP 拦截并修改访问和资源请求 访问推送通知和后台同步API 特点： 不能访问DOM 只能HTTPS 纯异步（同步API不可使用） 生命周期下载首次访问service worker控制的网站或页面时，service worker会立刻被下载。之后，至少每24小时它会被下载一次 安装 首次加载 与现有service worker不同（字节对比） 激活 现有service worker已启用，新版本会在后台安装，但不会被激活（worker in waiting） 所有已加载的页面不再使用旧的service worker(当网站上当前打开的页面关闭时)才会激活新的service worker（active worker） 步骤 service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。 如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 woker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。 service worker 现在可以处理事件了。 受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。 当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。 下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。 Service Worker 现在可以控制页面了，但仅是在 register() 成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。（首次注册该服务工作线程的页面需要再次加载才会受其控制） 使用场景现在： 后台数据同步 响应来自其它源的资源请求 集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据 在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的） 后台服务钩子（反爬处理） 自定义模板用于特定URL模式 性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片 将来： 后台同步：启动一个service worker即使没有用户访问特定站点，也可以更新缓存 响应推送：启动一个service worker向用户发送一条信息通知新的内容可用 对时间或日期作出响应 进入地理围栏（用一个虚拟的栅栏围出一个虚拟地理边界） 事件 常用接口 Cache表示用于Request/Response对象对的存储，作为ServiceWorker生命周期的一部分被缓存。 CacheStorage表示Cache对象的存储。提供一个所有命名缓存的主目录，ServiceWorker可以访问并维护名字字符串到Cache对象的映射。 Client表示service worker client的作用域。一个service worker client可以是浏览器上下文的一个文档，也可以是一个由活动worker控制的SharedWorker。 Clients表示一个Client对象容器，是访问当前源的活动service worker clients的主要途径。 ExtendableEvent扩展被分发到ServiceWorkerGlobalScope的install和activate事件时序，作为service worker生命周期的一部分。这会确保任何功能型事件（如FetchEvent）不被分发到ServiceWorker，直到它更新了数据库架构、删除过期缓存项等等以后。 FetchEvent传递给ServiceWorkerGlobalScope.onfetch处理函数的参数，FetchEvent代表一个在ServiceWorker的ServiceWorkerGlobalScope中分发的请求动作。它包含关于请求和响应的结果信息，并且提供FetchEvent.respondWith()方法，这个方法允许我们提供任意的响应返回到控制页面。 InstallEvent传递给oninstall处理函数的参数，InstallEvent接口代表一个在ServiceWorker的ServiceWorkerGlobalScope中分发的安装动作，作为ExtendableEvent的子事件，它保证诸如FetchEvent 的功能性事件在安装过程中不会被分发。 Navigator.serviceWorker返回一个ServiceWorkerContainer对象，可以提供入口用于注册，删除，更新以及与在相关 document中ServiceWorker通信的对象。 NotificationEvent传递给onnotificationclick处理函数的参数，NotificationEvent 接口代表在ServiceWorker里ServiceWorkerGlobalScope中分发的单击事件通知。 ServiceWorker表示一个service worker。多个浏览的上下文(例如pages,workers等等)都能通过相同的ServiceWorker对象相关联。 ServiceWorkerContainer提供一个在网络生态中把service worker 作为一个整体的对象，包括辅助注册，反注册以及更新服务工作者，并且访问service worker 的状态以及他们的注册信息。 ServiceWorkerGlobalScope表示service worker的全局执行上下文。 ServiceWorkerMessageEvent包含关于一个发送给以navigator.serviceWorker为目标的事件信息。 ServiceWorkerRegistration表示service worker的注册。 WindowClient表示在浏览器上下文中记录的service worker客户端的作用域，被活动的工作者控制。是Client对象的特殊类型，包含一些附加的方法和可用的属性。 兼容性Chrome(&gt;42),Firefox(&gt;44)已支持 Chrome调试工具：chrome://serviceworker-internals/ Firefox调试工具：about:serviceworkers DEMOindex.html12345678910111213141516// 特性检查if ('serviceWorker' in navigator) &#123; // 注册 这个文件的url 是相对于 origin， 而不是相对于引用它的那个 JS 文件;scope为sw的作用范围，最大的 scope 是 service worker 所在的地址 navigator.serviceWorker.register('/sw.js', &#123; scope: '/' &#125;).then(function(reg) &#123; if(reg.installing) &#123; console.log('Service worker installing'); &#125; else if(reg.waiting) &#123; console.log('Service worker installed'); &#125; else if(reg.active) &#123; console.log('Service worker active'); &#125; &#125;).catch(function(error) &#123; // registration failed console.log('Registration failed with ' + error); &#125;);&#125; 缓存sw.js1234567891011121314151617181920212223242526272829303132333435363738self.addEventListener('install', function(event) &#123; event.waitUntil( caches.open('v1').then(function(cache) &#123; //addAll:参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表 return cache.addAll([ '/index.html', '/public/css/style.css', '/public/js/main.js', '/public/img/star-wars-logo.jpg', '/public/img/myLittleVader.jpg' ]); &#125;) );&#125;);// 缓存处理self.addEventListener('fetch', function(event) &#123; //允许我们对网络请求的资源和 cache 里可获取的资源进行匹配，查看是否缓存中有相应的资源。这个匹配通过 url 和 vary header进行 event.respondWith(caches.match(event.request).then(function(response) &#123; if (response !== undefined) &#123; return response; &#125; else &#123; return fetch(event.request).then(function (response) &#123; // response may be used only once // we need to save clone to put one copy in cache // and serve second one let responseClone = response.clone(); // 添加新缓存 caches.open('v1').then(function (cache) &#123; cache.put(event.request, responseClone); &#125;); return response; &#125;).catch(function () &#123; return caches.match('/default.jpg'); &#125;); &#125; &#125;));&#125;); 更改请求、响应1234567891011121314151617181920212223242526272829// 请求处理self.addEventListener('fetch', function(event) &#123; event.respondWith( fetch(event.request).then(function(response) &#123; return response; &#125;).catch(function() &#123; var request = event.request; // 判断资源类型 if(request.destination==='script') &#123; // 请求jQuery的资源报错，进行地址更换 if(request.url.indexOf('jquery')&gt;-1)&#123; var backupUrl = \"https://code.jquery.com/jquery-1.12.4.min.js\"; let backupRequest = new Request(backupUrl, &#123; method: request.method, headers: request.headers, credentials: request.credentials, redirect: 'manual', //从不支持 CORS 的第三方网址中获取资源 mode: 'no-cors' &#125;); return fetch(backupRequest); &#125; &#125; return new Response('&lt;p&gt;Resource Error!&lt;/p&gt;', &#123; headers: &#123; 'Content-Type': 'text/html' &#125; &#125;) &#125;) );&#125;); 更新service worker12345678910111213// activate 清理过期sw数据self.addEventListener('activate', function(event) &#123; var cacheWhitelist = ['v2']; event.waitUntil( caches.keys().then(function(keyList) &#123; return Promise.all(keyList.map(function(key) &#123; if (cacheWhitelist.indexOf(key) === -1) &#123; return caches.delete(key); &#125; &#125;)); &#125;) );&#125;); 单向通信index.html12345678function oneWayCommunication() &#123; if (navigator.serviceWorker.controller) &#123; navigator.serviceWorker.controller.postMessage(&#123; command: 'oneWayCommunication', message: 'Hi, SW' &#125;); &#125;&#125; 123456self.addEventListener('message', function(event) &#123; const data = event.data; if (data.command === 'oneWayCommunication') &#123; console.log(`Message from the Page : $&#123;data.message&#125;`); &#125;&#125;); 双向通信index.html123456789101112function twoWayCommunication() &#123; if (navigator.serviceWorker.controller) &#123; const messageChannel = new MessageChannel(); messageChannel.port1.onmessage = function(event) &#123; console.log(`Response from the SW : $&#123;event.data.message&#125;`); &#125; navigator.serviceWorker.controller.postMessage(&#123; command: 'twoWayCommunication', message: 'Hi, SW' &#125;, [messageChannel.port2]); &#125;&#125; 12345678self.addEventListener('message', function(event) &#123; const data = event.data; if (data.command === 'twoWayCommunication') &#123; event.ports[0].postMessage(&#123; message: 'Hi, Page' &#125;); &#125;&#125;); 广播index.html1234567891011121314151617function registerBroadcastReceiver() &#123; navigator.serviceWorker.onmessage = function(event) &#123; const data = event.data; if (data.command === 'broadcastOnRequest') &#123; console.log(`Broadcasted message from the ServiceWorker : $&#123;data.message&#125;`); &#125; &#125;;&#125;function requestBroadcast() &#123; registerBroadcastReceiver(); if (navigator.serviceWorker.controller) &#123; navigator.serviceWorker.controller.postMessage(&#123; command: 'broadcast' &#125;); &#125;&#125; sw.js12345678910111213self.addEventListener('message', function(event) &#123; const data = event.data; if (data.command === 'broadcast') &#123; self.clients.matchAll().then(function(clients) &#123; clients.forEach(function(client) &#123; client.postMessage(&#123; command: 'broadcastOnRequest', message: 'This is a broadcast on request from the SW' &#125;); &#125;) &#125;) &#125;&#125;); 参考文档 W3C: https://w3c.github.io/ServiceWorker/ Cookbook：https://serviceworke.rs/ https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers https://googlechrome.github.io/samples/service-worker/ https://zhuanlan.zhihu.com/p/27264234","tags":[{"name":"service worker","slug":"service-worker","permalink":"https://zj-john.github.io/tags/service-worker/"}]},{"title":"Module not found:Can't resolve '@babel/runtime/helpers/builtin/** in '...'","date":"2018-08-10T04:55:58.000Z","path":"tips/ckbdbl45v00bv2ktyh1ir56xo.html","text":"记录一个报错。很久没更新的一个项目重新启用时，报错：12./node_modules/_@material-ui_icons@1.1.0@@material-ui/icons/LocalCarWash.jsModule not found: Can&apos;t resolve &apos;@babel/runtime/helpers/builtin/interopRequireDefault&apos; in &apos;...\\node_modules\\_@material-ui_icons@1.1.0@@material-ui\\icons&apos; 项目之前一直很稳定，怎么会突然报错呢？ 看到的第一反应是：包没安装，然后马上1npm i @babel/runtime --save 然后再执行，错误依然。 这么会有这个问题呢，在项目的目录下找node_module文件夹，发现@babel/runtime/helpers下确实没有builtin目录，感觉到有可能是版本更新了。 于是看到网上有个issue中有人回答如下：12345678Everyone probably already has @babel/runtime as dependencies. Unfortunately Babel has removed the builtin helpers since v7.0.0-beta.56 (3 days ago). Since npm doesn&apos;t automatically update most people won&apos;t have this problem.Try installing v7.0.0-beta.55, this fixes your problem:... &quot;@babel/runtime&quot;: &quot;7.0.0-beta.55&quot;,...&#125; 所以新版本的runtime把builtin目录拆分掉了，以至于查不到对应的目录。 所以安装以下包可以解决问题：1npm i @babel/runtime@7.0.0-beta.55 --save 参考： https://github.com/jquense/yup/issues/216","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"},{"name":"babel/runtime","slug":"babel-runtime","permalink":"https://zj-john.github.io/tags/babel-runtime/"},{"name":"Error","slug":"Error","permalink":"https://zj-john.github.io/tags/Error/"}]},{"title":"chrome修改启动参数方式跨域","date":"2018-08-10T04:55:58.000Z","path":"tips/ckbdbl45x00c22ktybhsinw9t.html","text":"之前一直用–disable-web-security的方式，取消chrome的同源策略，实现跨域。 chrome版本升级之后，发现不在生效。 查资料发现从chrome49版本后，如果想要实现相同的跨域效果，需要同时在启动项中加上–user-data-dir指定存储用户信息的目录。 开启–disable-web-security后，chrome处于不安全模式。不能使用默认的用户信息目录。也就是说，不指定–user-data-dir的话，无法读取任何用户信息，如cookie等。对需要此类信息的站点，将无法正常访问。 12--disable-web-security :Don&apos;t enforce the same-origin policy. (Used by people testing their sites.)--user-data-dir :Directory where the browser stores the user profile. 添加chrome启动参数的方法见参考。 参考： chrome官方说明：https://codereview.chromium.org/1512843002 chrome启动参数：https://peter.sh/experiments/chromium-%20command-line-switches/ 添加chrome启动参数的方法：https://www.cnblogs.com/laden666666/p/5544572.html","tags":[{"name":"chrome","slug":"chrome","permalink":"https://zj-john.github.io/tags/chrome/"},{"name":"跨域","slug":"跨域","permalink":"https://zj-john.github.io/tags/跨域/"}]},{"title":"TravelOrderShare","date":"2018-08-09T07:59:34.000Z","path":"projects/ckbdbl46r00dj2ktypcrg6ws1.html","text":"在公司做的创新项目的小DEMO 功能：订单分享，生成图片，分享朋友圈 工具：ant-mobile, react 难度等级: ★★ 项目地址: https://github.com/zj-john/travelOrderShare 演示地址：https://zj-john.github.io/travelOrderShare/build/index.html 订单分享Demo描述用户完成下单后，从订单页面可以直接把本次订单分享出去。不同的订单使用不同的模板，编辑完成后可以直接分享到朋友圈。 操作酒店订单分享/机票订单分享/旅游订单分享 -&gt; 编辑或不编辑文字 -&gt; 分享 -&gt; 选择“朋友圈” -&gt; 朋友圈分享页面 -&gt; 点击分享的图片看大图 技术 ant-mobile canvas mobilebone","tags":[{"name":"prototype","slug":"prototype","permalink":"https://zj-john.github.io/tags/prototype/"},{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"ant mobile","slug":"ant-mobile","permalink":"https://zj-john.github.io/tags/ant-mobile/"}]},{"title":"python2.6安装pip","date":"2018-07-09T02:53:07.000Z","path":"tips/ckbdbl45m00bi2ktya4opft29.html","text":"VPS上默认的python版本是2.6.6，按照网上安装pip时，报错如下： 12345678910Traceback (most recent call last): File &quot;get-pi1p.py&quot;, line 20649, in &lt;module&gt; main() File &quot;get-pi1p.py&quot;, line 197, in main bootstrap(tmpdir=tmpdir) File &quot;get-pi1p.py&quot;, line 82, in bootstrap import pip._internal File &quot;/tmp/tmp6hUd4Z/pip.zip/pip/_internal/__init__.py&quot;, line 42, in &lt;module&gt; File &quot;/tmp/tmp6hUd4Z/pip.zip/pip/_internal/cmdoptions.py&quot;, line 16, in &lt;module&gt; File &quot;/tmp/tmp6hUd4Z/pip.zip/pip/_internal/index.py&quot;, line 526 官方安装方法：12curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py 通过详细的查看官方说明，发现了这样一行说明 The get-pip.py script is supported on the same python version as pip. For the now unsupported Python 2.6, alternate script is available here. 所以python2.6 下安装pip的正确安装方法是：12curl https://bootstrap.pypa.io/2.6/get-pip.py -o get-pip.pypython get-pip.py 参考： https://pip.pypa.io/en/stable/installing/","tags":[{"name":"python2.6","slug":"python2-6","permalink":"https://zj-john.github.io/tags/python2-6/"},{"name":"pip","slug":"pip","permalink":"https://zj-john.github.io/tags/pip/"}]},{"title":"VPS搭VPN","date":"2018-06-30T03:20:26.000Z","path":"notes/ckbdbl40i001f2ktyclv648h6.html","text":"由于访问外部网站的需求，需要用到VPN，这里记录下通过VPS搭给自己使用的VPN的方法。 VPSVPS（虚拟专用服务器）选择的是搬瓦工。 当前最便宜的是10G VPS（含10GB SSD，512MB RAM，500GB 流量，1x Intel Xeon CPU，支持多设备），一年是19.99刀，折合下来一个月10几块软妹币，还是相当划算的。 购买之后，就可以看到你的虚拟机的IP和端口，然后用户密码会通过你注册的邮箱发给你。此时,你就可以使用xshell等ssh工具远程到主机上操作了。 bandwagon的后台提供资源管理，重装系统，远程shell等基础功能，还有一键OpenVPN等扩展功能。这些扩展功能是变动的，有些VPS提供一键shadowsocks的功能，最新买的看已经没有这一项了。 OpenVPN通过banwagon的一键OpenVPN功能，可以一键安装OpenVPN。OpenVPN支持在windows、mac、Android、IOS上安装，在官网有各个平台需要的下载包。安装很简单，不在赘述。 MAC的安装配置可以参考文档 ShadowSocks由于OpenVPN无法精细化管理（比如VPN只提供给浏览器、NPM使用，而不是全开），我们使用ShadowSocks来帮助实现这一需求。Shadowsocks可以把VPN映射到本地地址和端口，来提供给浏览器、GIT、NPM等使用。 安装server端1pip install shadowsocks client端（含手机端）：https://shadowsocks.org/en/download/clients.html 配置新建文件：/etc/shadowsocks.json12345678&#123; \"server\":\"my_server_ip\", //your hostname or server IP (IPv4/IPv6). \"server_port\":8388, //server port number. \"local_port\":1080, //local port number. \"password\":\"barfoo!\", //a password used to encrypt transfer. \"timeout\":600, //connections timeout in seconds. \"method\":\"aes-256-cfb\" //encryption method&#125; 命令123456#启动ssserver -c /etc/shadowsocks.json -d start# 关闭ssserver -c /etc/shadowsocks.json -d stop# 重启ssserver -c /etc/shadowsocks.json -d restart 参考 搬瓦工官网：https://bandwagonhost.com OpenVPN官网： https://openvpn.net/ MAC安装OpenVPN：https://www.jianshu.com/p/a5fd8dc95ad4 ShadowSocks官网: https://shadowsocks.org/en/index.html ShadowSocks配置： https://segmentfault.com/a/1190000010528542","tags":[{"name":"VPS","slug":"VPS","permalink":"https://zj-john.github.io/tags/VPS/"},{"name":"VPN","slug":"VPN","permalink":"https://zj-john.github.io/tags/VPN/"}]},{"title":"CSS效果","date":"2018-06-12T03:25:42.000Z","path":"notes/ckbdbl40e00172kty5rch9qse.html","text":"虚线效果 代码12345&lt;div style=\" height: 1px; background: linear-gradient(to right, #ff8080, #ff8080 7.5px, transparent 7.5px, transparent); background-size: 10px 100%;\"&gt;&lt;/div&gt; 分析一般想到虚线，可能会考虑hr这个标签,或者是用border的样式，这种方式比较便捷，但是缺点在于无法定制。所以这里介绍的虚线用到的是 linear-gradient 这个css属性，可以定制化虚线的样式。 语法：123&lt;linear-gradient&gt; = linear-gradient([ [ &lt;angle&gt; | to &lt;side-or-corner&gt; ] ,]? &lt;color-stop&gt;[, &lt;color-stop&gt;]+)&lt;side-or-corner&gt; = [left | right] || [top | bottom]&lt;color-stop&gt; = &lt;color&gt; [ &lt;length&gt; | &lt;percentage&gt; ]? 角度： angle：用角度值指定渐变的方向（或角度）。 to left：设置渐变为从右到左。相当于: 270deg to right: 设置渐变从左到右。相当于: 90deg to top：设置渐变从下到上。相当于: 0deg to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。 color-stop: 用于指定渐变的起止颜色： color：指定颜色。 length：用长度值指定起止色位置。不允许负值 percentage：用百分比指定起止色位置。 我们来看background: linear-gradient(to right, #ff8080, #ff8080 7.5px, transparent 7.5px, transparent)这句代码： to right，表示向右渐变， #ff8080, #ff8080 7.5px, 这两个点表示从0画一个7.5px的#ff8080颜色的实线（因为颜色没有改变） #ff8080 7.5px, transparent 7.5px，这一步什么都没有做，因为他们的位置都是7.5px，也就是渐变的长度为0 transparent 7.5px, transparent，是一段透明的距离，从7.5px到10px(background size是10px)，共2.5px 所以以上就画出一个实线(7.5px):透明(2.5px) = 3:1的虚线 箭头效果 代码123456&lt;div style=\" width:10px; height:10px; border:10px solid #FFF; border-left-color:red;\"&gt;&lt;/div&gt; 分析先说盒装模型，每一侧的border是个等边梯形（非长方形）。所以如果border和宽高相同，也就是说整个模型只剩下border（4个三角形）。此时把某三边的border隐藏掉，剩下的模型看起来就是个三角形了，也就是箭头 圆圈效果 代码12345&lt;div style=\"height: 20px; width: 20px; border-radius:10px; border:1px solid;\"&gt;&lt;/div&gt; 分析圆圈的分析比较简单，div的width和height相同，border的radius是width的一半就行。想像一下正方形的内切圆。 参考 虚线Sample：http://www.zhangxinxu.com/study/201710/css3-linear-gradient-dashed-generate.html linear-gradient： https://www.jianshu.com/p/bf862535dd30 http://www.css88.com/book/css/values/image/linear-gradient().htm","tags":[{"name":"css","slug":"css","permalink":"https://zj-john.github.io/tags/css/"}]},{"title":"Datatable源变化后rerender","date":"2018-06-11T03:23:39.000Z","path":"tips/ckbdbl45o00bk2ktyh94qv0ze.html","text":"datatable的值还需要异步的数据来补充的话，要把异步的数据也插入到表格中去。一种方式是destory掉，然后在datatable()，这种方式会产生闪烁的效果。 更好的方式如下,利用drawCallback函数，再拿到新数据绘制到表格中。 例子中的方式是利用click事件来触发draw()，如果是异步数据重绘的话，需要设定一个标志位，在异步数据拿到之后改变这个标志位，使重绘停止。否则会不断重绘，造成死循环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var dataSet = [ [\"yes\", \"Jose M. Smith\"], [\"no\", \"Sidney D. McRae\"], [\"yes\", \"Christina D. Turner\"], [\"no\", \"Mary L. Engen\"], [\"no\", \"Charles G. Campbell\"], [\"no\", \"Alan J. Harris\"], [\"no\", \"Kelly E. Litton\"], [\"no\", \"Scott T. Cannon\"], [\"no\", \"Judith C. Cockrell\"], [\"yes\", \"Raymond C. Gordon\"]]$(\"#js_table\").DataTable( &#123; \"data\": dataSet, \"paging\": true, \"stateSave\": true, \"stateSaveParams\": function (settings, data) &#123; delete data.search; &#125;, \"searching\" : true, \"lengthMenu\": [ [25, 50, 100, -1], [25, 50, 100, \"All\"] ], \"autoWidth\": true, \"order\": [[ 0, 'asc' ],[ 1, \"asc\" ]], \"drawCallback\": function (settings) &#123; var api = new $.fn.dataTable.Api(settings); api.rows().every(function () &#123; var rowApi = this; $('.js_assign_element', this.node()).off(\"click\").click(function () &#123; var rowData = rowApi.data(); if (rowData[0] == \"yes\") &#123; rowData[0] = \"no\"; &#125; else &#123; rowData[0] = \"yes\"; &#125; rowApi.invalidate().draw(); &#125;); &#125;); &#125;, \"columns\": [ &#123;\"orderSequence\": [ \"asc\",\"desc\" ], \"render\": function (data, type, row )&#123; if ( type === 'display') &#123; if (data === \"yes\") &#123; return '&lt;div class=\"js_assign_element element_assign __assigned\"&gt;&lt;/div&gt;' &#125; else &#123; return '&lt;div class=\"js_assign_element element_assign\"&gt;&lt;/div&gt;' &#125; &#125; else &#123; if (data === \"yes\") &#123; return \"assigned\" &#125; else &#123; return \"not assigned\" &#125; &#125; &#125;&#125;, &#123;\"orderSequence\": [ \"asc\",\"desc\" ]&#125; ]&#125;) 参考： https://codepen.io/anon/pen/NXNEMJ?editors=0010","tags":[{"name":"datatable","slug":"datatable","permalink":"https://zj-john.github.io/tags/datatable/"},{"name":"draw","slug":"draw","permalink":"https://zj-john.github.io/tags/draw/"}]},{"title":"绘画板","date":"2018-05-24T09:13:53.000Z","path":"projects/ckbdbl46g00cw2kty1hzxmwd2.html","text":"最近看canvas，拿这个项目作为一个验收结果。 功能：选择主题（漫画、自定义），选择模块，在画板上布局编辑，最后保存为一张图片 工具：canvas, fabric, ant-mobile 难度等级: ★★ 项目地址: https://github.com/zj-john/drawingBoard 先上最终工具的地址,有兴趣的可以操作下。 由于是mobile框架，可以在浏览器手机端模式下浏览或在手机浏览器打开操作 fabric特性fabric是个强大而简单的H5 canvas库，对canvas的基础功能做了很多封装，并提供一些优化的操作，包括不限于： 模块：包括矩形、文字、Path、Image、Group（组合）、IText（可编辑）、Free Drawing等多种模块 属性：每个模块可以独立设置Event，可以独立设置是否可以拖动、自定义样式等 动画 图片Filter svg处理 使用node下使用：文档 我demo中用的是fabric-webpack12345import &#123;fabric&#125; from 'fabric-webpack';let canvas = new fabric.Canvas(domId, &#123; backgroundColor: \"white\"&#125;); 问题IText中PC Chrome浏览器中无法输入中文，手机端测试可以，issue上看和键盘编码有关 canvas保存图片a标签1234let a = document.createElement('a');a.href = canvas.toDataURL('image/png');a.download = \"download.png\";a.click(); FileSaver12345const FileSaver = require('file-saver');canvas.getElement().toBlob(function(blob) &#123; FileSaver.saveAs(blob, \"download.png\");&#125;); 问题PC浏览器中，可以保存下载，手机端不行。于是采用了文档中的方法，生成图片，不直接下载。 可替换图片的Img组件代码12345678910111213141516171819202122232425262728293031323334353637import defaultPic from './default_pic.png';const global = this;fabric.Image.fromURL(defaultPic, function(oImg) &#123; let canvas = global.canvas, height = canvas.height, width = canvas.width; const options = &#123; 'left': 0.5*width-50, 'top': 0.5*height-50, 'width':100, 'height':100 &#125; oImg.set(options); // 长按 oImg.on('mouseup', function() &#123; let fileInput = document.createElement(\"input\"); fileInput.type = \"file\", fileInput.accept =\"image/gif,image/jpeg,image/jpg,image/png\"; fileInput.addEventListener(\"change\", function(event) &#123; let file = event.currentTarget.files[0], reader = new FileReader(); reader.onload = function (evt) &#123; let img = document.createElement(\"img\"); img.src = evt.target.result; img.onload = function() &#123; oImg.setElement(img); oImg.set(options); canvas.renderAll(); &#125; &#125;; reader.readAsDataURL(file); &#125;, false) fileInput.click(); &#125;) canvas.add(oImg);&#125;); 问题image上longpress、mousedblclick等事件未生效 参考文档 https://juejin.im/post/5a17c5e26fb9a04527254689","tags":[{"name":"canvas","slug":"canvas","permalink":"https://zj-john.github.io/tags/canvas/"},{"name":"js","slug":"js","permalink":"https://zj-john.github.io/tags/js/"},{"name":"fabric","slug":"fabric","permalink":"https://zj-john.github.io/tags/fabric/"},{"name":"ant-mobile","slug":"ant-mobile","permalink":"https://zj-john.github.io/tags/ant-mobile/"}]},{"title":"JS 物理引擎","date":"2018-05-23T07:32:14.000Z","path":"tips/ckbdbl45k00bb2ktyepc7c96n.html","text":"最近在做一个canvas的东西，看的过程中，顺便了解下JS的物理引擎。微信上目前有很多很火的小程序，跳格子、弹球等，都是一些物理学游戏，其中很重要的部分是如何模拟一个真实的物理世界，这就用到了物理引擎。 我最早知道的物理引擎是box2dJS，看过demo，但一直没有了解过。 现在重拾看看，先记录下以下资料。 按照Stack Overflow上推荐的答案(截止2017.04)，目前有如下引擎库。 基于Box2D： kripken/box2d.js planck.js Box2DJS box2dweb 不基于Box2D: Matter.js P2.js 比较推荐的是kripken/box2d.js和planck.js，box2dweb优于Box2DJS。 kripken/box2d.js基于Emscripten，虽然效率和性能提高，但是开发的成本提高。 参考文档： https://stackoverflow.com/questions/7628078/which-box2d-javascript-library-should-i-use","tags":[{"name":"box2d","slug":"box2d","permalink":"https://zj-john.github.io/tags/box2d/"}]},{"title":"Failed to execute removeChild on Node（React）","date":"2018-05-22T07:32:14.000Z","path":"tips/ckbdbl45i00b72ktykshrpv0w.html","text":"开发时遇到报错：React: Failed to execute removeChild on Node。 如下，更改isActive时会报错：1234567891011121314//App.jsrender() &#123; &#123; this.state.isActive? &lt;Test /&gt;:null &#125;&#125;// Test.jsrender() &#123; &lt;canvas /&gt;&#125; 解决方案：更改为如下1234567// Test.jsrender() &#123; &lt;div&gt; &lt;canvas /&gt; &lt;/div&gt;&#125;","tags":[{"name":"React","slug":"React","permalink":"https://zj-john.github.io/tags/React/"}]},{"title":"vagrant up报错：unable to mount VirtualBox shared folders","date":"2018-05-03T06:16:42.000Z","path":"tips/ckbdbl45900at2kty6wb2ekul.html","text":"vagrant up报以下错误：123456789101112Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem &quot;vboxsf&quot; is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=1000,gid=1000 vagrant /vagrantThe error output from the command was:/sbin/mount.vboxsf: mounting failed with the error: No such device 参考文档 看到有2个方法： 1.12vagrant plugin install vagrant-vbguestvagrant vbguest 2.12vagrant plugin install vagrant-winnfsdvagrant plugin install vagrant-vbguest","tags":[{"name":"error","slug":"error","permalink":"https://zj-john.github.io/tags/error/"},{"name":"vagrant","slug":"vagrant","permalink":"https://zj-john.github.io/tags/vagrant/"}]},{"title":"windows 为CMD设置代理","date":"2018-05-02T06:36:55.000Z","path":"tips/ckbdbl45g00b42kty02lmiv1m.html","text":"在windows CMD中执行一些命令，由于是国内环境，很多地址可能访问不到(比如下载vagrant的插件)，我们需要配置代理。 设置方法如下：12set http_proxy=http://user:password@host:portset https_proxy=%http_proxy% 通过set命令查看已有设置。1set | find &quot;proxy&quot; 设置后的代理只在本CMD中有效，其它cmd中查看set是没有prox的设置的。 参考文档： https://blog.csdn.net/rznice/article/details/50705451 https://stackoverflow.com/questions/19872591/how-to-use-vagrant-in-a-proxy-environment","tags":[{"name":"proxy","slug":"proxy","permalink":"https://zj-john.github.io/tags/proxy/"},{"name":"cmd","slug":"cmd","permalink":"https://zj-john.github.io/tags/cmd/"}]},{"title":"以太坊私链集群(未完)","date":"2018-04-06T02:57:34.000Z","path":"projects/ckbdbl46i00d02ktylzuvo9o8.html","text":"在公司内网搭建以太坊私链服务 编码之前目标在公司内网环境，搭建以太坊私链集群。需要提供以下功能： 支持集群自动扩容 每个节点配备健康监测，支持节点的热插拔 集群对外提供API，包括写入、读取以太链信息等 支持部署智能合约 分析自动扩容自动扩容的难点在于bootnode的指定。以太坊P2P新节点的发现，会通过一个bootnode（启动节点、中介节点）作为中介。也就是说，新节点需要显示指定bootnodes参数，选定中介节点，连接到中介节点后，会通过中介节点广播给整个P2P网络，同步区块数据。 由于需要支持热插拔，所以bootnode不能写死，需要从存活的节点中选择。此时需要当前存活节点的nodeInfo信息列表，项目中使用mongo来记录和更新存活节点的数据。 健康监测这部分由于监测网络中节点的健康状态。如何判断一个节点是否存活： 执行api命令，验证结果例如获取eth.accounts返回的结果，与Mongo中存储的某条节点的account数据对比，一直则监测通过。在我们网络中，每个节点的账户（矿工）只有一个（后续介绍）。 通过datadir目录下的geth.ipc文件在geth运行时，会在数据目录下生成geth.ipc文件。节点关闭则文件删除。 对外API这里的提供的API是对以太坊web3Api的封装。项目中以太链提供的基础功能是存储，外部调用不需要了解web3 API的功能，所以封装一层，提供存储和访问支持。 智能合约对于高级用户，可以定制智能合约来使用 依赖goweb3mongo编码后续","tags":[{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"private chain","slug":"private-chain","permalink":"https://zj-john.github.io/tags/private-chain/"},{"name":"cluster","slug":"cluster","permalink":"https://zj-john.github.io/tags/cluster/"}]},{"title":"geth console命令","date":"2018-04-05T04:46:45.000Z","path":"notes/ckbdbl41q003p2ktyfpj8uj0d.html","text":"geth console命令 描述Geth控制台是JavaScript运行时环境的交互式shell，它暴露了一个节点管理界面以及Ðapp JavaScript API。请参阅 https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console。 这大概是用的最多的geth命令了 基本用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120USAGE: geth console [command options] [arguments...]ETHEREUM OPTIONS: --identity value 自定义节点名称 --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录 --keystore 密钥库目录 (默认同datadir) --nousb 禁用监视和管理USB硬件钱包 --syncmode &quot;fast&quot; 区块链同步模式 (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)，参数必填，没有默认值 --gcmode value 区块链垃圾收集模式 (&quot;full&quot;, &quot;archive&quot;) (默认: &quot;full&quot;) --lightserv value 允许服务LES请求的最大时间百分比 (0-90) (默认: 0) --lightpeers value LES客户端的最大数量 (默认: 100) --lightkdf 以减少KDF（秘钥生成函数）的强度为代价减少生成秘钥时RAM和CPU的使用量 --testnet Ropsten网络：预先配置的POW(proof-of-work)测试网络 --rinkeby Rinkeby网络：预先配置的POA(proof-of-authority)测试网络 --networkid value 网络标识符 (整数, 1=Frontier(以太坊线上网络：主网), 2=Morden (已废弃), 3=Ropsten, 4=Rinkeby) (默认: 1) --ethstats value 报告ethstats服务的URL (nodename:secret@host:port) --config value TOML配置文件DEVELOPER CHAIN OPTIONS: --dev dev模式下包括一个短连的（Ephemeral）POA共识网络，一个预先分派的有资金的账户，且已自动开启挖矿。 --dev.period value 在开发者模式下挖矿周期（生成区块的周期）（0 =仅在交易使用）（默认值：0）ETHASH OPTIONS（ETHASH算法）: --ethash.cachedir 用于存储ethash验证缓存的目录 (默认同datadir) --ethash.cachesinmem value 保留在内存中的最新ethash缓存数量（每个16MB） (默认: 2) --ethash.cachesondisk value 保留在磁盘上的最新ethash缓存数量（每个16MB） (默认: 3) --ethash.dagdir &quot;/root/.ethash&quot; 用于存储ethash mining DAGs的目录 (默认同datadir) --ethash.dagsinmem value 保留在内存中的最新ethash mining DAGs的个数 (每个1GB+) (默认: 1) --ethash.dagsondisk value 保留在磁盘中的最新ethash mining DAGs的个数 (每个1GB+) (默认: 2)TRANSACTION POOL OPTIONS（交易池选项）: --txpool.nolocals 本地提交交易禁用价格豁免 --txpool.journal value 用于本地事务的磁盘日志以保持节点重新启动 Disk journal for local transaction to survive node restarts (默认: &quot;transactions.rlp&quot;) --txpool.rejournal value 重新生成本地事务日志的时间间隔 (默认: 1h0m0s) --txpool.pricelimit value 加入交易池的最小的gas价格限制 (默认: 1) --txpool.pricebump value 价格颠簸百分比来替代已经存在的交易 Price bump percentage to replace an already existing transaction (默认: 10) --txpool.accountslots value 每个帐户保证的可执行交易时间的最小数量 Minimum number of executable transaction slots guaranteed per account (默认: 16) --txpool.globalslots value 所有帐户的可执行事务处理槽的最大数量 Maximum number of executable transaction slots for all accounts (默认: 4096) --txpool.accountqueue value 每个帐户允许的最大非可执行事务处理槽数量 Maximum number of non-executable transaction slots permitted per account (默认: 64) --txpool.globalqueue value 所有帐户的最大非可执行事务处理槽数 Maximum number of non-executable transaction slots for all accounts (默认: 1024) --txpool.lifetime value 不可执行事务排队的最长时间 Maximum amount of time non-executable transaction are queued (默认: 3h0m0s)PERFORMANCE TUNING OPTIONS: --cache value 分配给内部缓存使用的内存（MB） (默认: 1024) --cache.database value 用于数据库io的缓存内存容量的百分比 Percentage of cache memory allowance to use for database io (默认: 75) --cache.gc value 缓存内存允许用于修剪的百分比 Percentage of cache memory allowance to use for trie pruning (默认: 25) --trie-cache-gens value 保存在内存中的trie node的数量 (默认: 120)ACCOUNT OPTIONS: --unlock value 解锁以逗号分隔的帐户列表 --password value 用于非交互式密码输入的密码文件API AND CONSOLE OPTIONS: --rpccorsdomain value 以逗号分隔的接受跨源请求的域名列表（浏览器强制执行） --rpcvhosts value 以逗号分隔的用于接受请求的虚拟主机名列表（服务器强制执行）。 接入&apos;*&apos;通配符. (默认: &quot;localhost&quot;) --rpc 启用HTTP-RPC服务器 --rpcaddr value HTTP-RPC服务器监听地址 (默认: &quot;localhost&quot;) --rpcport value HTTP-RPC服务器监听端口 (默认: 8545) --rpcapi value 基于HTTP-RPC接口提供的API --ws 启用WS-RPC服务器 --wsaddr value WS-RPC服务器监听地址 (默认: &quot;localhost&quot;) --wsport value WS-RPC服务器监听端口 (默认: 8546) --wsapi value 通过WS-RPC接口提供的API --wsorigins value 允许接受websockets请求的源 --ipcdisable 禁用IPC-RPC服务器 --ipcpath 数据区中IPC套接字/管道的文件名（显式路径将其转义） Filename for IPC socket/pipe within the datadir (explicit paths escape it) --jspath loadScript 设置加载JS脚本的根路径 (默认: &quot;.&quot;) --exec value 执行JavaScript语句 --preload value 把以逗号分隔的JavaScript文件列表预加载到控制台中NETWORKING OPTIONS: --bootnodes value 用于P2P发现引导的enode urls(逗号分隔) (set v4+v5 instead for light servers) --bootnodesv4 value 用于P2P V4发现引导的enode urls(逗号分隔) (light server, full nodes) --bootnodesv5 value 用于P2P V5发现引导的enode urls(逗号分隔) (light server, light nodes) --port value 网络监听端口 (默认: 30303) --maxpeers value 最大的网络节点数量(如果设置为0，网络将被禁用) (默认: 25) --maxpendpeers value 最大尝试连接的数量 (如果设置为0，则将使用默认值) (默认: 0) --nat value NAT端口映射机制（any | none | upnp | pmp | extip：&lt;IP&gt;） (默认: &quot;any&quot;) --nodiscover 禁用节点发现机制 (手动添加节点) --v5disc 启用实验性RLPx V5 Enables the experimental RLPx V5 (Topic Discovery) mechanism --netrestrict value 将网络通信限制在给定的IP网络上 Restricts network communication to the given IP networks (CIDR masks) --nodekey value P2P节点密钥文件 --nodekeyhex value 十六进制的P2P节点密钥（用于测试）MINER OPTIONS: --etherbase value 地块挖掘奖励的公开地址 Public address for block mining rewards (默认 = first account created) (默认: &quot;0&quot;) --gasprice &quot;18000000000&quot; 最小的天然气价格，以接受采矿交易 Minimal gas price to accept for mining a transactions --minerthreads value 用于挖矿的CPU线程数 (默认: 4) --mine 启用挖矿 --targetgaslimit value 目标气体极限设置了要开采的块的人造目标气体地板 Target gas limit sets the artificial target gas floor for the blocks to mine (默认: 4712388) --extradata value 阻止矿工设置的额外数据 Block extra data set by the miner (默认 = client version)GAS PRICE ORACLE OPTIONS: --gpoblocks value 检查天然气价格的最近区块数量 Number of recent blocks to check for gas prices (默认: 20) --gpopercentile value 建议的天然气价格是一组最近交易天然气价格的给定百分位数 Suggested gas price is the given percentile of a set of recent transaction gas prices (默认: 60)VIRTUAL MACHINE OPTIONS: --vmdebug 记录对虚拟机和合同调试有用的信息 Record information useful for VM and contract debuggingLOGGING AND DEBUGGING OPTIONS: --metrics 启用指标收集和报告 Enable metrics collection and reporting --fakepow 禁用POW验证 Disables proof-of-work verification --nocompaction 导入后禁用数据库压缩 Disables db compaction after importWHISPER (EXPERIMENTAL) OPTIONS: --shh 启用耳语 Enable Whisper --shh.maxmessagesize value 接受最大邮件大小 Max message size accepted (默认: 1048576) --shh.pow value Minimum POW accepted (默认: 0.2)DEPRECATED OPTIONS（弃用的选项）: --fast Enable fast syncing through state downloads --light Enable light client modeMISC OPTIONS: --dashboard 启用仪表板 --dashboard.addr value 仪表板监听地址 (默认: &quot;localhost&quot;) --dashboard.host value 仪表板监听端口 (默认: 8080) --dashboard.refresh value 仪表板指标收集刷新频率 (默认: 5s) --dashboard.assets value 开发人员标志从本地文件系统提供仪表板 Developer flag to serve the dashboard from the local file system 示例以太坊选项（ETHEREUM OPTIONS）identity1&gt; geth console --identity &quot;myTestChain&quot; 其它选项相同，添加了indentity属性，geth启动后的区别如下：12345//不加identityinstance: Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4// identityinstance: Geth/myTestChain/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4 nousb这部分不太了解。猜测USB钱包是类似于U盾一样的东西。 syncmode3种同步模式，参考Question fast：快速模式，仅下载所有区块的状态信息，状态下载到当前块之前不处理任何事务。状态下载完成后，下载同full模式。一般这个选项配合cache（设置为1G或2G）一起使用，加快下载 light： 轻客户端模式，仅获取当前状态 full(默认)：完整模式，下载所有区块数据信息，从创世块开始逐一校验下载 参考文献 https://blog.csdn.net/wo541075754/article/details/78360560 https://juejin.im/entry/5a1e174ff265da43322753a6","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"geth","slug":"geth","permalink":"https://zj-john.github.io/tags/geth/"}]},{"title":"geth bug命令","date":"2018-04-04T04:00:53.000Z","path":"notes/ckbdbl41m003f2ktye66fgwm0.html","text":"geth bug命令 这个命令功能很简单，可以快捷的向go-ethereum仓库提交报错。 使用方式：终端输入以下命令，然后会自动打开一个浏览器窗口，跳转到go-ethereum的提issue的地址。1&gt; geth bug 提交issue页面上会默认带上你的环境信息，如下： 123456789101112131415161718Please answer these questions before submitting your issue. Thanks!#### What did you do?#### What did you expect to see?#### What did you see instead?#### System detailsVersion: 1.8.2-stableGo Version: go1.9.4OS: linuxuname -sr: Linux 4.13.0-38-genericDistributor ID: UbuntuDescription: Ubuntu 16.04.3 LTSRelease: 16.04Codename: xenial","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"geth","slug":"geth","permalink":"https://zj-john.github.io/tags/geth/"},{"name":"bug","slug":"bug","permalink":"https://zj-john.github.io/tags/bug/"}]},{"title":"geth attach命令","date":"2018-04-03T10:49:02.000Z","path":"notes/ckbdbl41w003x2ktyj9x427ov.html","text":"geth attach命令 描述该命令允许在正在运行的geth节点上打开另一个控制台。 基本用法12345678910USAGE: geth attach [command options] [arguments...]ETHEREUM OPTIONS: --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录API AND CONSOLE OPTIONS: --jspath loadScript 设置加载JS脚本的根路径(默认是&quot;.&quot;，为console所在的当前目录) --exec value 执行JavaScript语句 --preload value 把以逗号分隔的JavaScript文件列表预加载到控制台中 示例新开一个geth控制台这个命令主要是另开一个geth控制台。 例如我开了一个geth：123456789101112131415161718192021222324252627&gt; ./start.shINFO [04-09|05:07:58] Maximum peer count ETH=25 LES=0 total=25INFO [04-09|05:07:58] Starting peer-to-peer node instance=Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4INFO [04-09|05:07:58] Allocated cache and file handles database=/root/Documents/ethereum/data/geth/chaindata cache=768 handles=512INFO [04-09|05:07:59] Initialised chain configuration config=&quot;&#123;ChainID: 1106 Homestead: 0 DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown&#125;&quot;INFO [04-09|05:07:59] Disk storage enabled for ethash caches dir=/root/Documents/ethereum/data/geth/ethash count=3INFO [04-09|05:07:59] Disk storage enabled for ethash DAGs dir=/root/.ethash count=2INFO [04-09|05:07:59] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=100000INFO [04-09|05:07:59] Loaded most recent local header number=14 hash=86cf03…65a6b9 td=1967872INFO [04-09|05:07:59] Loaded most recent local full block number=14 hash=86cf03…65a6b9 td=1967872INFO [04-09|05:07:59] Loaded most recent local fast block number=14 hash=86cf03…65a6b9 td=1967872INFO [04-09|05:07:59] Loaded local transaction journal transactions=0 dropped=0INFO [04-09|05:07:59] Regenerated local transaction journal transactions=0 accounts=0WARN [04-09|05:07:59] Blockchain not empty, fast sync disabledINFO [04-09|05:07:59] Starting P2P networkingINFO [04-09|05:08:01] UDP listener up self=enode://09200d47050993bac053ec038ab90046d8ce5e6c82005f4f1c2a34704f523d7545444d6f3c921f40545fe96b6b56b0b12019cd444ec072493f6db9f77025e590@[::]:30303INFO [04-09|05:08:01] HTTP endpoint opened url=http://127.0.0.1:8545 cors=* vhosts=localhostINFO [04-09|05:08:01] RLPx listener up self=enode://09200d47050993bac053ec038ab90046d8ce5e6c82005f4f1c2a34704f523d7545444d6f3c921f40545fe96b6b56b0b12019cd444ec072493f6db9f77025e590@[::]:30303INFO [04-09|05:08:01] IPC endpoint opened url=/root/Documents/ethereum/data/geth.ipcWelcome to the Geth JavaScript console!instance: Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4INFO [04-09|05:08:01] Etherbase automatically configured address=0x93a44e1E0aCeb6a68ED39018d48A359b0beB8Eb5coinbase: 0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5at block: 14 (Fri, 30 Mar 2018 01:22:07 PDT) datadir: /root/Documents/ethereum/data modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 start.sh的内容123456#!/bin/bashgeth --rpc \\ --rpccorsdomain \"*\" \\ --datadir \"/root/Documents/ethereum/data\" \\ --networkid 100000 \\ console 注意以下内容，后面新开geth控制台时会遇到123INFO [04-09|05:08:01] HTTP endpoint opened url=http://127.0.0.1:8545 cors=* vhosts=localhost...INFO [04-09|05:08:01] IPC endpoint opened url=/root/Documents/ethereum/data/geth.ipc 如果这个时候我再开一个终端，执行同样的命令,会报以下错误：123root@ubuntu:~/Documents# ./start.shINFO [04-09|05:09:29] Maximum peer count ETH=25 LES=0 total=25Fatal: Error starting protocol stack: datadir already used by another process 这个时候我们可以执行以下代码，就会新打开一个geth控制台12345678910&gt; geth attach --datadir &quot;/root/Documents/ethereum/data/&quot;Welcome to the Geth JavaScript console!instance: Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4coinbase: 0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5at block: 14 (Fri, 30 Mar 2018 01:22:07 PDT) datadir: /root/Documents/ethereum/data modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 还可以使用以下两个命令，也是同样的效果,下面的地址来自于第一个geth启动时的数据。123geth attach ipc://root/Documents/ethereum/data/geth.ipc//orgeth attach http://127.0.0.1:8545 执行JS我们在这个目录下新建一个test.js文件（/root/Documents/test.js），内容如下：1234var aForTest = 5;var bForTest = aForTest + 1;console.log(aForTest, bForTest);console.log(eth.accounts); 执行以下命令，得到结果5, 6和accounts的值，说明既可以执行原生JS命令，又可以结合geth带的API。1234&gt; geth attach http://127.0.0.1:8545 --jspath &quot;/root/Documents&quot; --exec &quot;loadScript(&apos;test.js&apos;)&quot;5 60x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5,0x68512ebacb81a3274933de1ac02a787927ef76d5,0x0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284b,0xf96a0654d887881cd8cdd5c4320125ae90515a0dtrue","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"geth","slug":"geth","permalink":"https://zj-john.github.io/tags/geth/"},{"name":"attach","slug":"attach","permalink":"https://zj-john.github.io/tags/attach/"}]},{"title":"ethereum 报错汇总","date":"2018-04-02T06:20:51.000Z","path":"notes/ckbdbl41o003j2kty152dlupr.html","text":"ethereum 报错汇总 包含一些自己遇到的和网上收集的报错。 invalid sender undefined这个错误不会导致初始化失败，但是会在以后的转账（eth.sendTransaction），或者部署智能合约的时候产生。解决方法就是在genesis.json文件中，chainId 不能设置为0。 如果你完全按照github上给的官方配置文件，就会产生这个错误 Error: authentication needed: password or unlock undefined解锁账户：personal.unlockAccount(acc0) Error: exceeds block gas limit undefined.The contract code couldn’t be stored, please check your gas amount. undefined把合约中gas改为300000。直接从那个网站的Web3 deploy 复制可能是4300000，然后改成300000，就没问题了。 Fatal: invalid genesis file: missing 0x prefix for hex data这个错误信息意思很明白，就是你的json文件中，对于16进制数据，需要加上0x前缀 Fatal: invalid genesis file: hex string has odd length从v1.6开始，设置的十六进制数值，不能是奇数位， 比如不能是0x0，而应该是0x00。 Fatal: failed to write genesis block: genesis has no chain configuration这个错误信息，就是说，你的json文件中，缺少config部分。看到这个信息，我们不需要把geth退回到v1.5版本，而是需要加上config部分 参考文档： https://blog.csdn.net/loy_184548/article/details/78002015 http://blog.leanote.com/post/chaim/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A0%94%E7%A9%B6%E3%80%90%E5%AE%89%E8%A3%85%E3%80%91 https://github.com/ethereum/go-ethereum/issues/15983","tags":[{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"error","slug":"error","permalink":"https://zj-john.github.io/tags/error/"}]},{"title":"geth account命令","date":"2018-04-02T06:20:02.000Z","path":"notes/ckbdbl41l003c2ktyfgx0eh5x.html","text":"geth account命令 描述功能：管理帐户 列出所有现有帐户 将私钥导入新帐户 创建一个新帐户或更新现有帐户 当系统提示您输入密码时，它支持交互模式。当通过给定的密码文件提供密码时转为非交互模式。非交互模式仅适用于在测试网络或已知安全的环境下的脚本使用。 记得你创建一个新账户时使用的密码（无论是新增账户还是导入账户）。没有它，你无法解锁你的账户。 请注意，不支持以非加密格式导出您的密钥。 密钥存储在 / keystore下。以太坊节点之间，可以通过简单的复制转移整个目录或其中的个人密钥。这种行为是安全的。 定期备份你的钥匙。 基本用法1234567891011USAGE: geth account command [command options] [arguments...]COMMANDS: list 列出所有帐户的简要信息 new 创建一个新账户 update 更新现有账户 import 将私钥导入一个新帐户OPTIONS: --help, -h show help geth account list列出所有帐户的简要信息1234567list [command options] [arguments...]列出所有帐户的简要信息ETHEREUM OPTIONS: --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录 --keystore 密钥库目录 (默认同datadir) 示例：1234&gt; geth account list --datadir &quot;/root/Documents/ethereum/data/&quot;INFO [04-09|00:56:47] Maximum peer count ETH=25 LES=0 total=25Account #0: &#123;93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-28T06-14-55.548233530Z--93a44e1e0aceb6a68ed39018d48a359b0beb8eb5Account #1: &#123;68512ebacb81a3274933de1ac02a787927ef76d5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-29T07-38-29.214491449Z--68512ebacb81a3274933de1ac02a787927ef76d5 geth account new12345678910111213141516171819new [command options] [arguments...] geth account new创建一个新帐户并打印地址。该帐户以加密格式保存，系统会提示您输入密码。您必须记住此密码才能在未来解锁您的帐户。对于非交互式使用，可以使用--password 选项来指定密码请注意，这种方式仅用于测试，因为将密码保存到文件或以任何其他方式公开都是一个坏主意。ETHEREUM OPTIONS: --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录 --keystore 密钥库目录 (默认同datadir) --lightkdf 以减少KDF（秘钥生成函数）的强度为代价减少生成秘钥时RAM和CPU的使用量ACCOUNT OPTIONS: --password value 用于非交互式密码输入时指定密码文件 示例：123456789101112&gt; geth account new --datadir &quot;/root/Documents/ethereum/data/&quot;INFO [04-09|01:15:46] Maximum peer count ETH=25 LES=0 total=25Your new account is locked with a password. Please give a password. Do not forget this password.Passphrase:Repeat passphrase:Address: &#123;0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284b&#125;&gt; geth account list --datadir &quot;/root/Documents/ethereum/data/&quot;INFO [04-09|01:16:09] Maximum peer count ETH=25 LES=0 total=25Account #0: &#123;93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-28T06-14-55.548233530Z--93a44e1e0aceb6a68ed39018d48a359b0beb8eb5Account #1: &#123;68512ebacb81a3274933de1ac02a787927ef76d5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-29T07-38-29.214491449Z--68512ebacb81a3274933de1ac02a787927ef76d5Account #2: &#123;0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284b&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-04-09T08-15-58.475205640Z--0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284b 使用密码文件的方式:/root/Documents/ethereum/pwd 的内容是一个密码的字符串12345678910&gt; geth account new --datadir &quot;/root/Documents/ethereum/data/&quot; --password &quot;/root/Documents/ethereum/pwd&quot;INFO [04-09|01:17:44] Maximum peer count ETH=25 LES=0 total=25Address: &#123;f96a0654d887881cd8cdd5c4320125ae90515a0d&#125;&gt; geth account list --datadir &quot;/root/Documents/ethereum/data/&quot;INFO [04-09|01:17:49] Maximum peer count ETH=25 LES=0 total=25Account #0: &#123;93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-28T06-14-55.548233530Z--93a44e1e0aceb6a68ed39018d48a359b0beb8eb5Account #1: &#123;68512ebacb81a3274933de1ac02a787927ef76d5&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-03-29T07-38-29.214491449Z--68512ebacb81a3274933de1ac02a787927ef76d5Account #2: &#123;0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284b&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-04-09T08-15-58.475205640Z--0ed90cf4d6a37cbcf7c4b9461f151c6f1fe2284bAccount #3: &#123;f96a0654d887881cd8cdd5c4320125ae90515a0d&#125; keystore:///root/Documents/ethereum/data/keystore/UTC--2018-04-09T08-17-44.504001170Z--f96a0654d887881cd8cdd5c4320125ae90515a0d geth account update1234567891011121314151617181920update [command options] [arguments...] geth account update &lt;address&gt;更新现有帐户。要更新的帐户以加密格式保存在最新版本中，系统会提示您输入密码以解锁帐户，然后再输入新密码，就会把新密码更新到存储文件。使用本命令可以用于将老格式的帐户迁移至最新格式或更改帐户的密码。对于非交互式使用，可以使用--password 选项来指定新密码： geth account update [options] &lt;address&gt;由于只能输入一个密码，只能进行格式更新，所以更改密码是唯一的交互方式。ETHEREUM OPTIONS: --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录 --keystore 密钥库目录 (默认同datadir) --lightkdf 以减少KDF（秘钥生成函数）的强度为代价减少生成秘钥时RAM和CPU的使用量 我理解的这里的格式修改，是指随着geth版本升级，对账户的构成方式（生成秘钥的方式等）发生了变化，此时需要适配新版本。把老版本用户进行更新。实际中未遇到此类情况。欢迎理解的童鞋不吝赐教。 示例：12345678&gt; geth account update f96a0654d887881cd8cdd5c4320125ae90515a0d --datadir &quot;/root/Documents/ethereum/data/&quot;INFO [04-09|01:36:07] Maximum peer count ETH=25 LES=0 total=25Unlocking account f96a0654d887881cd8cdd5c4320125ae90515a0d | Attempt 1/3Passphrase:INFO [04-09|01:36:11] Unlocked account address=0xf96a0654D887881cd8cDD5c4320125aE90515A0DPlease give a new password. Do not forget this password.Passphrase:Repeat passphrase: geth account import123456789101112131415161718192021222324import [command options] [arguments...] geth account import &lt;keyfile&gt;从&lt;keyfile&gt;导入一个未加密的私钥并创建一个新帐户。返回新创建用户的地址。这个密钥文件（keyfile）需要包含十六进制格式的未加密私钥。该帐户将以加密格式保存，系统会提示您输入密码。您必须记住此密码才能在未来解锁您的帐户。对于非交互式使用，可以使用--password 选项来指定新密码： geth account import [options] &lt;keyfile&gt;注意：由于您可以直接将加密帐户复制到另一个以太坊实例，因此在节点之间传输帐户时不需要此导入机制。ETHEREUM OPTIONS: --datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录 --keystore 密钥库目录 (默认同datadir) --lightkdf 以减少KDF（秘钥生成函数）的强度为代价减少生成秘钥时RAM和CPU的使用量ACCOUNT OPTIONS: --password value 用于非交互式密码输入时指定密码文件 没有找到合适的key file，也未找到此命令的使用场景。","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"geth","slug":"geth","permalink":"https://zj-john.github.io/tags/geth/"},{"name":"account","slug":"account","permalink":"https://zj-john.github.io/tags/account/"}]},{"title":"geth命令行","date":"2018-04-01T03:44:14.000Z","path":"notes/ckbdbl41x00402kty7q4infka.html","text":"geth命令行 基本用法1geth [options] command [command options] [arguments...] 命令（COMMANDS）12345678910111213141516171819account 管理账户 attach 启动交互式JavaScript环境（连接到node）bug 打开一个窗口（go-ethereum仓库中提交issue的地址），报告geth使用中的bugconsole 启动交互式JavaScript环境copydb 以目标目录的chaindata来创建一个本地链dump Dump a specific block from storagedumpconfig Show configuration valuesexport 把区块链导出到文件中import 从区块链文件中导入init Bootstrap and initialize a new genesis blockjs 执行指定的JavaScript文件license 展示license信息makecache Generate ethash verification cache (for testing)makedag Generate ethash mining DAG (for testing)monitor Monitor and visualize node metricsremovedb Remove blockchain and state databasesversion 打印版本号wallet Manage Ethereum presale walletshelp, h 展示命令列表或者针对某一命令展示帮助信息 以太坊选项（ETHEREUM OPTIONS）1234567891011121314--config value TOML configuration file--datadir &quot;/root/.ethereum&quot; 数据库和密钥库的数据目录--keystore 密钥库目录 (默认同datadir)--nousb Disables monitoring for and managing USB hardware wallets--networkid value Network identifier (integer, 1=Frontier, 2=Morden (disused), 3=Ropsten, 4=Rinkeby) (default: 1)--testnet Ropsten network: pre-configured proof-of-work test network--rinkeby Rinkeby network: pre-configured proof-of-authority test network--syncmode &quot;fast&quot; Blockchain sync mode (&quot;fast&quot;, &quot;full&quot;, or &quot;light&quot;)--gcmode value Blockchain garbage collection mode (&quot;full&quot;, &quot;archive&quot;) (default: &quot;full&quot;)--ethstats value Reporting URL of a ethstats service (nodename:secret@host:port)--identity value Custom node name--lightserv value Maximum percentage of time allowed for serving LES requests (0-90) (default: 0)--lightpeers value Maximum number of LES client peers (default: 100)--lightkdf 以减少KDF（秘钥生成函数）的强度为代价减少生成秘钥时RAM和CPU的使用量 DEVELOPER CHAIN OPTIONS:12* --dev Ephemeral proof-of-authority network with a pre-funded developer account, mining enabled* --dev.period value Block period to use in developer mode (0 = mine only if transaction pending) (default: 0) ETHASH OPTIONS:123456* --ethash.cachedir Directory to store the ethash verification caches (default = inside the datadir)* --ethash.cachesinmem value Number of recent ethash caches to keep in memory (16MB each) (default: 2)* --ethash.cachesondisk value Number of recent ethash caches to keep on disk (16MB each) (default: 3)* --ethash.dagdir &quot;/root/.ethash&quot; Directory to store the ethash mining DAGs (default = inside home folder)* --ethash.dagsinmem value Number of recent ethash mining DAGs to keep in memory (1+GB each) (default: 1)* --ethash.dagsondisk value Number of recent ethash mining DAGs to keep on disk (1+GB each) (default: 2) TRANSACTION POOL OPTIONS:12345678910* --txpool.nolocals Disables price exemptions for locally submitted transactions* --txpool.journal value Disk journal for local transaction to survive node restarts (default: &quot;transactions.rlp&quot;)* --txpool.rejournal value Time interval to regenerate the local transaction journal (default: 1h0m0s)* --txpool.pricelimit value Minimum gas price limit to enforce for acceptance into the pool (default: 1)* --txpool.pricebump value Price bump percentage to replace an already existing transaction (default: 10)* --txpool.accountslots value Minimum number of executable transaction slots guaranteed per account (default: 16)* --txpool.globalslots value Maximum number of executable transaction slots for all accounts (default: 4096)* --txpool.accountqueue value Maximum number of non-executable transaction slots permitted per account (default: 64)* --txpool.globalqueue value Maximum number of non-executable transaction slots for all accounts (default: 1024)* --txpool.lifetime value Maximum amount of time non-executable transaction are queued (default: 3h0m0s) PERFORMANCE TUNING OPTIONS:1234* --cache value Megabytes of memory allocated to internal caching (default: 1024)* --cache.database value Percentage of cache memory allowance to use for database io (default: 75)* --cache.gc value Percentage of cache memory allowance to use for trie pruning (default: 25)* --trie-cache-gens value Number of trie node generations to keep in memory (default: 120) ACCOUNT OPTIONS:12* --unlock value Comma separated list of accounts to unlock* --password value 用于非交互式密码输入时指定密码文件 API AND CONSOLE OPTIONS:12345678910111213141516* --rpc Enable the HTTP-RPC server* --rpcaddr value HTTP-RPC server listening interface (default: &quot;localhost&quot;)* --rpcport value HTTP-RPC server listening port (default: 8545)* --rpcapi value API&apos;s offered over the HTTP-RPC interface* --ws Enable the WS-RPC server* --wsaddr value WS-RPC server listening interface (default: &quot;localhost&quot;)* --wsport value WS-RPC server listening port (default: 8546)* --wsapi value API&apos;s offered over the WS-RPC interface* --wsorigins value Origins from which to accept websockets requests* --ipcdisable Disable the IPC-RPC server* --ipcpath Filename for IPC socket/pipe within the datadir (explicit paths escape it)* --rpccorsdomain value Comma separated list of domains from which to accept cross origin requests (browser enforced)* --rpcvhosts value Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts &apos;*&apos; wildcard. (default: &quot;localhost&quot;)* --jspath loadScript JavaScript root path for loadScript (default: &quot;.&quot;)* --exec value Execute JavaScript statement* --preload value Comma separated list of JavaScript files to preload into the console NETWORKING OPTIONS:123456789101112* --bootnodes value Comma separated enode URLs for P2P discovery bootstrap (set v4+v5 instead for light servers)* --bootnodesv4 value Comma separated enode URLs for P2P v4 discovery bootstrap (light server, full nodes)* --bootnodesv5 value Comma separated enode URLs for P2P v5 discovery bootstrap (light server, light nodes)* --port value Network listening port (default: 30303)* --maxpeers value Maximum number of network peers (network disabled if set to 0) (default: 25)* --maxpendpeers value Maximum number of pending connection attempts (defaults used if set to 0) (default: 0)* --nat value NAT port mapping mechanism (any|none|upnp|pmp|extip:&lt;IP&gt;) (default: &quot;any&quot;)* --nodiscover Disables the peer discovery mechanism (manual peer addition)* --v5disc Enables the experimental RLPx V5 (Topic Discovery) mechanism* --netrestrict value Restricts network communication to the given IP networks (CIDR masks)* --nodekey value P2P node key file* --nodekeyhex value P2P node key as hex (for testing) MINER OPTIONS:123456* --mine Enable mining* --minerthreads value Number of CPU threads to use for mining (default: 4)* --etherbase value Public address for block mining rewards (default = first account created) (default: &quot;0&quot;)* --targetgaslimit value Target gas limit sets the artificial target gas floor for the blocks to mine (default: 4712388)* --gasprice &quot;18000000000&quot; Minimal gas price to accept for mining a transactions* --extradata value Block extra data set by the miner (default = client version) GAS PRICE ORACLE OPTIONS:12* --gpoblocks value Number of recent blocks to check for gas prices (default: 20)* --gpopercentile value Suggested gas price is the given percentile of a set of recent transaction gas prices (default: 60) VIRTUAL MACHINE OPTIONS:1* --vmdebug Record information useful for VM and contract debugging LOGGING AND DEBUGGING OPTIONS:1234567891011121314* --metrics Enable metrics collection and reporting* --fakepow Disables proof-of-work verification* --nocompaction Disables db compaction after import* --verbosity value Logging verbosity: 0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (default: 3)* --vmodule value Per-module verbosity: comma-separated list of &lt;pattern&gt;=&lt;level&gt; (e.g. eth/*=5,p2p=4)* --backtrace value Request a stack trace at a specific logging statement (e.g. &quot;block.go:271&quot;)* --debug Prepends log messages with call-site location (file and line number)* --pprof Enable the pprof HTTP server* --pprofaddr value pprof HTTP server listening interface (default: &quot;127.0.0.1&quot;)* --pprofport value pprof HTTP server listening port (default: 6060)* --memprofilerate value Turn on memory profiling with the given rate (default: 524288)* --blockprofilerate value Turn on block profiling with the given rate (default: 0)* --cpuprofile value Write CPU profile to the given file* --trace value Write execution trace to the given file WHISPER (EXPERIMENTAL) OPTIONS:123* --shh Enable Whisper* --shh.maxmessagesize value Max message size accepted (default: 1048576)* --shh.pow value Minimum POW accepted (default: 0.2) DEPRECATED OPTIONS:12* --fast Enable fast syncing through state downloads* --light Enable light client mode MISC OPTIONS:1* --help, -h show help","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"geth","slug":"geth","permalink":"https://zj-john.github.io/tags/geth/"}]},{"title":"ethereum 智能合约","date":"2018-03-30T06:20:51.000Z","path":"notes/ckbdbl41h00362kty88oe94jz.html","text":"blockchain_smart_contract ethereum smart contract的编写 智能合约讲解Demo来自solidity的官网，制定了一个带有委托功能的投票（选举）智能合约。 逐行讲解代码，以便大家了解solidity语法和合约功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 当前使用的solidity的版本号 ^符号的意义和npm版本中相同pragma solidity ^0.4.16;/// 带有委托功能的投票契约contract Ballot &#123; // 声明了一个struct类型：Voter，用来代表每一个单独的voter。可以理解为抽象了一个voter的类。下文简称之为对象。 struct Voter &#123; // 权重，由于可以委托，权重可能大于1 uint weight; // 标识是否有投票权，如果为true，标识已经投过票，不能再投 bool voted; // 被委托人的地址 address delegate; // 支持的（已投票的）提议的序号 uint vote; &#125; // 声明一个代表提议案的struct类型 struct Proposal &#123; // 提议案的name，最大32bytes bytes32 name; // 获得的投票数 uint voteCount; &#125; // 召集这次投票的主人，可以决定哪些人有投票权。public类型，表示可以address可以被外部知晓，这里称之为主席 address public chairperson; // 一个叫做voters的public变量，为每一个address对应生成一个Voter对象 mapping(address =&gt; Voter) public voters; // 一个储存Proposal的public对象的数组 Proposal[] public proposals; // 发起一个投票，从若干个proposalNames（Array类型）中选择你支持的那个，public的，可以被外部查看到 function Ballot(bytes32[] proposalNames) public &#123; // 调用这个方法的人就是主席，把他的公钥赋给chairperson chairperson = msg.sender; // 他自己也有一次投票权，给他的voter的权重加1 voters[chairperson].weight = 1; // 为每一个proposalNames下的元素生成对应的proposal对象，添加到proposals对象中 for (uint i = 0; i &lt; proposalNames.length; i++) &#123; proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // 主席分发投票权 function giveRightToVote(address voter) public &#123; // 如果require中的参数等于false，将直接终止运行,并回退所有状态的改变和以太币的交易。所以要在一个函数未被正确调用时使用这个方法 // 另外，这个回退操作也会消耗gas（后续的版本打算修复这一情况） require( (msg.sender == chairperson) &amp;&amp; !voters[voter].voted &amp;&amp; (voters[voter].weight == 0) ); voters[voter].weight = 1; &#125; // 把投票权委托给to的那个人（公钥） function delegate(address to) public &#123; // storage类型的对象将永远存在区块链上，前提是没有回退 Voter storage sender = voters[msg.sender]; require(!sender.voted); // 自己给自己授权不被允许 require(to != msg.sender); // 一般来说，循环是很危险的，如果运行时间过长，很有可能导致gas消耗完毕，使合约卡主。 // 如果被委托人也有他自己的委托人，就向上查找到最终的委托人 // address(0)等于\"0x0\",一个未被使用的地址 while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // 避免死循环 require(to != msg.sender); &#125; sender.voted = true; sender.delegate = to; Voter storage delegate_ = voters[to]; if (delegate_.voted) &#123; // 如果被委托人已经投过票，他投的票上加上委托人拥有的权重 proposals[delegate_.vote].voteCount += sender.weight; &#125; else &#123; // 如果还没投票，把他的weight提高 delegate_.weight += sender.weight; &#125; &#125; // 行使投票权 function vote(uint proposal) public &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted); sender.voted = true; sender.vote = proposal; // 如果proposal不在数组中，会自动抛异常然后回退 proposals[proposal].voteCount += sender.weight; &#125; // 统计票数，返回获胜者的序号 // 函数加view，表示这个函数中承诺不更改状态 function winningProposal() public view returns (uint winningProposal_) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal_ = p; &#125; &#125; &#125; // 获取获胜提议的name function winnerName() public view returns (bytes32 winnerName_) &#123; winnerName_ = proposals[winningProposal()].name; &#125;&#125; 从最简单开始合约地址 12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData = x; &#125; function get() public constant returns (uint) &#123; return storedData; &#125;&#125; 打开合约在线编译地址,把上面的合约复制进去，点击右侧的“Start to compile” 如果所示，编译成功。 我们点击Detail，打开编译的详情。我们需要的部分如下： 我们copy WEB3DEPLOY中的内容(2个JS变量)，粘贴在geth的命令行中。123456789101112var simplestorageContract = web3.eth.contract([&#123;\"constant\":false,\"inputs\":[&#123;\"name\":\"x\",\"type\":\"uint256\"&#125;],\"name\":\"set\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[],\"name\":\"get\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"uint256\"&#125;],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"&#125;]);var simplestorage = simplestorageContract.new( &#123; from: web3.eth.accounts[0], data: '0x6060604052341561000f57600080fd5b60d38061001d6000396000f3006060604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c14606e575b600080fd5b3415605857600080fd5b606c60048080359060200190919050506094565b005b3415607857600080fd5b607e609e565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a72305820d260b3fab2aaf9b7911618aac87abe44b9a999f906eeac6e177fd8df4ba06a3d0029', gas: '4700000' &#125;, function (e, contract)&#123; console.log(e, contract); if (typeof contract.address !== 'undefined') &#123; console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash); &#125; &#125;) 粘贴后提示先解锁账户，我们解锁账户0。1personal.unlockAccount(acc0) 之后又有报错：Error: exceeds block gas limit undefined,我们采用文档的说法把gas:’4700000’改为gas:’3000000’ 结果如下：1234567891011121314151617181920212223242526INFO [03-30|00:04:41] Submitted contract creation fullhash=0x9b1b99ad03b577839547127304c7e149eaa50d5deb932c5f25b285005ea8edbc contract=0xEd9F8F66fFac7FF317b4f10d48721d36E111a308null [object Object]undefined&gt; simplestorage&#123; abi: [&#123; constant: false, inputs: [&#123;...&#125;], name: &quot;set&quot;, outputs: [], payable: false, stateMutability: &quot;nonpayable&quot;, type: &quot;function&quot; &#125;, &#123; constant: true, inputs: [], name: &quot;get&quot;, outputs: [&#123;...&#125;], payable: false, stateMutability: &quot;view&quot;, type: &quot;function&quot; &#125;], address: undefined, transactionHash: &quot;0x9b1b99ad03b577839547127304c7e149eaa50d5deb932c5f25b285005ea8edbc&quot;&#125; 得到了两个值 交易哈希：fullhash=0x9b1b99ad03b577839547127304c7e149eaa50d5deb932c5f25b285005ea8edbc 合约地址：contract=0xEd9F8F66fFac7FF317b4f10d48721d36E111a308 现在需要挖矿把合约写到区块链中。1234567891011&gt; miner.start(10)INFO [03-30|00:20:40] Updated mining threads threads=10INFO [03-30|00:20:40] Transaction pool price threshold updated price=18000000000nullINFO [03-30|00:20:40] Starting mining operationINFO [03-30|00:20:40] Commit new mining work number=13 txs=1 uncles=0 elapsed=387.643msINFO [03-30|00:25:08] Successfully sealed new block number=13 hash=c1c3b2…d683afINFO [03-30|00:25:08] 🔨 mined potential block number=13 hash=c1c3b2…d683afINFO [03-30|00:25:09] Commit new mining work number=14 txs=0 uncles=0 elapsed=15.773msnull [object Object]Contract mined! address: 0xed9f8f66ffac7ff317b4f10d48721d36e111a308 transactionHash: 0x9b1b99ad03b577839547127304c7e149eaa50d5deb932c5f25b285005ea8edbc 看到Contract mined!，表示合约已经写到链上了。 调用一次合约：1234567&gt; personal.unlockAccount(acc0)Unlock account 0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5Passphrase:true&gt; simplestorage.set(1106,&#123;from:acc0&#125;)INFO [03-30|00:58:34] Submitted transaction fullhash=0x945de4c8424e1c2675d90e1f03f13ad56fd329460d32f988b3cbf0c6ff9270b7 recipient=0xEd9F8F66fFac7FF317b4f10d48721d36E111a308&quot;0x945de4c8424e1c2675d90e1f03f13ad56fd329460d32f988b3cbf0c6ff9270b7&quot; 调用合约中的set方法，把值设置为1106，这笔操作的gas费用从acc0账户出。执行成功后，得到”0x945de4c8424e1c2675d90e1f03f13ad56fd329460d32f988b3cbf0c6ff9270b7”这个hash值，是交易的哈希。 现在要继续挖矿，把这次的结果写入链中，才能看到生效。挖矿成功后：12&gt; simplestorage.get()1106 刚才的数据已经set成功。get属于constant类型，不改变状态，所以不消耗gas。 找回合约如果把geth关掉了，怎么找回合约呢？我们刚才使用的是WEB3DEPLOY中内容，现在使用另一个ABI的值。 123456789101112131415161718192021222324252627282930[ &#123; &quot;constant&quot;: false, &quot;inputs&quot;: [ &#123; &quot;name&quot;: &quot;x&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;name&quot;: &quot;set&quot;, &quot;outputs&quot;: [], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;nonpayable&quot;, &quot;type&quot;: &quot;function&quot; &#125;, &#123; &quot;constant&quot;: true, &quot;inputs&quot;: [], &quot;name&quot;: &quot;get&quot;, &quot;outputs&quot;: [ &#123; &quot;name&quot;: &quot;&quot;, &quot;type&quot;: &quot;uint256&quot; &#125; ], &quot;payable&quot;: false, &quot;stateMutability&quot;: &quot;view&quot;, &quot;type&quot;: &quot;function&quot; &#125;] geth中执行（把回车符去除，否则会截断报错）12var abi = [&#123;&quot;constant&quot;: false,&quot;inputs&quot;: [&#123;&quot;name&quot;: &quot;x&quot;,&quot;type&quot;: &quot;uint256&quot;&#125;],&quot;name&quot;: &quot;set&quot;,&quot;outputs&quot;: [],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;constant&quot;: true,&quot;inputs&quot;: [],&quot;name&quot;: &quot;get&quot;,&quot;outputs&quot;: [ &#123;&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;uint256&quot; &#125;],&quot;payable&quot;: false,&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;];var simplestorage = eth.contract(abi).at(&quot;0xEd9F8F66fFac7FF317b4f10d48721d36E111a308&quot;) 0xEd9F8F66fFac7FF317b4f10d48721d36E111a308是上文记录的合约地址。这样就把合约再次创建出来了。我们之前操作的结果还在。12Contract = eth.contract(abi) //获取合约对象Contract.at(contract.address) //实例化合约 12&gt; simplestorage.get()1106","tags":[{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"smart contract","slug":"smart-contract","permalink":"https://zj-john.github.io/tags/smart-contract/"}]},{"title":"wireshark报错failed to set hardware filter to promiscuous mode","date":"2018-03-29T11:16:23.000Z","path":"tips/ckbdbl45e00b12kty38di44mi.html","text":"wireshark: failed to set hardware filter to promiscuous mode 在客户端抓包排查问题时，发现wireshark不能捕获无线网卡对应的流量信息，报failed to set hardware filter to promiscuous mode 解决方法：在Capture - Options 下把截图中的勾选去掉，即去掉混杂模式即可。 具体原理后续探索。","tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://zj-john.github.io/tags/wireshark/"},{"name":"promiscuous","slug":"promiscuous","permalink":"https://zj-john.github.io/tags/promiscuous/"}]},{"title":"以太坊私链搭建","date":"2018-03-29T04:23:24.000Z","path":"notes/ckbdbl41f00322ktyc1of6eac.html","text":"以太坊私链搭建 安装系统：Ubuntu 环境GO下载go包，安装并加入环境变量12345&gt; curl -O https://storage.googleapis.com/golang/go1.5.1.linux-amd64.tar.gz&gt; tar -C /usr/local -xzf go1.5.1.linux-amd64.tar.gz&gt; mkdir -p ~/go; echo \"export GOPATH=$HOME/go\" &gt;&gt; ~/.bashrc&gt; echo \"export PATH=$PATH:$HOME/go/bin:/usr/local/go/bin\" &gt;&gt; ~/.bashrc&gt; source ~/.bashrc 成功标志：12&gt; go versiongo version go1.5.1 linux/amd64 Ethereum12345&gt; sudo apt-get install software-properties-common&gt; sudo add-apt-repository -y ppa:ethereum/ethereum&gt; sudo add-apt-repository -y ppa:ethereum/ethereum-dev&gt; sudo apt-get update&gt; sudo apt-get install ethereum 成功标志：1234567891011&gt; geth versionGethVersion: 1.8.2-stableGit Commit: b8b9f7f4476a30a0aaf6077daade6ae77f969960Architecture: amd64Protocol Versions: [63 62]Network Id: 1Go Version: go1.9.4Operating System: linuxGOPATH=/root/goGOROOT=/usr/lib/go-1.9 参考文档：区块链技术指南: 地址 初始化新建项目目录12345cd /root/Documents/mkdir ethereumcd ethereummkdir datatouch init.json ethereum是项目目录，新建目录data用以存放databases和keystore,新建文件init.json用于初始化的配置。以上目录文件名称等可以自定。 init配置配置内容参考官网init.json内容如下:1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 1106, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"alloc\" : &#123;&#125;, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\"&#125; 如果需要初始化的时候添加账户，可以在alloc中注明12345678\"alloc\": &#123; \"0x0000000000000000000000000000000000000001\": &#123; \"balance\": \"111111111\" &#125;, \"0x0000000000000000000000000000000000000002\": &#123; \"balance\": \"222222222\" &#125;&#125; mixhash:与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow Paper，Block Header Validity（44）章节中所描述的条件 nonce：nonce就是一个64位的随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow Paper，Block Header Validity（44）章节中所描述的条件 difficulty:设置当前区块的难度，如果难度过大，cpu挖矿就困难。私有链设置的小一些。 alloc：用于预设值账号已经账号的以太币数量。 coinbase：矿工的账号，随意填 timestamp:创世块的时间戳 parentHash：上一个区块的hash值，因为是创世块，所以这个值为0 extraData：附加信息 gasLimit：该值设置对gas的消耗总量限制，用来限制区块能包含的交易信息的总和。私有链填最大。 具体的key的含义参考官网文档即可。 使用中发现extraData不为空时，会报错Fatal: invalid genesis file: json: cannot unmarshal hex string without 0x prefix into Go struct field Genesis.extraData of type hexutil.Bytes Attention: chainId不能为0，为0时，在后续转账是无法成功。报错Error: insufficient funds for gas * price + value Attention: chainId 和 后续的networkid 保持一致，否则报错Error: insufficient funds for gas * price + value。 见issue。 创世操作执行以下命令初始化系统123&gt; pwd/root/Documents/ethereum&gt; geth --datadir \"/root/Documents/ethereum/data\" init init.json 正常结果如下：123456789INFO [03-27|19:56:49] Maximum peer count ETH=25 LES=0 total=25INFO [03-27|19:56:49] Allocated cache and file handles database=/root/Documents/ethereum/data/geth/chaindata cache=16 handles=16INFO [03-27|19:56:49] Writing custom genesis blockINFO [03-27|19:56:49] Persisted trie from memory database nodes=0 size=0.00B time=38.164µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [03-27|19:56:49] Successfully wrote genesis state database=chaindata hash=5e1fc7…d790e0INFO [03-27|19:56:49] Allocated cache and file handles database=/root/Documents/ethereum/data/geth/lightchaindata cache=16 handles=16INFO [03-27|19:56:49] Writing custom genesis blockINFO [03-27|19:56:49] Persisted trie from memory database nodes=0 size=0.00B time=2.884µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [03-27|19:56:49] Successfully wrote genesis state database=lightchaindata 接着执行以下命令 启动运行1geth --rpc --rpccorsdomain &quot;*&quot; --datadir &quot;/root/Documents/ethereum/data&quot; --networkid 100000 console 2&gt;&gt;geth.log 参数的含义请参考Command文档. 参数 参数说明 datadir 设置当前区块链网络数据存放的位置 console 启动命令行模式，可以在geth里执行命令 nodiscover 关闭p2p网络的自动发现，不会被网上看到 networkid 网络标识，用于区分不同的网络，私有链取一个大于4的随意的值 identity 区块链的标示，随便填写，用于标示目前网络的名字 init 指定创世块文件的位置，并创建初始块 rpc 启动rpc通信，可以进行智能合约的部署和调试 rpcapi 设置允许连接的rpc的客户端，一般为db，net，eth，web3 正常结果返回Welcome to the Geth JavaScript console! 1234567891011121314151617181920212223INFO [03-27|21:51:13] Maximum peer count ETH=25 LES=0 total=25INFO [03-27|21:51:13] Starting peer-to-peer node instance=Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4INFO [03-27|21:51:13] Allocated cache and file handles database=/root/Documents/ethereum/data/geth/chaindata cache=768 handles=512INFO [03-27|21:51:13] Initialised chain configuration config=&quot;&#123;ChainID: 0 Homestead: 0 DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown&#125;&quot;INFO [03-27|21:51:13] Disk storage enabled for ethash caches dir=/root/Documents/ethereum/data/geth/ethash count=3INFO [03-27|21:51:13] Disk storage enabled for ethash DAGs dir=/root/.ethash count=2INFO [03-27|21:51:13] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=100000INFO [03-27|21:51:13] Loaded most recent local header number=0 hash=5e1fc7…d790e0 td=131072INFO [03-27|21:51:13] Loaded most recent local full block number=0 hash=5e1fc7…d790e0 td=131072INFO [03-27|21:51:13] Loaded most recent local fast block number=0 hash=5e1fc7…d790e0 td=131072INFO [03-27|21:51:13] Loaded local transaction journal transactions=0 dropped=0INFO [03-27|21:51:13] Regenerated local transaction journal transactions=0 accounts=0INFO [03-27|21:51:13] Starting P2P networkingINFO [03-27|21:51:16] UDP listener up self=enode://09200d47050993bac053ec038ab90046d8ce5e6c82005f4f1c2a34704f523d7545444d6f3c921f40545fe96b6b56b0b12019cd444ec072493f6db9f77025e590@[::]:30303INFO [03-27|21:51:16] HTTP endpoint opened url=http://127.0.0.1:8545 cors=* vhosts=localhostINFO [03-27|21:51:16] RLPx listener up self=enode://09200d47050993bac053ec038ab90046d8ce5e6c82005f4f1c2a34704f523d7545444d6f3c921f40545fe96b6b56b0b12019cd444ec072493f6db9f77025e590@[::]:30303INFO [03-27|21:51:16] IPC endpoint opened url=/root/Documents/ethereum/data/geth.ipcWelcome to the Geth JavaScript console!instance: Geth/v1.8.2-stable-b8b9f7f4/linux-amd64/go1.9.4 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 操作到现在，私有链已经搭建好了，只是现在还没有账户，也没有交易，只有一个环境。 最终的ethereum目录结构如下：12345678910111213141516171819202122232425262728293031.├── data│ ├── geth│ │ ├── chaindata│ │ │ ├── 000002.ldb│ │ │ ├── 000005.ldb│ │ │ ├── 000006.log│ │ │ ├── CURRENT│ │ │ ├── LOCK│ │ │ ├── LOG│ │ │ └── MANIFEST-000007│ │ ├── lightchaindata│ │ │ ├── 000001.log│ │ │ ├── CURRENT│ │ │ ├── LOCK│ │ │ ├── LOG│ │ │ └── MANIFEST-000000│ │ ├── LOCK│ │ ├── nodekey│ │ ├── nodes│ │ │ ├── 000011.log│ │ │ ├── 000013.ldb│ │ │ ├── CURRENT│ │ │ ├── LOCK│ │ │ ├── LOG│ │ │ └── MANIFEST-000012│ │ └── transactions.rlp│ ├── geth.ipc│ ├── history│ └── keystore└── init.json 挖矿 写在前面的话：如果是像我一样跑在虚拟机上的童鞋，请先调高你的虚拟机配置，初始的Ubuntu我的是1C1G，通过5h的挖矿探索，发现调高配置到4C2G，分分钟挖到了。血泪史。 接着上面的geth命令行，执行以下命令查询账户和新建账户。listAccounts为[],表示当前没有账户；newAccount()，输入密码就会新建一个账户，这时候再listAccounts就会显示刚才创建的用户。12345678&gt; personal.listAccounts[]&gt; personal.newAccount()Passphrase:Repeat passphrase:&quot;0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&quot;&gt; personal.listAccounts[&quot;0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&quot;] personal.listAccounts 等同于eth.accounts，说明有很多包的方法有重复 geth的命令行支持的操作参见文档 现在有了第一个账户，可以开始挖矿了。 geth命令行执行以下命令，查当前账户的钱包。当前为0以太币123&gt; acc0 = eth.accounts[0]&gt; eth.getBalance(acc0)0 接着输入12&gt; miner.start()true 语法是：miner.start(threadCount),返回true表示开始挖矿 一次挖矿完整的记录如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143INFO [03-27|23:31:13] Generating DAG in progress epoch=1 percentage=0 elapsed=4m15.013sINFO [03-27|23:35:20] Generating DAG in progress epoch=1 percentage=1 elapsed=8m22.403sINFO [03-27|23:40:52] Generating DAG in progress epoch=1 percentage=2 elapsed=13m54.069sINFO [03-27|23:45:11] Generating DAG in progress epoch=1 percentage=3 elapsed=18m12.980sINFO [03-27|23:49:05] Generating DAG in progress epoch=1 percentage=4 elapsed=22m7.204sINFO [03-27|23:51:19] Regenerated local transaction journal transactions=0 accounts=0INFO [03-27|23:53:33] Generating DAG in progress epoch=1 percentage=5 elapsed=26m34.627sINFO [03-27|23:57:48] Generating DAG in progress epoch=1 percentage=6 elapsed=30m49.961sINFO [03-28|00:02:21] Generating DAG in progress epoch=1 percentage=7 elapsed=35m22.462sINFO [03-28|00:06:30] Generating DAG in progress epoch=1 percentage=8 elapsed=39m31.955sINFO [03-28|00:10:38] Generating DAG in progress epoch=1 percentage=9 elapsed=43m39.886sINFO [03-28|00:14:44] Generating DAG in progress epoch=1 percentage=10 elapsed=47m46.109sINFO [03-28|00:18:53] Generating DAG in progress epoch=1 percentage=11 elapsed=51m55.415sINFO [03-28|00:23:16] Generating DAG in progress epoch=1 percentage=12 elapsed=56m17.590sINFO [03-28|00:27:26] Generating DAG in progress epoch=1 percentage=13 elapsed=1h0m27.989sINFO [03-28|00:31:27] Generating DAG in progress epoch=1 percentage=14 elapsed=1h4m28.462sINFO [03-28|00:35:21] Generating DAG in progress epoch=1 percentage=15 elapsed=1h8m22.313sINFO [03-28|00:39:20] Generating DAG in progress epoch=1 percentage=16 elapsed=1h12m21.312sINFO [03-28|00:43:29] Generating DAG in progress epoch=1 percentage=17 elapsed=1h16m30.009sINFO [03-28|00:47:37] Generating DAG in progress epoch=1 percentage=18 elapsed=1h20m38.194sINFO [03-28|00:51:16] Regenerated local transaction journal transactions=0 accounts=0INFO [03-28|00:51:33] Generating DAG in progress epoch=1 percentage=19 elapsed=1h24m34.492sINFO [03-28|00:55:25] Generating DAG in progress epoch=1 percentage=20 elapsed=1h28m26.685sINFO [03-28|00:59:04] Generating DAG in progress epoch=1 percentage=21 elapsed=1h32m4.969sINFO [03-28|01:03:10] Generating DAG in progress epoch=1 percentage=22 elapsed=1h36m11.437sINFO [03-28|01:07:06] Generating DAG in progress epoch=1 percentage=23 elapsed=1h40m7.738sINFO [03-28|01:11:08] Generating DAG in progress epoch=1 percentage=24 elapsed=1h44m9.167sINFO [03-28|01:15:44] Generating DAG in progress epoch=1 percentage=25 elapsed=1h48m45.854sINFO [03-28|01:20:39] Generating DAG in progress epoch=1 percentage=26 elapsed=1h53m40.293sINFO [03-28|01:24:36] Generating DAG in progress epoch=1 percentage=27 elapsed=1h57m37.955sINFO [03-28|01:28:12] Generating DAG in progress epoch=1 percentage=28 elapsed=2h1m13.753sINFO [03-28|01:31:58] Generating DAG in progress epoch=1 percentage=29 elapsed=2h4m59.767sINFO [03-28|01:35:39] Generating DAG in progress epoch=1 percentage=30 elapsed=2h8m40.917sINFO [03-28|01:39:22] Generating DAG in progress epoch=1 percentage=31 elapsed=2h12m23.719sINFO [03-28|01:43:03] Generating DAG in progress epoch=1 percentage=32 elapsed=2h16m4.180sINFO [03-28|01:46:56] Generating DAG in progress epoch=1 percentage=33 elapsed=2h19m57.810sINFO [03-28|01:50:24] Generating DAG in progress epoch=1 percentage=34 elapsed=2h23m26.296sINFO [03-28|01:51:19] Regenerated local transaction journal transactions=0 accounts=0INFO [03-28|01:54:03] Generating DAG in progress epoch=1 percentage=35 elapsed=2h27m4.613sINFO [03-28|01:57:47] Generating DAG in progress epoch=1 percentage=36 elapsed=2h30m49.006sINFO [03-28|02:01:29] Generating DAG in progress epoch=1 percentage=37 elapsed=2h34m31.396sINFO [03-28|02:05:15] Generating DAG in progress epoch=1 percentage=38 elapsed=2h38m16.808sINFO [03-28|02:08:59] Generating DAG in progress epoch=1 percentage=39 elapsed=2h42m1.220sINFO [03-28|02:13:00] Generating DAG in progress epoch=1 percentage=40 elapsed=2h46m1.605sINFO [03-28|02:16:40] Generating DAG in progress epoch=1 percentage=41 elapsed=2h49m42.243sINFO [03-28|02:20:20] Generating DAG in progress epoch=1 percentage=42 elapsed=2h53m22.062sINFO [03-28|02:24:09] Generating DAG in progress epoch=1 percentage=43 elapsed=2h57m11.394sINFO [03-28|02:27:50] Generating DAG in progress epoch=1 percentage=44 elapsed=3h0m52.296sINFO [03-28|02:31:27] Generating DAG in progress epoch=1 percentage=45 elapsed=3h4m28.628sINFO [03-28|02:35:18] Generating DAG in progress epoch=1 percentage=46 elapsed=3h8m20.178sINFO [03-28|02:38:58] Generating DAG in progress epoch=1 percentage=47 elapsed=3h11m59.768sINFO [03-28|02:42:38] Generating DAG in progress epoch=1 percentage=48 elapsed=3h15m39.901sINFO [03-28|02:46:29] Generating DAG in progress epoch=1 percentage=49 elapsed=3h19m31.220sINFO [03-28|02:50:03] Generating DAG in progress epoch=1 percentage=50 elapsed=3h23m5.428sINFO [03-28|02:51:17] Regenerated local transaction journal transactions=0 accounts=0INFO [03-28|02:53:44] Generating DAG in progress epoch=1 percentage=51 elapsed=3h26m46.427sINFO [03-28|02:57:25] Generating DAG in progress epoch=1 percentage=52 elapsed=3h30m26.974sINFO [03-28|03:00:55] Generating DAG in progress epoch=1 percentage=53 elapsed=3h33m57.345sINFO [03-28|03:04:34] Generating DAG in progress epoch=1 percentage=54 elapsed=3h37m36.322sINFO [03-28|03:08:16] Generating DAG in progress epoch=1 percentage=55 elapsed=3h41m17.787sINFO [03-28|03:11:52] Generating DAG in progress epoch=1 percentage=56 elapsed=3h44m53.677sINFO [03-28|03:15:50] Generating DAG in progress epoch=1 percentage=57 elapsed=3h48m51.747sINFO [03-28|03:19:30] Generating DAG in progress epoch=1 percentage=58 elapsed=3h52m32.327sINFO [03-28|03:23:07] Generating DAG in progress epoch=1 percentage=59 elapsed=3h56m9.105sINFO [03-28|03:26:49] Generating DAG in progress epoch=1 percentage=60 elapsed=3h59m50.899sINFO [03-28|03:30:28] Generating DAG in progress epoch=1 percentage=61 elapsed=4h3m29.553sINFO [03-28|03:33:55] Generating DAG in progress epoch=1 percentage=62 elapsed=4h6m57.427sINFO [03-28|03:37:30] Generating DAG in progress epoch=1 percentage=63 elapsed=4h10m32.180sINFO [03-28|03:41:04] Generating DAG in progress epoch=1 percentage=64 elapsed=4h14m6.429sINFO [03-28|04:06:03] Generating DAG in progress epoch=1 percentage=65 elapsed=4h18m11.501sINFO [03-28|04:09:47] Generating DAG in progress epoch=1 percentage=66 elapsed=4h21m55.415sINFO [03-28|04:12:08] Regenerated local transaction journal transactions=0 accounts=0INFO [03-28|04:13:36] Generating DAG in progress epoch=1 percentage=67 elapsed=4h25m44.487sINFO [03-28|04:17:11] Generating DAG in progress epoch=1 percentage=68 elapsed=4h29m20.175sINFO [03-28|04:21:02] Generating DAG in progress epoch=1 percentage=69 elapsed=4h33m10.483sINFO [03-28|04:24:45] Generating DAG in progress epoch=1 percentage=70 elapsed=4h36m53.288sINFO [03-28|04:28:21] Generating DAG in progress epoch=1 percentage=71 elapsed=4h40m29.837sINFO [03-28|04:32:00] Generating DAG in progress epoch=1 percentage=72 elapsed=4h44m8.371sINFO [03-28|04:35:33] Generating DAG in progress epoch=1 percentage=73 elapsed=4h47m41.299sINFO [03-28|04:39:09] Generating DAG in progress epoch=1 percentage=74 elapsed=4h51m17.830sINFO [03-28|04:42:37] Generating DAG in progress epoch=1 percentage=75 elapsed=4h54m46.152sINFO [03-28|04:46:18] Generating DAG in progress epoch=1 percentage=76 elapsed=4h58m26.446sINFO [03-28|04:50:00] Generating DAG in progress epoch=1 percentage=77 elapsed=5h2m8.264sINFO [03-28|04:53:42] Generating DAG in progress epoch=1 percentage=78 elapsed=5h5m50.968sINFO [03-28|04:57:31] Generating DAG in progress epoch=1 percentage=79 elapsed=5h9m38.710sINFO [03-28|05:01:14] Generating DAG in progress epoch=1 percentage=80 elapsed=5h13m22.502sINFO [03-28|05:05:14] Generating DAG in progress epoch=1 percentage=81 elapsed=5h17m22.433sINFO [03-28|05:09:26] Generating DAG in progress epoch=1 percentage=82 elapsed=5h21m34.496sINFO [03-28|05:12:10] Regenerated local transaction journal transactions=0 accounts=0INFO [03-28|05:13:21] Generating DAG in progress epoch=1 percentage=83 elapsed=5h25m30.173sINFO [03-28|05:17:17] Generating DAG in progress epoch=1 percentage=84 elapsed=5h29m10.749sINFO [03-28|05:18:19] Generating DAG in progress epoch=1 percentage=85 elapsed=5h30m12.264sINFO [03-28|05:18:35] Generating DAG in progress epoch=1 percentage=86 elapsed=5h30m29.213sINFO [03-28|05:18:47] Successfully sealed new block number=1 hash=ee7849...d9fa2INFO [03-28|05:18:47] mined potential block number=1 hash=ee7849...d9fa2INFO [03-28|05:18:47] Commit new mining work number=2 txs=0 uncles=0 elapsed=80.389msINFO [03-28|05:18:49] Generating DAG in progress epoch=1 percentage=87 elapsed=5h30m42.735sINFO [03-28|05:18:58] Successfully sealed new block number=2 hash=71a6fe...8f13cINFO [03-28|05:18:58] mined potential block number=2 hash=71a6fe...8f13cINFO [03-28|05:18:58] Commit new mining work number=3 txs=0 uncles=0 elapsed=92.767sINFO [03-28|05:19:02] Generating DAG in progress epoch=1 percentage=88 elapsed=5h30m55.718sINFO [03-28|05:19:15] Generating DAG in progress epoch=1 percentage=89 elapsed=5h31m8.583sINFO [03-28|05:19:21] Successfully sealed new block number=3 hash=12e44e...743f9INFO [03-28|05:19:21] mined potential block number=3 hash=12e44e...743f9INFO [03-28|05:19:21] Commit new mining work number=4 txs=0 uncles=0 elapsed=110.894μsINFO [03-28|05:19:25] Successfully sealed new block number=4 hash=0cdb39...ba20bINFO [03-28|05:19:25] mined potential block number=4 hash=0cdb39...ba20bINFO [03-28|05:19:25] Commit new mining work number=5 txs=0 uncles=0 elapsed=135.77μsINFO [03-28|05:19:28] Generating DAG in progress epoch=1 percentage=90 elapsed=5h31m21.687sINFO [03-28|05:19:33] Successfully sealed new block number=5 hash=c90c64...91627INFO [03-28|05:19:33] mined potential block number=5 hash=c90c64...91627INFO [03-28|05:19:33] Commit new mining work number=6 txs=0 uncles=0 elapsed=175.941μsINFO [03-28|05:19:34] Successfully sealed new block number=6 hash=bb6175...89bebINFO [03-28|05:19:34] block reached canonical chain number=1 hash=ee7849...d9fa2INFO [03-28|05:19:34] mined potential block number=6 hash=bb6175...89bebINFO [03-28|05:19:34] Commit new mining work number=7 txs=0 uncles=0 elapsed=133.76μsINFO [03-28|05:19:40] Generating DAG in progress epoch=1 percentage=91 elapsed=5h31m34.113sINFO [03-28|05:19:42] Successfully sealed new block number=7 hash=047dee...55436INFO [03-28|05:19:42] block reached canonical chain number=2 hash=71a6fe...8f13cINFO [03-28|05:19:42] mined potential block number=7 hash=047dee...55436INFO [03-28|05:19:42] Commit new mining work number=8 txs=0 uncles=0 elapsed=95.689μs&gt; mINFO [03-28|05:19:46] Successfully sealed new block number=8 hash=19e109...3fbdeINFO [03-28|05:19:46] block reached canonical chain number=3 hash=12e44e...743f9INFO [03-28|05:19:46] mined potential block number=8 hash=19e109...3fbdeINFO [03-28|05:19:46] Commit new mining work number=9 txs=0 uncles=0 elapsed=115.824μs&gt; miINFO [03-28|05:19:47] Successfully sealed new block number=9 hash=4538a0...aa22eINFO [03-28|05:19:47] block reached canonical chain number=4 hash=0cdb39...ba20bINFO [03-28|05:19:47] mined potential block number=9 hash=4538a0...aa22eINFO [03-28|05:19:47] Commit new mining work number=10 txs=0 uncles=0 elapsed=109.851μs&gt; miner.stop()INFO [03-28|05:19:51] Successfully sealed new block number=10 hash=7e83b8...1f8f7INFO [03-28|05:19:51] block reached canonical chain number=5 hash=c90c64...91627INFO [03-28|05:19:51] mined potential block number=10 hash=7e83b8...1f8f7INFO [03-28|05:19:51] Commit new mining work number=11 txs=0 uncles=0 elapsed=181.645μsINFO [03-28|05:19:52] Successfully sealed new block number=11 hash=5c5aab...9d07dINFO [03-28|05:19:52] block reached canonical chain number=6 hash=bb6175...89bebINFO [03-28|05:19:52] mined potential block number=11 hash=5c5aab...9d07dINFO [03-28|05:19:52] Commit new mining work number=12 txs=0 uncles=0 elapsed=223.353μstrue&gt; INFO [03-28|05:19:53] Generating DAG in progress epoch=1 percentage=92 elapsed=5h31m46.365sINFO [03-28|05:19:58] Generating DAG in progress epoch=1 percentage=93 elapsed=5h31m51.285sINFO [03-28|05:20:03] Generating DAG in progress epoch=1 percentage=94 elapsed=5h31m56.675sINFO [03-28|05:20:08] Generating DAG in progress epoch=1 percentage=95 elapsed=5h32m1.628s 分析一下: Generating DAG in progress正在生成DAG，参考DAG Regenerated local transaction journal重新生成本地事务日志 Successfully sealed new block成功密封新块 mined potential block挖掘潜在的块 Commit new mining work提交新的采矿工作 block reached canonical chain块达到了规范链 epoch纪元 elapsed过去 uncles叔链 这个时候我再查一下账户，发现已经有钱啦。这就是挖矿得来的奖励。我查了下总共有11次success的标识，钱包是55 ether，那每次挖矿会奖励5个以太币了。（显示的单位是wei）12&gt; eth.getBalance(acc0)55000000000000000000 注意：ethereum中的最小交易单位是wei，所有的交易都已Wei为单位进行。换算方法如下： Unit Wei Value Wei wei 1 1 wei Kwei (babbage) 1e3 wei 1,000 Mwei (lovelace) 1e6 wei 1,000,000 Gwei (shannon) 1e9 wei 1,000,000,000 microether (szabo) 1e12 wei 1,000,000,000,000 milliether (finney) 1e15 wei 1,000,000,000,000,000 ether 1e18 wei 1,000,000,000,000,000,000 交易为了模拟交易，我们新建一个用户。123456&gt; personal.newAccount()Passphrase:Repeat passphrase:&quot;0x68512ebacb81a3274933de1ac02a787927ef76d5&quot;&gt; personal.listAccounts[&quot;0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5&quot;, &quot;0x68512ebacb81a3274933de1ac02a787927ef76d5&quot;] 新账户的钱包：1234&gt; acc1 = eth.accounts[1]&quot;0x68512ebacb81a3274933de1ac02a787927ef76d5&quot;&gt; eth.getBalance(acc1)0 我们要互相转多少钱呢？由于wei的单位太小，直接使用起来不方便，我们可以执行以下命令：123456&gt; web3.toWei(1)&quot;1000000000000000000&quot;&gt; web3.toWei(1,&apos;ether&apos;)&quot;1000000000000000000&quot;&gt; web3.toWei(1,&apos;kWei&apos;)&quot;1000&quot; web3.toWei(number, unit) 是把数值转换为wei的单位web3.toWei(1,’ether’) === 1 ether (默认)web3.toWei(1,’kWei’)=== 1 kWei web3的用法参照文档. web3 console里内置了一些用来操作以太坊的Javascript对象。主要有： eth：包含一些跟操作区块链相关的方法 net：包含以下查看p2p网络状态的方法 admin：包含一些与管理节点相关的方法 miner：包含启动&amp;停止挖矿的一些方法 personal：主要包含一些管理账户的方法 txpool：包含一些查看交易内存池的方法 web3：包含了以上对象，还包含一些单位换算的方法 我们把钱从第一个账户转到第二个账户，金额是1 ether。12345678&gt; money = web3.toWei(1)&quot;1000000000000000000&quot;&gt; eth.sendTransaction(&#123;from:acc0, to:acc1, value:money&#125;)Error: authentication needed: password or unlock at web3.js:3143:20 at web3.js:6347:15 at web3.js:5081:36 at &lt;anonymous&gt;:1:1 命令很好理解（命令省去了一些参数）。报错也很常见，账户被锁。这是ethereum的安全机制，每隔一段时间就会锁定账户。交易前先解锁账户（发起交易的账户）。 1234&gt; personal.unlockAccount(acc0)Unlock account 0x93a44e1e0aceb6a68ed39018d48a359b0beb8eb5Passphrase:true 解锁完成，直接操作123&gt; eth.sendTransaction(&#123;from:acc0, to:acc1, value:web3.toWei(1, &apos;ether&apos;)&#125;)INFO [03-29|02:37:55] Submitted transaction fullhash=0xde091e31d3251b590420981f7d1b5675bb18ef3a6abcbe91fe5565c6f4299f16 recipient=0x68512eBACB81a3274933DE1ac02a787927Ef76D5&quot;0xde091e31d3251b590420981f7d1b5675bb18ef3a6abcbe91fe5565c6f4299f16&quot; 执行到这一步如果报错Error:insufficient funds for gas * price + value的报错，回到init时的attention处找一下原因。我做到这一步报错，停掉重新init，重新启动，账户还在，余额也在，转账正常。原理还未知。 这个时候，查看两个账户的余额，发现还没有变化。这是因为交易要记录在通过挖矿找到的块上才算生效。所以我们继续挖矿。 最终结果如下：挖到矿后，两个账户的金额有了变动，账户1:55+5（挖矿）-1（交易） ；账户2:1（交易）123456789101112131415&gt; miner.start(10)INFO [03-29|02:57:56] Updated mining threads threads=10INFO [03-29|02:57:56] Transaction pool price threshold updated price=18000000000null&gt; INFO [03-29|02:57:56] Starting mining operationINFO [03-29|02:57:56] Commit new mining work number=12 txs=1 uncles=0 elapsed=109.261msINFO [03-29|03:03:00] Successfully sealed new block number=12 hash=205b7a…159a50INFO [03-29|03:03:01] 🔨 mined potential block number=12 hash=205b7a…159a50INFO [03-29|03:03:01] Commit new mining work number=13 txs=0 uncles=0 elapsed=357.976µs&gt; miner.stop()true&gt; eth.getBalance(acc0)59000000000000000000&gt; eth.getBalance(acc1)1000000000000000000 参考文档 https://blog.csdn.net/ethchinese/article/details/62220879 https://blog.csdn.net/lhtzbj12/article/details/79405238 https://github.com/ethereum/go-ethereum/wiki/Private-network","tags":[{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"},{"name":"private chain","slug":"private-chain","permalink":"https://zj-john.github.io/tags/private-chain/"}]},{"title":"blockchain 笔记","date":"2018-03-28T06:20:51.000Z","path":"notes/ckbdbl418002s2ktyqdh8gyil.html","text":"blockchain 笔记最近在学习区块链，先做些记录，后续再整理 书籍教程 区块链技术指南: 地址 论文【以太坊：一种安全去中心化的通用交易账本】：中文地址 Node.js开发加密货币： 地址 知乎贴： 地址 以太坊中文教程： 地址 比特币当前交易信息查看最近的区块，区块大小、传输数据、交易笔数等信息。 具体交易某个区块上具体的交易信息、上一块的hash，本区块的hash（通过以上两个hash可以开始计算下一个块的hash地址了）、矿工、交易费等 技术实践以太坊安装（Ubuntu版本）参考文档 安装 Go 环境12345curl -O https://storage.googleapis.com/golang/go1.5.1.linux-amd64.tar.gztar -C /usr/local -xzf go1.5.1.linux-amd64.tar.gzmkdir -p ~/go; echo \"export GOPATH=$HOME/go\" &gt;&gt; ~/.bashrcecho \"export PATH=$PATH:$HOME/go/bin:/usr/local/go/bin\" &gt;&gt; ~/.bashrcsource ~/.bashrc 安装之后，terminal中直接输入 go 来验证是否安装成功。 安装 ethereum12345sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ethereum/ethereumsudo add-apt-repository -y ppa:ethereum/ethereum-devsudo apt-get updatesudo apt-get install ethereum 安装之后，terminal中直接输入 geth –help 来验证ethereum是否安装成功。 如果需要智能合约的话，还需要安装 solc 编译器(Solidity语言)1234sudo add-apt-repository ppa:ethereum/ethereum-qtsudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install cpp-ethereum geth 修改储存区块数据的地址geth -datadir “/media/ethereum/“ 同步区块数据geth 快速同步区块数据geth -fast 创建账户geth account new 记好密码，唯一凭证 查看账户geth account list 产品 网易星球邀请码：ADQC7X上车码：https://zhuanlan.zhihu.com/p/33722443","tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://zj-john.github.io/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://zj-john.github.io/tags/ethereum/"}]},{"title":"nodejs excel处理","date":"2018-03-27T06:19:17.000Z","path":"tips/ckbdbl45l00be2kty6fx5e17z.html","text":"nodejs excel处理 库js-xlsx 教程https://scarletsky.github.io/2016/01/30/nodejs-process-excel/#解析-Excel-生成-JSON","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"excel","slug":"excel","permalink":"https://zj-john.github.io/tags/excel/"}]},{"title":"react-bootstrap-typeahead 设置不可选option","date":"2018-03-26T02:33:49.000Z","path":"tips/ckbdbl45a00aw2ktya0ddwisa.html","text":"react中使用了react-bootstrap-typeahead插件，需要在样式里做分组，类似于optgroup的样式。所以optgroup的label需要不可选择,在插件的说明文档中并没有这个说明。需要怎么配置呢？ 找了下源码，看到源码中实际上做了这一部分，但是没有说明出来。render option的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// TypeaheadMenu.react.jsconst menuItemProps = &#123; // 有disabled的props disabled: option.disabled, key: idx, label: getOptionLabel(option, labelKey), option, position: idx,&#125;;if (option.customOption) &#123; return ( &lt;MenuItem &#123;...menuItemProps&#125; className=\"rbt-menu-custom-option\" label=&#123;newSelectionPrefix + option[labelKey]&#125;&gt; &#123;newSelectionPrefix&#125; &lt;Highlighter search=&#123;text&#125;&gt; &#123;option[labelKey]&#125; &lt;/Highlighter&gt; &lt;/MenuItem&gt; );&#125;return ( &lt;MenuItem &#123;...menuItemProps&#125;&gt; &#123;renderMenuItemChildren(option, this.props, idx)&#125; &lt;/MenuItem&gt;);// MenuItem.react.jsreturn ( /* eslint-disable jsx-a11y/anchor-is-valid */ &lt;li &#123;...props&#125; className=&#123;cx(conditionalClassNames, className)&#125;&gt; &lt;a className=&#123;cx('dropdown-item', conditionalClassNames)&#125; href=\"#\" onClick=&#123;this._handleClick&#125; onMouseDown=&#123;onMouseDown&#125;&gt; &#123;children&#125; &lt;/a&gt; &lt;/li&gt; /* eslint-enable jsx-a11y/anchor-is-valid */ );&#125;_handleClick = (e) =&gt; &#123; const &#123;disabled, onClick&#125; = this.props; e.preventDefault(); // disabled为false时才触发onclick事件 !disabled &amp;&amp; onClick(e);&#125; 修改了代码后，已经无法点击optgroup的label，但是仍可以通过键盘Enter来选择optgroup。 这个问题在issue:304做了修复，发布在新版本v2.3.2中。我当前使用的版本1.4.2过低，升级一下再试试。","tags":[{"name":"react-bootstrap-typeahead","slug":"react-bootstrap-typeahead","permalink":"https://zj-john.github.io/tags/react-bootstrap-typeahead/"}]},{"title":"Angular1 笔记","date":"2018-03-16T07:19:42.000Z","path":"notes/ckbdbl412002e2ktynt3jq6ux.html","text":"Angular1学习记录整理文件夹的时候发现了蛮早之前写的Angular1的笔记，搬到博客来。 基本1234567891011121314// 原生方法替代$window.alert();$eval(\"20+1|number:0\")// 模板// 允许空值、null、undefined&#123;&#123; tmp &#125;&#125;// 允许函数，需要返回值&#123;&#123; temp() &#125;&#125;// 定义modulevar module = anguler.module(\"a\",[]);// 注入控制器a.controller('aCtrl',['$scope',function($scope)()&#123; $scope.text = \"hello world\"&#125;]); 模板1234// 方式1&lt;script type=\"text/ng-template\" id=\"tplbase\"&gt;……&lt;/script&gt;// 方式2&lt;div ng-include src=\"tplbase\" ng-controller=\"CtrlTest\"&gt;&lt;/div&gt; 样式123456789101112&lt;!-- $scope.a = true; --&gt;&lt;!-- $scope.b = false; --&gt;&lt;div ng-class=\"&#123;'class1':a,'class2':b&#125;\"&gt;&lt;/div&gt;&lt;!-- 等价于 --&gt;&lt;div class=\"class1\"&gt;&lt;/div&gt;&lt;!-- switch --&gt;&lt;ul ng-switch on=&#123;&#123; switchvalue &#125;&#125;&gt; &lt;li ng-switch-when=\"1\"&gt;a&lt;/li&gt; &lt;li ng-switch-when=\"2\"&gt;b&lt;/li&gt; &lt;li ng-switch-default&gt;default&lt;/li&gt;&lt;/ul&gt; Form $pristine: 表单或控件是否未输入过 $dirty: 表单或控件是否已输入过 checkbox/radio 不具备控件验证功能 12345678910111213141516171819202122&lt;!-- 错误信息展示 --&gt;&lt;form name=\"testForm\"&gt;&lt;input type=\"text\" name=\"testInput\"/&gt;&lt;label ng-show=\"testForm.testInput.$error.required\"&gt;这是必填项&lt;/label&gt;&lt;input type=\"email\" name=\"emailInput\"/&gt;&lt;label ng-show=\"testForm.emailInput.$error.email\"&gt;不符合email格式&lt;/label&gt;&lt;/form&gt;&lt;input type=\"checkbox\" ng-model=\"a\" ng-true-value=\"1\" ng-false-value=\"2\" /&gt;&lt;input type=\"radio\" ng-model=\"b\" value=\"1\"&gt;&lt;input type=\"radio\" ng-model=\"b\" value=\"0\"&gt;&lt;select ng-model=\"a\" ng-options=\"txt for txt in data\"&gt; &lt;option value=\"\"&gt;--请选择--&lt;/option&gt;&lt;/select&gt;&lt;!-- 分组 --&gt;&lt;select ng-model=\"a\" ng-options=\"txt.value as txt.text group by txt.key for txt in data\"&gt; &lt;option value=\"\"&gt;--请选择--&lt;/option&gt;&lt;/select&gt; 过滤器1234567891011121314151617181920212223242526272829303132&lt;li ng-repeat=\" stu in data | orderBy: '-score' | limitTo: 3\"&gt;&lt;/li&gt;&lt;!-- 在score列匹配 --&gt;&#123;&#123; data | filter:&#123;score:90&#125;&#125;&#125;&lt;!-- 所有列匹配 --&gt;&#123;&#123; data | filter:&#123;$:90&#125;&#125;&#125;&lt;!-- 自定义过滤器 --&gt;&lt;li ng-repeat=\" stu in data | filter:selfmade \"&gt; &lt;/li&gt;&lt;script&gt;module.filter('selfmade',function()&#123; //e:数据,type:传参 return function(e, type)&#123; return result &#125;&#125;);&lt;/script&gt;&lt;!-- 类似datatable排序 --&gt;&lt;!-- 表头 --&gt;&lt;li&gt; &lt;span ng-click=\"title:'name';desc=!desc\"&gt;姓名&lt;/span&gt; &lt;span ng-click=\"title:'sex';desc=!desc\"&gt;性别&lt;/span&gt; &lt;span ng-click=\"title:'age';desc=!desc\"&gt;年龄&lt;/span&gt;&lt;/li&gt;&lt;!-- 内容 --&gt;&lt;li ng-repeat=\" stu in data | orderBy : title : desc\"&gt; &lt;span&gt;&#123;&#123; stu.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; stu.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; stu.age &#125;&#125;&lt;/span&gt;&lt;/li&gt; 搜索123&lt;input ng-model=\"key\" type=\"text\" placeholder=\"key world\" /&gt;&lt;!-- filter功能使用来创建一个新的数组 --&gt;&lt;li ng-repeat=\"stu in data | filter: &#123;name : key&#125;\"&gt;&lt;/li&gt; 作用域123456$scope.name=\"\"//监听属性的变化$scope.$watch('name',function()&#123;&#125;)// $rootScope :顶级作用域 子作用域和父作用域属性值重合时，先访问子作用域的对象，找不到再访问父作用域对象 通过作用域中的事件传播数据的功能十分有限，只能调用Angular中的$emit和$broadcast方法。 $broadcast(eventname, data):将事件从父级作用域传播至子级作用域 $emit(eventname, data)：将事件从子级作用域传播至父级作用域 $on(eventname,function(event,data){})：在作用域中监控传播来的事件并获取相应的数据 依赖注入123456789101112//此类内联写法使得代码支持压缩module.controller(\"controller\", ['$scope',function($scope)&#123; //控制器代码&#125;]);// 等价于module.config(function($controllerProvider)&#123; $controllerProvider.register('controller',['$scope',function($scope)&#123; //控制器代码 &#125;])&#125;) 后者是实际执行的本质：创建一个控制器时，，实际上在config函数中调用controllerProvider服务的register方法，依赖注入 一般流程：config -&gt; $provide服务 -&gt; provider,factory,service,value 方法，创建一个自定义的依赖注入对象，最上层可以直接使用return方法 factory123456789angular.module('ngapp',[]) .factory('$out',function()&#123; return &#123; // 服务代码 &#125; &#125;) .controller('aCtrl',function($scope,$out)&#123; //处理器代码 &#125;); 通过factory方法创建的服务代码，完全可以使用service方法来代替。但如果service方法创建的服务，使用factory方法代替时，需要先将service中的回调函数单独创建一个自定义函数，然后在factory的回调函数中使用关键字new实例化这个函数，并返回实例化后的对象。constant：返回常量，可用于创建配置数据，可以注入配置函数config中value：返回常量，创建对象和函数，不能注入到config中 $inject 方式的依赖注入的服务名和顺序必须与函数在构造时的参数名和顺序完全一致 $inject api injector.has(‘$方法name’)注册列表中查找相应服务，有返回true injector.get(‘$方法name’)var a = injector.get(‘$方法name’) 获得服务的实例对象后可以直接调用 a.test() injector.invoke(‘自定义fun’)执行一个自定义函数（立即触发） ng-view切换视图模板123456789101112131415161718&lt;div ng-view&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; module.config(['$routeProvider',function($routeProvider)&#123; $routeProvider .when(\"/\",&#123; controller:\"aCtrl\", template:\"aTemplate\" &#125;) .when(\"/book\",&#123; controller:\"bCtrl\", template:\"bTemplate\", publicAccess:true // 对外公开 全局 &#125;) .otherwise(&#123; redirectTo:\"/\" &#125;) &#125;]);&lt;/script&gt; 服务单例对象：每一个应用中只会被实例化一次$scope/$http/$window/$location 装饰器123456angular.module('a',[]) .config(function($provide)&#123; $provide.decorator('$student', function($delegate)()&#123; return $delegate &#125;) &#125;) $http刷新页面后缓存内容都会丢失 1234567// 先调用config方法，注入$httpProvider,设置默认headersanguler.module('module',[]) .config(function($httpProvider)&#123; $httpProvider.default.headers.post = &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125; &#125;) 12345$http.get(url.[data],[config]) .success(data,status,headers,config) .error(data,status,headers,config)// 等价于$http(&#123;&#125;).then(fn1成功, fn2失败) 12345678910$http(&#123; method: url: data: // POST 、PUT使用 params: // GET方法，追加到url后面，传给服务端 transformRequest: // 用于请求体头信息和请求体进行序列化转换，并生成一个数组发给服务端 transformResponse: // 对响应体头信息和响应体进行反序列化的转换，实质是解析服务器发送来的被序列化后的数据 cache: // 是否对http请求返回的数据进行缓存，true为缓存 timeout: // 延迟发送http请求，单位是ms&#125;).success() 缓存服务：$cacheFactory1234567891011121314151617 // 一般用法$cacheFactory(key,[option])$cacheFactory.get(key)// 先建一个cachevar cache = $cacheFactory(\"test\") //缓存信息 大小等console.log(cache.info())// 添加cache.put(\"key1\",\"value1\")cache.get(\"key1\")// 全删和清空所有引用 removeAll destorycache.remove(\"key1\") //把http的返回值存储在以$http为key的缓存中var cacheHttp = $cacheFactory.get($http);$http().then() $resource优于 $http 12&lt;!-- 需要格外引入： --&gt;&lt;script src=\"../Script/angular-resouce.min.js\"&gt;&lt;/script&gt; 注入时使用[‘ngResource’]12var obj = $resource('url');obj.get(params,successFn,errorFn) get类：get/query 非get类：save/delete/remove $promise123456789angular.module(\"m\",[]) .controller(\"c\",function($scope,$q)&#123; var defer = $q.defer(); var promise = defer.promise; promise.then(successCallback,errorCallback,notifyCallback); defer.notify(); // 通知 defer.reject(); // 拒绝 defer.reslove(); // 完成 &#125;) $http中使用$promise123456789var defer = $q.defer();$http.get().success(function()&#123; defer.resolve(data)&#125;).error(function(data)&#123; defer.reject(data)&#125;)return defer.promise; directive123456789var app = anjular.module(\"a\",[])a.directive('tsHello',function()&#123; return&#123; restrict: \"EAC\" // E：标签 A：属性 C：类别 M：注释 可以使用的方式 template:'&lt;h2&gt;Hello World&lt;/h2&gt;' templatUrl //template id replace：true // true 将模板中的内容替换指令标记 &lt;h2&gt;&lt;/h2&gt;，false不替换指令标记，将内容插入指令标记中，原内容清空，默认为false &#125;&#125;) 四种使用方式：1234&lt;ts-hello&gt;&lt;/ts-hello&gt;&lt;div ts-hello&gt;&lt;/div&gt;&lt;div class=\"ts-hello\"&gt;&lt;/div&gt;&lt;div data-ts-hello&gt;&lt;/div&gt; 属性 transclude取值：true/false利用ng-transclude方式替换指令元素中的内容，如果是纯文本，加span标签 123&lt;script type=\"text/ng-template\" id=\"tpl\"&gt; &lt;div ng-transclude class=\"tip\"&gt;&lt;/div&gt;&lt;/script&gt; 1234567.directive(\"tsTplscript\",function()&#123; return&#123; restrict:'EAC', templaateUrl:'tpl', transclude:true &#125;&#125;); 1234567&lt;!-- text = \"Hello\" --&gt;&lt;ts-tplscript&gt;&#123;&#123; text &#125;&#125;&lt;/ts-tplscript&gt;&lt;!-- 等价于 --&gt;&lt;div ng-transclude class=\"tip\"&gt; &lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt; linklink属性的值是一个函数，在该函数中可以操纵dom元素 1234567891011121314.directive(\"tsTplscript\",function()&#123; return &#123; restrict:'EAC', templaateUrl:'tpl', link:function(scope,iEle,iAttr)&#123; // iEle 父级元素 iEle.bind('click',function()&#123; scope.$apply(……); // iAttr.$$element 与属性对应的元素集合 iAttr.$$element[0].disabled = true; &#125;) &#125; &#125;&#125;) compile与link不可同用 scope取值：true/falsefalse时：不创建新的作用域，父与子作用域的数据完全相同，两方相互关联，一起变化。属性值还可以设置为json：绑定策略：@ = &amp; require创建子指定时添加，格式：require：’^?myParentDirective’ ,与controller一起使用 controller在创建父指令时添加，可以被实例的对象所继承，与require一起使用 $location服务只读方法：absUrl, protocol, host, port 读写类方法：1234567// http://1.html#?a=1&amp;b=2#hash$location.url()// ??a=1&amp;b=2#hash$location.hash()// hash$location.search()//&#123;\"a\":\"1\",\"b\":\"2\"&#125; 事件 $locationChangeStart :参数：current 当前地址 previous：上一个地址 $locationChangeSuccess路由模式：标签（hashbang）和HTML5模式 常见问题： setTimeout:-&gt;$timeout() 防止应用闪烁: ng-cloak AngularJS 应用在加载时，文档可能会由于AngularJS 代码未加载完而出现显示 AngularJS 代码，进而会有闪烁的效果， ng-cloak 指令是为了防止该问题的发生。 1&lt;element ng-cloak&gt;&lt;/element&gt; ng-repeat:如果有过滤器，不能使用$index索引定位元素 np-repeat:track by加快加载速度 ng-repeat=”user in users track by user.id” 解决单击事件的冒泡现象：$event.stopPropagation() 释放多余的$watch监测函数：定义$watch事件内容为空 利用ng-show代替ng-if:因为ng-if下的元素是一个子级作用域，无法直接在scope中修改，需要绑定的方式是ng-model=”$parent.b” 在浏览器标题栏中会在一瞬间看到如Google Phone Gallery:这样的信息，但其实这不是你希望的（这时angular的数据绑定还没有起作用，就造成了前面的原始数据显示，和后面起作用后的正确显示），对此一个更好的处理方法是使用ngBind或者ngBindTemplate命令，这使得在加载器无关的信息对用户来说是不可见的： 1&lt;title ng-bind-template=\"Google Phone Gallery: &#123;&#123;query&#125;&#125;\"&gt;Google Phone Gallery&lt;/title&gt; 把ng-src指令替换为原来的src属性:使用诸如Firebug之类的工具或者Chrome浏览器的Web开发组件观察web访问日志，可以观察到如/app/%7B%7Bphone.imageUrl%7D%7D 或者/app/这样的无效请求，这些无效请求就是浏览器在Angular还没有正确初始化和进行数据绑定（注入）时，构建img标签时发出的，这使得图片不能正确显示。","tags":[{"name":"Angular1","slug":"Angular1","permalink":"https://zj-john.github.io/tags/Angular1/"}]},{"title":"Design Principles","date":"2018-03-15T07:50:02.000Z","path":"notes/ckbdbl41p003m2ktyjtcv92b6.html","text":"Design Principles做的页面总是被人Diss难看。写的代码越多，越觉得设计真的是好难，但是又必须掌握。只能慢慢积累了…… 布局布局是一个网页的骨骼。虽然它很重要，但并不是最难的部分。常用的布局模式就那么几种，几乎所有的UI框架都已经将其涵盖在内。对于我这样的设计萌新来说，使用起来简单的尝试、重复即可。 配色颜色是最难也是最重要的部分。配色多了，乱；配色少了，重点不突出。配色不搭，就像一个不会化妆的妹子首次尝试一样，只可远观…… 配色的理论知识很多，想学到理论的高度非一蹴而就。日常的使用中，会使用色轮基本就满足了需求。 Adobe公司色轮，https://color.adobe.com/zh/create/color-wheel/ 统一整齐为美。一个站点，注意以下元素的统一 字体（字号、样式） 颜色 模块（button、table、form） icon 链接 AntDesign：蚂蚁金服的设计指引。 7 Rules for Creating Gorgeous UI :英文版1,2;中文版1,2","tags":[{"name":"design","slug":"design","permalink":"https://zj-john.github.io/tags/design/"}]},{"title":"windows 源路径过长无法删除的问题","date":"2018-03-14T09:35:57.000Z","path":"tips/ckbdbl45500am2ktycrpeo3x1.html","text":"今天在删除一个无用的前端项目目录时，报出：源文件名长度大于文件系统支持的长度 的错误。主要是node_module里边嵌套了多层的node_module的，导致删除文件时报这个错误。 网上搜了一些解决办法的，有些让下特殊软件处理，有的用命令的。自己最终依靠的解决办法是：在要删除的目录上，选择添加到压缩文件，接着选择“压缩后删除原来的文件”。执行后，也许会遇到新的报错，“目录不为空等”，此时用常规的右键-删除 操作一下就可以了。","tags":[{"name":"windows","slug":"windows","permalink":"https://zj-john.github.io/tags/windows/"},{"name":"delete","slug":"delete","permalink":"https://zj-john.github.io/tags/delete/"}]},{"title":"Echarts 宽度设置为100% 不生效","date":"2018-03-13T11:57:05.000Z","path":"tips/ckbdbl45c00az2ktygu6i4c3m.html","text":"Echarts是一款常用的前端图形插件。在使用中，有时会遇到Echarts宽度设置为100%，但并不生效的情况。 此种情况一般发生在，Echarts所在的dom结构在页面初始化的时候处于隐藏状态的情形。例如：123456789101112131415161718192021222324&lt;div&gt; &lt;div className=\"widget-body\"&gt; &lt;ul id=\"myTab\" className=\"nav nav-tabs\"&gt; &lt;li className=\"active\"&gt; &lt;a data-toggle=\"tab\" href=\"#tab1\"&gt; Tab1 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a data-toggle=\"tab\" href=\"#tab2\"&gt; Tab2 &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=\"tab-content padding-header\"&gt; &lt;div className=\"tab-pane active\" id=\"tab1\"&gt; Tab1 Content &lt;/div&gt; &lt;div className=\"tab-pane\" id=\"tab2\"&gt; &lt;Echarts &#123;...this.props&#125; style=&#123;&#123; width:'100%'&#125;&#125;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Echarts是一个显示Echarts图表的Component 在这个例子中,Tab首屏展示的Tab1，Tab2中的Echarts组件在Tab被点击后才显示（但此时已加载）。虽然我们设置了Echarts宽度为100%自适应，但实际使用中会发现当Tab2点击后，Echarts的宽度只有100px，而且也非自适应的。 查其原因，当Echarts处于隐藏中加载时，无法获取其父元素的100%宽度这个值，所以截断了100%为100，宽度就变成了100px。 该怎么解决呢：123456789101112131415161718192021222324252627&lt;div&gt; &lt;div className=\"widget-body\"&gt; &lt;ul id=\"myTab\" className=\"nav nav-tabs\"&gt; &lt;li className=\"active\"&gt; &lt;a data-toggle=\"tab\" href=\"#tab1\"&gt; Tab1 &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a data-toggle=\"tab\" href=\"#tab2\"&gt; Tab2 &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className=\"tab-content padding-header\"&gt; &lt;div className=\"tab-pane active\" id=\"tab1\"&gt; Tab1 Content &lt;/div&gt; &lt;div className=\"tab-pane\" id=\"tab2\"&gt; (currentTabId === 'tab2' ? &lt;Echarts &#123;...this.props&#125; style=&#123;&#123; width:'100%'&#125;&#125;/&gt;: \"\" ) &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 首屏时，先不加载Echarts组件。当Tab2被点击，页面显示之后再加载Echarts。这也是延迟加载的思想，当需要时才加载，减少首屏的渲染时间。 类似于Echarts这样的情况，我在angular中，使用footable时也遇到过，可做相同处理。","tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://zj-john.github.io/tags/Echarts/"},{"name":"footable","slug":"footable","permalink":"https://zj-john.github.io/tags/footable/"}]},{"title":"JS将图片变为字符画","date":"2018-03-07T02:46:27.000Z","path":"projects/ckbdbl46q00dg2ktyyfcyf6hs.html","text":"在刷头条的时候，看到这样一张图片，顺手存了下来。现在用JS来实现一下。 功能：将图片变为用字符组成的画 工具：canvas 难度等级: ★ 项目地址: https://github.com/zj-john/imageToCodeEffect 先上最终工具的地址,有兴趣的可以操作下。 编码之前目标：上传一张图片，导出为图片对应的字符画。如果上传的图片过大，有可能导致生成的字符画过大，难以看到效果，所以还需要对上传的图片调整大小。 分析： 基本的想法是获取图片的每一个像素点，然后转换每个像素点，对应一个字符。 canvas中处理的图片像素包括R,G,B,A四个点，也就是说每一个图片的像素点对应canvas解析结果中的四个值，分别是R（red值），G（green值），B（blue值），A（Alpha透明度值） 拿上图来看，字符画是没有颜色概念的，我们实际处理的是一张灰度图像。所以需要转换rgb图像到灰度图像。 常用的RGB转灰度的算法，参考： 1234567891011// 方法1 心理学公式Gray = R*0.299 + G*0.587 + B*0.114// 方法2Gray = (R*299 + G*587 + B*114 + 500) / 1000Gray = (R*30 + G*59 + B*11 + 50) / 100// 方法3 更快，调节各系数可以调节精度Gray = (R*19595 + G*38469 + B*7472) &gt;&gt; 16// 方法4 Adobe Photoshop中公式，效果好，慢Gray = (R^2.2 * 0.2973 + G^2.2 * 0.6274 + B^2.2 * 0.0753)^(1/2.2)// 方法5 精度最低 效果不好GRAY = (R + G + B)/3 灰度图像中每个像素点只包括RGBA中的A值，我们把A值（0~255）用我们要替代的字符划分区间后，落在区间中的像素值用对应的字符替换，就替换为了字符图。 从上图中，我们看到很重要的部分在于留白，特别是背景的部分。所以对于灰度值最高的像素区间（灰度值最高为255，代表白色），我们用空白（空格）替换。 编码上传图片1234567891011121314151617181920uploadDom.addEventListener('change',handleFileSelect);var reader = new FileReader();function handleFileSelect(evt) &#123; var file = evt.currentTarget.files[0]; reader.onload = function (evt) &#123; var src = evt.target.result; img.src = src; img.onload = function (argument) &#123; // var data = imgDataToCode(this, newWidth.value); // 写到&lt;pre&gt;标签中 result.innerHTML = data; &#125; &#125;; reader.readAsDataURL(file);&#125;; RGB图转灰度图123456// ascii_char是要使用的字符集function rgbToGray(r, g, b) &#123; var gray = parseInt((19595 * r + 38469 * g + 7472 * b) &gt;&gt; 16); var unit = 256.0/ascii_char.length ; return ascii_char[parseInt(gray/unit)];&#125; 把图片转为字符图12345678910111213141516171819202122232425262728293031323334353637383940function imgDataToCode(img, newWidth) &#123; // 根据指定宽度，等比改变图片的大小 const newHeight = parseInt(newWidth * img.height / img.width); canvas.width = newWidth; canvas.height = newHeight; ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, newWidth, newHeight); //读取整张图片的像素 var imgData = ctx.getImageData(0, 0, newWidth, newHeight).data; // 像素值转换为灰度值 var rgbList = []; var txt = \"\"; var i=0; for (; i&lt;imgData.length; i+=4) &#123; //R - 红色（0-255） var red = imgData[i]; // G - 绿色（0-255） var green = imgData[i+1]; // B - 蓝色（0-255） var blue = imgData[i+2]; // alpha 通道（0-255; 0 是透明的，255 是完全可见的） var alpha = imgData[i+3]; rgbList.push(&#123; \"r\" : red, \"g\" : green, \"b\" : blue, &#125;); &#125; var k = 0; for (; k&lt; newHeight; k++) &#123; var j = 0; for(; j &lt; newWidth; j++) &#123; var item = rgbList[k*newWidth + j]; txt += rgbToGray(item.r, item.g, item.b); &#125; txt += '\\n'; &#125; return txt;&#125; 后续 可填写用于填充的字符 有一些色彩比较丰富的图片，增强对比度后再处理 UI 彩色字符图案 参考文档 灰度转换：http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/","tags":[{"name":"canvas","slug":"canvas","permalink":"https://zj-john.github.io/tags/canvas/"},{"name":"image","slug":"image","permalink":"https://zj-john.github.io/tags/image/"},{"name":"js","slug":"js","permalink":"https://zj-john.github.io/tags/js/"},{"name":"code","slug":"code","permalink":"https://zj-john.github.io/tags/code/"}]},{"title":"爬虫爬取房价数据","date":"2018-03-06T03:31:55.000Z","path":"projects/ckbdbl46o00dd2ktysm90y7rm.html","text":"今年考虑买房，想着做点什么，所以爬取了Fang.com的数据…… 但爬取的数据在买房中基本用不上，如果想着依托于各种数据来作分析，那真的需要你有扎实的数据分析基础和对房价市场的了解。不然面对一大堆数据可能也不知从何入手还有可能造成误区。 功能：爬取房价、房型等数据 工具：node, crawler 难度等级: ★ 项目地址: https://github.com/zj-john/houseCrawler 编码之前目标爬取网站所有二手房的数据信息，信息采集需要精确到具体房子的detail页面中，爬取的数据放在本地的数据库中 依赖的包123456789101112// 连接数据库const mysql = require('mysql');// 爬虫const crawler = require(\"crawler\");// 逻辑处理时使用const url = require('url');const moment = require('moment');const _ = require('lodash');const path = require('path');// 给每次的request请求添加user-agent，来伪装成浏览器访问// https://github.com/sindresorhus/ua-string Get the user agent of a recent Chrome version to pretend to be a browser in network requestsconst uaString = require('ua-string'); 编码爬取1234567891011121314151617181920212223242526272829303132333435363738394041// 实例化一个爬虫const c = new crawler(&#123; maxConnections: 1, rateLimit: 5000, // gap 5 sec timeout: 45000, userAgent: uaString&#125;);// 开始爬取，使用listFetcher处理爬取的结果c.queue([ &#123; uri: 'http://esf.sh.fang.com/', callback: listFetcher, city: '上海' &#125;]);const listFetcher = (error, res, done) =&gt; &#123; if(error)&#123; // 错误处理 let export_error = \"URL: \" + res.options.uri + \";Error: \" + error; utils.export_to_file(export_error, \"./error/\" + moment().format(\"YYYY-MM-DDTHH-mm-ss\") + '.txt'); &#125;else&#123; let $ = res.$ // 处理程序 // 使用$像jQuery一样处理dom，获取你需要的数据。 &#125; done();&#125;// Emitted when queue is empty.c.on('drain',function()&#123; console.log('done!');&#125;);// Emitted when crawler is ready to send a request.c.on('request',function(options)&#123; let now = Date(); console.log (`$&#123;now&#125;[request][$&#123;options.city&#125;]$&#123;options.uri&#125;`);&#125;); SQL12345678910db.connect();// 对DB的操作就是执行sql语句db.query('INSERT INTO fangtianxia_old SET ?', data, function (err, rows, fields) &#123; if(err)&#123; console.log('INSERT ERROR - ', err.message); return; &#125; // console.log(\"INSERT SUCCESS\");&#125;);db.end() 后续 针对反爬，检测到获取不到数据（需要输入验证码的页面），记录报错url 爬取完成后，针对报错url进行二次爬取 全部爬取完成后，执行sql导出为excel文件","tags":[{"name":"crawler","slug":"crawler","permalink":"https://zj-john.github.io/tags/crawler/"},{"name":"house","slug":"house","permalink":"https://zj-john.github.io/tags/house/"}]},{"title":"和版本升级有关的npm命令","date":"2018-03-02T04:14:45.000Z","path":"tips/ckbdbl45100af2ktygyoa1rvt.html","text":"开发过程中，不可避免的遇到版本升级的问题。特别是协作的时候，如果忘记了package.json的更新，可能会出现难查的现象或BUG。 npm outdated查看当前目录下，所有插件的当前版本，package.json中的需要版本和该插件的最新版本1npm outdated 结果如下： Current: 当前项目中实际使用的版本 Wanted：package.json中标注的版本 Latest：插件的最新版本 Location: 目录 Package Current Wanted Latest Location react-big-calendar MISSING 0.18.0 0.18.0 myProject babel-eslint 8.2.1 8.2.2 8.2.2 myProject bootstrap 3.3.7 3.3.7 4.0.0 myProject clipboard 1.7.1 1.7.1 2.0.0 myProject copy-webpack-plugin 4.3.1 4.3.1 4.5.0 myProject eslint-config-standard-react 5.0.0 5.0.0 6.0.0 myProject eslint-config-standard 11.0.0-beta.0 11.0.0 11.0.0 myProject eslint-plugin-promise 3.6.0 3.7.0 3.7.0 myProject eslint-plugin-react 7.6.1 7.7.0 7.7.0 myProject eslint 4.16.0 4.18.2 4.18.2 myProject file-loader 1.1.6 1.1.6 1.1.11 myProject react-bootstrap-typeahead 1.4.2 1.4.2 2.5.1 myProject react-router 3.2.0 3.2.1 4.2.0 myProject redux 3.6.0 3.6.0 3.7.2 myProject style-loader 0.20.1 0.20.1 0.20.2 myProject url-loader 0.6.2 0.6.2 1.0.1 myProject webpack-dev-server 2.11.1 2.11.2 3.1.0 myProject webpack 3.10.0 3.11.0 4.1.1 myProject babel-core 6.26.0 linked linked myProject babel-loader 7.1.2 linked linked myProject babel-polyfill 6.26.0 linked linked myProject babel-preset-env 1.6.1 linked linked myProject babel-preset-es2015 6.24.1 linked linked myProject classnames 2.2.5 linked linked myProject npm update按照package.json的版本更新当前插件的版本123npm update// 对单个包升级npm update &lt;name&gt; 可用工具 npm-check手动选择需要更新的包 npm-check-updates根据package.json中的包的规则（^ ~等）自动把包提升到允许的最高版本","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"}]},{"title":"mongo 基础","date":"2018-02-26T07:26:20.000Z","path":"notes/ckbdbl425004g2kty8as91r6o.html","text":"MongoDB学习记录 术语 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 特殊库有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local:这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config:当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 MongoDB区分类型和大小写 常用命令 show dbs显示所有数据的列表 db可以显示当前数据库对象或集合 use DB_NAME连接到一个指定的数据库 如果数据库不存在，则创建数据库，否则切换到指定数据库。 db.DB_NAME.insert({“name”:”菜鸟教程”}) db.dropDatabase() 删除当前数据库 show tables展示集合 db.COLLECTION_NAME.drop()删除集合 db.COLLECTION_NAME.insert(document) db.COLLECTION_NAME.find() db.COLLECTION_NAME.save(document)如果不指定_id 字段 save() 方法类似于 insert() 方法,如果指定_id 字段，则会更新该_id 的数据。 db.COLLECTION_NAME.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}},{multi:true})更新、muti:true 更新多条 db.col.remove({‘title’:’MongoDB 教程’}) db.COLLECTION_NAME.ensureIndex({KEY:1})创建索引：语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可 mongo mongo_address:55944/db_name -u “username” -p “password”连接数据库","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://zj-john.github.io/tags/MongoDB/"}]},{"title":"setState Cannot update during an existing state transition","date":"2018-02-24T02:38:54.000Z","path":"tips/ckbdbl45700ap2ktyt72r3oex.html","text":"问题：setState Cannot update during an existing state transition React中，render时是不能进行props或者state的更改的，否则就会报上述错误。原因是React中，props或state的变化是可以监听到并重新render的，那如果render中，props或者state再更改，就产生了一个render死循环。 产生这个问题的原因，除了render中显示更改props或者state的值之外，更多的可能是不小心触发了更改。最常见的场景如下： 1234567&lt;Button onClick=&#123;doSomeAction(&apos;param&apos;)&#125;&gt;Test&lt;/Button&gt;doSomeAction (param) =&gt; &#123; this.setState(&#123; ... &#125;);&#125; 这种写法看起来没什么问题，但是会触发上述报错。看下正确的写法：1&lt;Button onClick=&#123;() =&gt; doSomeAction(&apos;param&apos;)&#125;&gt;Test&lt;/Button&gt; 错误的写法在render时，直接执行了doSomeAction这个函数，触发了state的改变；正确的写法把它封装了一层，表示这是一个等待触发的函数。 但是以下方式是可以的：1&lt;Button onClick=&#123;doSomeAction()&#125;&gt;Test&lt;/Button&gt; 即不加参数的函数时可以直接写的。","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"}]},{"title":"CMD参数","date":"2018-02-23T12:01:39.000Z","path":"tips/ckbdbl44z00a92kty9cf0k8bw.html","text":"问题： CMD参数 这个问题的由来是我有一个计划任务，里面使用cmd执行一个node程序。过两天发现任务没执行，排障的时候，运行计划任务脚本，cmd一闪而退，看不到具体的报错。12// 查看语法C:\\Windows\\system32&gt;cmd /? BasicCMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF] [[/S] [/C | /K] string] /C 执行字符串指定的命令然后终止，执行完后关闭命令窗口 /K 执行字符串指定的命令但保留，不关闭窗口 /S 修改 /C 或 /K 之后的字符串处理(见下) /Q 关闭回显 /D 禁止从注册表执行 AutoRun 命令(见下) /A 使向管道或文件的内部命令输出成为 ANSI /U 使向管道或文件的内部命令输出成为 Unicode /T:fg 设置前台/背景颜色(详细信息见 COLOR /?) /E:ON 启用命令扩展(见下) /E:OFF 禁用命令扩展(见下) /F:ON 启用文件和目录名完成字符(见下) /F:OFF 禁用文件和目录名完成字符(见下) /V:ON 使用 ! 作为分隔符启用延迟的环境变量扩展。例如，/V:ON 会允许 !var! 在执行时扩展变量 var。var 语法会在输入时扩展变量，这与在一个 FOR循环内不同。 /V:OFF 禁用延迟的环境扩展。 注意，如果字符串加有引号，可以接受用命令分隔符”&amp;&amp;”分隔多个命令。另外，由于兼容性原因，/X 与 /E:ON 相同，/Y 与 /E:OFF 相同，且 /R 与/C 相同。任何其他开关都将被忽略。 /C 和 /K如果指定了 /C 或 /K，则会将该开关之后的命令行的剩余部分作为一个命令行处理，其中，会使用下列逻辑处理引号(“)字符: 如果符合下列所有条件，则会保留命令行上的引号字符: - 不带 /S 开关 - 正好两个引号字符 - 在两个引号字符之间无任何特殊字符，特殊字符指下列字符: &amp;&lt;&gt;()@^| - 在两个引号字符之间至少有一个空格字符 - 在两个引号字符之间的字符串是某个可执行文件的名称。 否则，老办法是看第一个字符是否是引号字符，如果是，则去掉首字符并删除命令行上最后一个引号，保留最后一个引号之后的所有文本。 /D如果 /D 未在命令行上被指定，当 CMD.EXE 开始时，它会寻找以下REG_SZ/REG_EXPAND_SZ 注册表变量。如果其中一个或两个都存在，这两个变量会先被执行。 HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\AutoRun 和/或 HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\AutoRun 命令扩展是按默认值启用的。您也可以使用 /E:OFF ，为某一特定调用而停用扩展。您可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有调用的扩展，这要通过设置使用REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\EnableExtensions 和/或 HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\EnableExtensions 到 0x1 或 0x0。用户特定设置比机器设置有优先权。命令行开关比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEEXTENSIONS 或 DISABLEEXTENSIONS 参数比 /E:ON 或 /E:OFF 开关有优先权。请参阅 SETLOCAL /? 获取详细信息。 命令扩展包括对下列命令所做的更改和/或添加: DEL or ERASE COLOR CD or CHDIR MD or MKDIR PROMPT PUSHD POPD SET SETLOCAL ENDLOCAL IF FOR CALL SHIFT GOTO START (同时包括对外部命令调用所做的更改) ASSOC FTYPE 有关特定详细信息，请键入 commandname /? 查看。 延迟环境变量扩展不按默认值启用。您可以用/V:ON 或 /V:OFF 开关，为 CMD.EXE 的某个调用而启用或停用延迟环境变量扩展。您可以在机器上和/或用户登录会话上启用或停用 CMD.EXE 所有调用的延迟扩展，这要通过设置使用REGEDIT.EXE 的注册表中的一个或两个 REG_DWORD 值: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\DelayedExpansion 和/或 HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\DelayedExpansion 到 0x1 或 0x0。用户特定设置比机器设置有优先权。命令行开关比注册表设置有优先权。 在批处理文件中，SETLOCAL ENABLEDELAYEDEXPANSION 或DISABLEDELAYEDEXPANSION参数比 /V:ON 或 /V:OFF 开关有优先权。请参阅 SETLOCAL /?获取详细信息。 如果延迟环境变量扩展被启用，惊叹号字符可在执行时间被用来代替一个环境变量的数值。 您可以用 /F:ON 或 /F:OFF 开关为 CMD.EXE 的某个调用而启用或禁用文件名完成。您可以在计算上和/或用户登录会话上启用或禁用 CMD.EXE 所有调用的完成，这可以通过使用 REGEDIT.EXE 设置注册表中的下列REG_DWORD 的全部或其中之一: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\CompletionChar HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\PathCompletionChar 和/或 HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\CompletionChar HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\PathCompletionChar 由一个控制字符的十六进制值作为一个特定参数(例如，0x4是Ctrl-D，0x6 是 Ctrl-F)。用户特定设置优先于机器设置。命令行开关优先于注册表设置。 如果完成是用 /F:ON 开关启用的，两个要使用的控制符是:目录名完成用 Ctrl-D，文件名完成用 Ctrl-F。要停用注册表中的某个字符，请用空格(0x20)的数值，因为此字符不是控制字符。 如果键入两个控制字符中的一个，完成会被调用。完成功能将路径字符串带到光标的左边，如果没有通配符，将通配符附加到左边，并建立相符的路径列表。然后，显示第一个相符的路径。如果没有相符的路径，则发出嘟嘟声，不影响显示。之后，重复按同一个控制字符会循环显示相符路径的列表。将 Shift键跟控制字符同时按下，会倒着显示列表。如果对该行进行了任何编辑，并再次按下控制字符，保存的相符路径的列表会被丢弃，新的会被生成。如果在文件和目录名完成之间切换，会发生同样现象。两个控制字符之间的唯一区别是文件完成字符符合文件和目录名，而目录完成字符只符合目录名。如果文件完成被用于内置式目录命令(CD、MD 或 RD)，就会使用目录完成。用引号将相符路径括起来，完成代码可以正确处理含有空格或其他特殊字符的文件名。同时，如果备份，然后从行内调用文件完成，完成被调用时位于光标右方的文字会被调用。 需要引号的特殊字符是: ()[]{}^=;!'+,`~(&() 解决方法所以针对上文提到的问题，在命令行前加一个/K参数就可以解决了，别忘了解决后再改回/C","tags":[{"name":"cmd","slug":"cmd","permalink":"https://zj-john.github.io/tags/cmd/"}]},{"title":"node 判断运行环境","date":"2018-02-22T11:49:51.000Z","path":"tips/ckbdbl44u009y2ktyzkwfbknh.html","text":"问题： node 判断运行环境 node中判断运行的环境，可以使用OS包或者process包的以下命令。12os.platform();process.platform; 可用的取值有： linux win32: For Windows darwin: For OSX aix: IBM基于AT&amp;T Unix System V开发的一套类UNIX操作系统 freebsd: 类UNIX操作系统 openbsd: 类UNIX操作系统 sunos android: 这个取值目前在实验阶段","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"os","slug":"os","permalink":"https://zj-john.github.io/tags/os/"}]},{"title":"狗年快乐","date":"2018-02-15T16:00:00.000Z","path":"projects/ckbdbl46j00d42ktyyvijqnv0.html","text":"狗年快乐 祝大家新年快乐，身体健康，阖家欢乐~ 新的一年，我会继续记录自己的学习之路，希望大家多多支持","tags":[{"name":"github","slug":"github","permalink":"https://zj-john.github.io/tags/github/"},{"name":"zj","slug":"zj","permalink":"https://zj-john.github.io/tags/zj/"}]},{"title":"datatable 一些易混淆options说明","date":"2018-02-07T12:28:42.000Z","path":"tips/ckbdbl45000ab2ktyy7o6wi1a.html","text":"问题： datatable 一些易混淆options说明 解决方案加载 language.loadingRecords When using Ajax sourced data and during the first draw when DataTables is gathering the data, this message is shown in an empty row in the table to indicate to the end user the the data is being loaded. Note that this parameter is not used when loading data by server-side processing, just Ajax sourced data with client-side processing. language.processing Text that is displayed when the table is processing a user action (usually a sort command or similar). 空数据 language.zeroRecords Text shown inside the table records when the is no information to be displayed after filtering.Note that language.emptyTable is shown when there is simply no information in the table at all (regardless of filtering), while this parameter is used for when the table is empty due to filtering. language.emptyTable This string is shown in preference to language.zeroRecords when the table is empty of data (regardless of filtering) - i.e. there are zero records in the table.Note that this is an optional parameter. If it is not given, the value of language.zeroRecords will be used instead (either the default or given value). 信息展示 lengthChange [boolean] When pagination is enabled, this option will control the display of an option for the end user to change number of records to be shown per page. The options shown in the list are controlled by the lengthMenu configuration option. info [boolean] When this option is enabled, Datatables will show information about the table including information about filtered data if that action is being performed. This option allows that feature to be enabled or disabled. Note that by default the information display is shown below the table on the left, but this can be controlled using dom and CSS) paging [boolean] DataTables can split the rows in tables into individual pages, which is an efficient method of showing a large number of records in a small space. The end user is provided with controls to request the display of different data as the navigate through the data. This feature is enabled by default, but if you wish to disable it, you may do so with this parameter. searching [boolean] This option allows the search abilities of DataTables to be enabled or disabled. Searching in DataTables is “smart” in that it allows the end user to input multiple words (space separated) and will match a row containing those words, even if not in the order that was specified (this allow matching across multiple columns).","tags":[{"name":"object","slug":"object","permalink":"https://zj-john.github.io/tags/object/"},{"name":"deep copy","slug":"deep-copy","permalink":"https://zj-john.github.io/tags/deep-copy/"}]},{"title":"object deep copy","date":"2018-02-05T07:27:04.000Z","path":"tips/ckbdbl44y00a72ktyftqd3bch.html","text":"问题： object deep copy 一般来说，object变量的copy和引用都是基于内存地址的浅拷贝，不注意的话很容易出现问题。此时深拷贝就很必要。本文列举下深拷贝的几种方法： 解决方案原生1JSON.parse(JSON.stringify(obj)) 此种方法有个问题，如果object中某个key对应的值是函数或者undefined，则转换后会丢失该key。 JQuery12345// Shallow copyvar newObject = jQuery.extend(&#123;&#125;, oldObject);// Deep copyvar newObject = jQuery.extend(true, &#123;&#125;, oldObject); LodashcloneDeep12345var objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;];var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);// =&gt; false","tags":[{"name":"object","slug":"object","permalink":"https://zj-john.github.io/tags/object/"},{"name":"deep copy","slug":"deep-copy","permalink":"https://zj-john.github.io/tags/deep-copy/"}]},{"title":"发布自己的npm包","date":"2018-01-29T06:13:24.000Z","path":"notes/ckbdbl42w00602kty7s6nt52t.html","text":"本文记录下如何发布一个自己的NPM包。 前提阅读以下内容前，请先确保以下2个条件： 环境依赖：依赖npm，所以需要已安装node.js。 外部依赖：要发布的项目已经托管在公网的GitHub上，本地有对应的开发目录，假设为Test文件夹 1.注册NPM账号注册地址注册成功后，在Test文件下运行以下命令： npm 账户关联是全局的，并不限制在当前文件夹下使用 1234npm adduserUsername: your namePassword: your passwordEmail: your email 执行成功后，则本地目录和npm账号已绑定关联。 使用npm whoami查看当前关联账户，使用npm login来重新登录 2.发布npm包重新审视下Test文件夹下的package.json文件，重点查看以下内容： name: 发布的npm包名称不允许重复，所以发布前在npm网站中搜索下相同名称的包是否存在。已存在则修改下名称 version: 是否是一个恰当的版本来标识本次发布的内容 版本号：a.b.c。a是大版本号，用于当你做了不能向下兼容的修改时指定；b是次版本号，用于当你做了向下兼容的功能性新增时指定；c是修订号，用于当你做了向下兼容的问题修正时指定.可以使用npm version来指定版本，等同于修改package.json文件 repository: 是否是你正确的GitHub项目地址 以上内容都确认无误，在Test文件夹下执行：1npm publish 命令成功，则npm发布完成。 Publish时报以下报错的解决办法： You do not have permission to publish verified email required 后续 开发：自己发布npm包后，在本地调试的方法是使用npm link做好关联，详见文档。 持续集成：npm集成了travis，来在发布时测试你代码的可用性。详见阮大文档","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"}]},{"title":"使用了babel但报错object.assign is not a function","date":"2018-01-26T03:27:44.000Z","path":"tips/ckbdbl44t009v2ktyu07f5vfh.html","text":"问题： babel不转换object.assign方法 react中用到object.assign，虽然安装了babel，但是webpack打包后还是在浏览器报object.assign is not a function。 解决方案object.assign是ES6的中的方法，按照原先的理解，我安装了babel之后，应该就可以把ES6的语法转换掉。但是在babel中测试,发现确实object.assign不会做任何转换。 查了下，阮大神的解释最为透彻 引用如下：Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个polyfill。 1npm install --save babel-polyfill 1import &apos;babel-polyfill&apos;; 以下文件中的方法是babel不转换的，需要polyfill来帮助babel-plugin-transform-runtime babel-polyfill includes a custom regenerator runtime and core-js. 所以直接使用core-js也可以达到相同的转换效果","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"babel","slug":"babel","permalink":"https://zj-john.github.io/tags/babel/"}]},{"title":"使用datatable插件，一次点击发送两次请求","date":"2018-01-25T03:12:49.000Z","path":"tips/ckbdbl44v00a22ktyz4l0v895.html","text":"问题： 使用datatable插件，一次点击发送两次请求 场景是通过form改变查询条件，然后使用datatable插件，通过向后端请求url的方式获取数据，并且开启serverSide模式。问题是会出现一次form提交触发两次对后端接口的请求,而且两次请求有差异，最终导致展示的数据不正确。react中写法如下，1234567891011componentWillUpdate(nextProps) &#123; ...... if (needUpdate) &#123; let element = $(this.refs.table); if ($.fn.DataTable.isDataTable(element)) &#123; element.dataTable().fnClearTable(); element.dataTable().fnDestroy(); &#125; this.datatable(element, nextProps); &#125;&#125; 解决方案查下来，首先排除了form上的问题，定位在datatable这个组件上。最终的解决方法是：1234567891011componentWillUpdate(nextProps) &#123; ...... if (needUpdate) &#123; let element = $(this.refs.table); if ($.fn.DataTable.isDataTable(element)) &#123; // element.dataTable().fnClearTable(); element.dataTable().fnDestroy(); &#125; this.datatable(element, nextProps); &#125;&#125; 去掉了fnClearTable的调用，在datatable上看文档)说明如下： This method should not be used when serverSide is enabled. When server-side processing is enabled, the data should be deleted from the data store (i.e. an Ajax request to the server) and then draw() called. Deleting the client-side data will have no effect when server-side processing is enabled since the data would simply be restored on the next draw if the data is not removed from the server. 也就是在serverSide模式下，应该不使用fnClearTable方法，那么fnClearTable这个方法是否会向后端发起一个新请求来delete数据，导致两个请求发出，到达的顺序导致页面显示时好时坏，还得进一步查一查。","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"datatable","slug":"datatable","permalink":"https://zj-john.github.io/tags/datatable/"},{"name":"serverSide","slug":"serverSide","permalink":"https://zj-john.github.io/tags/serverSide/"}]},{"title":"webpack不生成map文件","date":"2018-01-24T02:51:03.000Z","path":"tips/ckbdbl44w00a42kty87f1rhaj.html","text":"问题： webpack不生成map文件 webpack中开启了map映射，但是打包一直没有map文件。经检查webpack的配置都没有问题，那为什么没有生成对应的map文件呢？ 解决方案最终找到的原因是使用uglifyjs-webpack-plugin这个插件导致的。在webpack的devtool文档中，有一块不起眼的小字。 When using the uglifyjs-webpack-plugin you must provide the sourceMap: true option to enable SourceMap support. 也就是当使用了uglifyjs-webpack-plugin 插件时，sourceMap这个值的默认值是false，不开启map。如果要启用map，需要在插件中配置sourceMap值为true。1234567new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, drop_console: true &#125;, sourceMap: true&#125;) 还有一点要注意，在uglifyjs-webpack-plugin的文档中指出： Use source maps to map error message locations to modules (This slows down the compilation) ⚠️ cheap-source-map options don’t work with this plugin 使用uglifyjs-webpack-plugin了之后，devtool中就不能使用cheap-source-map这个配置了。","tags":[{"name":"map","slug":"map","permalink":"https://zj-john.github.io/tags/map/"},{"name":"webpack","slug":"webpack","permalink":"https://zj-john.github.io/tags/webpack/"},{"name":"uglifyjs-webpack-plugin","slug":"uglifyjs-webpack-plugin","permalink":"https://zj-john.github.io/tags/uglifyjs-webpack-plugin/"}]},{"title":"react接入sentry","date":"2018-01-22T11:36:14.000Z","path":"tips/ckbdbl44n009n2ktyy3df6crq.html","text":"问题： react接入sentry 为了收集前端的报错，准备接入sentry系统。选择sentry的原因，首先这是是一款成熟的错误日志收集框架，支持多种语言以及细化的框架，比如支持JavaScript，也支持AngularJS、React、Vue等。另一个原因则部门已经有一些其它语言，如Python在使用这个平台。 具体操作如下： 解决方案sentry配置 Sentry网站上注册后新建一个Project。这里选择React框架，创建后会给你你的项目的客户端秘钥（DSN） 在React项目里安装raven 1npm install raven-js --save 项目中配置,config中的内容是第一步注册Project后得到的那个秘钥 12import Raven from &apos;raven-js&apos;;Raven.config(&apos;http://adagasdgasdgasdgas@sentry.com/10&apos;).install(); 这两句代码放的位置可以随意，我推荐放在你项目的config.js中或入口文件，保证在执行其它catch语句前先执行install即可。放在config中，你可以根据相关配置（host、port）来决定什么环境再install，一般推荐生产环境再开启sentry。 执行到这里，sentry的配置部分就完成了，现在看具体使用。 sentry使用 请先升级react版本到16或16以后（包含react和react-dom两个组件都要升级到v16） react16发布了新功能，可以使用componentDidCatch方法很轻易的获取react中error。 在具体的component中,按照如下方法即可把此component中的报错捕捉后发给sentry。 123456789101112131415import Raven from 'raven-js';export default class Test extends React.Component &#123; constructor (props) &#123; super(props); &#125; componentDidCatch(error, errorInfo) &#123; Raven.captureException(error, &#123; extra: errorInfo &#125;); &#125; render() &#123; &#125;&#125; 目前看，只要在最外层的component上catch就可以把其内部使用的各个组件的error也catch住。具体还要再测试下。 sentry优化react一般使用webpack打包压缩，压缩后的报错文件可读性差，所以需要额外在sentry中配置map的文件。","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"sentry","slug":"sentry","permalink":"https://zj-john.github.io/tags/sentry/"}]},{"title":"react-datatable-jq 组件","date":"2018-01-19T04:20:23.000Z","path":"projects/ckbdbl46l00d82kty0771vjud.html","text":"功能：react-datatable-jq npm包 工具：react, datatable 难度等级: ★★ 项目地址: https://github.com/zj-john/react-datatables react-datatablesDatatable components built with React Install1npm install react-datatable-jq --save Usage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import React from 'react';// import react-datatable-jqimport Datatable from 'react-datatable-jq'// datatable global options. You can import it from your config.jsconst options = &#123; dom: \"&lt;'dt-toolbar'&lt;'col-xs-12 col-sm-6'f&gt;&lt;'col-sm-6 col-xs-12 hidden-xs text-right'l&gt;r&gt;\" + \"t\" + \"&lt;'dt-toolbar-footer'&lt;'col-sm-6 col-xs-12 hidden-xs'i&gt;&lt;'col-xs-12 col-sm-6'p&gt;&gt;\", autoWidth: false, searching: false, paging: true, language: &#123; search: \"&lt;span class='input-group-addon input-sm'&gt;&lt;i class='glyphicon glyphicon-search'&gt;&lt;/i&gt;&lt;/span&gt; \", lengthMenu: \"每页显示 _MENU_ 条记录\", info: \"&lt;b&gt;从_START_到_END_ / 共_TOTAL_条记录&lt;/b&gt;\", infoEmpty: \"显示0条记录\", emptyTable: \"没有符合条件的记录\", zeroRecords: \"没有符合条件的记录\", loadingRecords: \"加载中...\", processing: \"处理中...\", paginate: &#123; \"first\": \"&lt;b&gt;首页&lt;/b&gt;\", \"previous\": \"&lt;b&gt;上一页&lt;/b&gt;\", \"next\": \"&lt;b&gt;下一页&lt;/b&gt;\", \"last\": \"&lt;b&gt;尾页&lt;/b&gt;\" &#125; &#125;&#125;class BasicDatatable extends React.Component &#123; constructor(props) &#123; super(props); // change the default options or add new option options.ording = false; this.options = options; // the events list on datatable this.events = [&#123; type: \"click\", scope: \"tbody tr td\", func: function() &#123; console.log(\"a test\"); &#125; &#125;]; // the columns for the datatable this.columns = [&#123; data: 'id', title: 'ID', &#125;, &#123; data: 'name', title: 'Name', orderable: false &#125;, &#123; data: 'sex', title: 'Sex', render: function(data, full) &#123; return data.toUpperCase() === 'M' ? \"Boy\": \"Girl\"; &#125;, orderable: false &#125;, &#123; data: null, title: 'Menu', className: \"menu\", orderable: false, createdCell: function(td, cellData, rowData, row, col) &#123; $(td).on('click', '.action', function() &#123; console.log(\"you click the action dom\"); &#125;); &#125; &#125;] // dtData 负责 datatable data的部分 this.state = &#123; DTdata: null, &#125; &#125; componentWillMount() &#123; let url = \"/api/basic/ajax\", postData = &#123; \"range\": \"all\" &#125;, dtData = &#123; _method: \"ajax\", url: url, data: function(d) &#123; $.extend(d, postData); return JSON.stringify(d); &#125;, type: \"post\", contentType: \"application/json; charset=utf-8\", dataSrc: \"data\" &#125;; this.setState(&#123; dtData: dtData, &#125;) &#125; render() &#123; // theme: one of [\"bootstrap\", \"bootstrap4\", \"foundation\", \"jqueryui\", \"material\", \"semanticui\", \"uikit\"], default JqueryDatatable return ( &lt;div&gt; this is sample： &lt;Datatable theme = &#123;\"bootstrap\"&#125; options = &#123;this.options&#125; dtData = &#123;this.state.dtData&#125; columns = &#123;this.columns&#125; events = &#123;this.events&#125; className = \"table table-striped table-hover\" id = \"sample_table\" /&gt; &lt;/div &gt; ); &#125;&#125; Propstheme根据不同框架，可以选择不同主题的datatable样式，可选theme如下： bootstrap bootstrap4 foundation jqueryui material semanticui uikit theme为空时，将选择默认的jQuery Datatable的样式。 选择不同主题的datatable时，请记得把框架本身的js和css导入。例如选择bootstrap样式时，需要同时引用bootstrap.css，bootstrap.js文件来辅助样式 optionsoptions中支持除ajax和data之外的datatable options中的取值，具体可选取值请参考以下地址datatable options 因为考虑到datatable中数据的变化，所以把和数据相关的ajax和data属性合为dtData这个props，这样在react组件中使用和判断变化时会比较方便。 dtDatadtData代表了datatable中取值的方式，有以下4种： ajax通过ajax的方式传输，可以定义各种参数和处理方法，配合option可以实现后端分页。1234567891011121314151617dtData = &#123; // 标识 method 为ajax _method: \"ajax\", // 请求的url url: url, // 对request data的处理 data: function (d) &#123; $.extend(d, postData); return JSON.stringify(d); &#125;, // 请求的方法 type: \"post\", // contentType contentType: \"application/json; charset=utf-8\", // 对response data的处理 dataSrc: \"data\"&#125; 更多的用法可以参考JQuery ajax. data直接给datatable传输数据。123456789101112dtData = &#123; // 标识 method 为 data _method: \"data\", // 数据 data: [ &#123; \"id\": 0, \"name\": \"john\", \"sex\": \"M\" &#125; ]&#125; url简易的ajax方式，只需要传输一个url，默认get方法传输。123456dtData = &#123; // 标识 method 为 url _method: \"url\", // 数据 url: \"/api/data.json\"&#125; func更自由的处理方式，参考Datatable ajax12345678910dtData = &#123; // 标识 method 为 url _method: \"function\", // 数据 func: function (data, callback, settings) &#123; callback( JSON.parse( localStorage.getItem('dataTablesData') ) ); &#125;&#125; columns提供Datatable的列信息，使用参考Datatable columns events绑定在Datatable中的事件，使用方法如下：12345678910[ &#123; // 事件类型 \"type\": \"click\", // 事件触发的元素 \"scope\": \"tbody tr td\", // 处理函数 \"func\": function()&#123;&#125; &#125;] className提供组件DOM的Class。 id提供组件DOM的ID。 插件中识别组件的方法是 先判断是否有ID，再判断是否有className，两者都没有就使用”table:eq(0)”来获取。建议给每一个table加ID。 hasCheckOptionsChange取值为布尔型，为true则在判断组件更新时，对options 这个props的值也进行判断，如果options的值变化，组件也会更新。默认取值false hasOptimizeDisplay取值为布尔型，为true则在渲染组件时进行一些效果优化，比如dtData类型为data时，判断data的长度，小于10则不显示页码按钮等。默认取值false","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"datatable","slug":"datatable","permalink":"https://zj-john.github.io/tags/datatable/"}]},{"title":"npm link 时各种Error","date":"2018-01-18T04:29:01.000Z","path":"tips/ckbdbl44m009k2ktyi6c9qcu5.html","text":"问题：npm link 时各种Error 开发npm包时，肯定会用到npm link功能。npm link可以让你在本地直接使用开发中的npm包，并且同步更新。 使用方法： 假如你开发的包的名字是test（package.json中的name对应的字段），然后有一个example目录，用来测试test的功能。 在你开发的npm包的根目录下（有package.json的目录），命令行执行1npm link 这一步执行成功后，把test包连接到npm的全局模式下 在example根目录下（同样有package.json文件的目录），命令行执行1npm link test 这一步执行成功后，你把全局的test包链接到了你本地目录下。这样在的你的example中可以直接import test包，而且npm包开发目录下的变动会同步反映到example下。 执行成功当然是最好的，但是执行时难免会遇到各种报错。 解决方案执行过程中遇到了不少问题，no permission之类的，尝试了不少方法，最终解决是执行了以下几步： 关闭打开此目录的IDE 删除 node_module 目录 删除package-lock.json 文件 执行需要的命令","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"},{"name":"permission","slug":"permission","permalink":"https://zj-john.github.io/tags/permission/"}]},{"title":"angular 关闭hash url","date":"2018-01-17T06:03:01.000Z","path":"tips/ckbdbl44o009q2kty84zum67b.html","text":"问题：angular 关闭hash url 未配置的angular1中route路由（用的是$stateProvider）是使用hash路由的，也就是使用http://localhost/#/index 这种方式来访问。如果要恢复http://localhost/index 这种方式的话，做法如下 解决方案 第一步：启用HTML5Mode 123app.config([\"$locationProvider\", function($locationProvider) &#123; $locationProvider.html5Mode(true);&#125;]); 第二步：在入口html文件中设置Root URL 12345&lt;head&gt; ... &lt;base href=\"/\"&gt; ...&lt;/head&gt;","tags":[{"name":"angular","slug":"angular","permalink":"https://zj-john.github.io/tags/angular/"},{"name":"hash","slug":"hash","permalink":"https://zj-john.github.io/tags/hash/"},{"name":"route","slug":"route","permalink":"https://zj-john.github.io/tags/route/"}]},{"title":"Chrome devtools-Security面板","date":"2018-01-15T06:43:47.000Z","path":"notes/ckbdbl40u00202ktyeonw1ba8.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Security面板的具体用法。 官方教程 Security面板使用安全面板调试混合内容问题，证书问题等等。 包含以下功能： 使用 Security Overview 可以立即查看当前页面是否安全。 检查各个源以查看连接和证书详情（安全源）或找出具体哪些请求未受保护（非安全源）。 Security Overview安全站点： 不安全站点： 如果请求的页面通过 HTTP 提供，则主源会被标记为不安全 如果请求的页面通过 HTTPS 检索，但页面会继续使用 HTTP 检索其他源的内容，然后页面仍然会被标记为不安全。这称为混合内容页面 检查源 点击安全源查看该源的连接和证书详情。 点击非安全源，Security 面板会提供 Network 面板过滤视图的链接","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"npm publish 报错：You do not have permission to publish","date":"2018-01-11T04:23:42.000Z","path":"tips/ckbdbl44f00962ktygwl11t9l.html","text":"问题：npm publish 报错：You do not have permission to publish 发布自己的npm包时，执行npm publish有时候会报错123npm ERR! publish Failed PUT 403npm ERR! code E403npm ERR! You do not have permission to publish &quot;***&quot;. Are you logged in as the correct user? 解决方案这个比较简单了，我自己都觉得这篇就是凑数的…… hava permission 没有权限，说明你发布的这个包在npm上已经被注册过了，你需要在package.json中改个名字。","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"},{"name":"permission","slug":"permission","permalink":"https://zj-john.github.io/tags/permission/"}]},{"title":"npm publish 报错：verified email required","date":"2018-01-10T03:50:37.000Z","path":"tips/ckbdbl44k009g2ktyvmwamdva.html","text":"问题：npm publish 报错：verified email required 发布自己的npm包时，执行npm publish有时候会报错,123npm ERR! publish Failed PUT 403npm ERR! code E403npm ERR! you must verify your email before publishing a new package: https://www.npmjs.com/email-edit : react-datatable-jq 解决方案官方教程 npm要求开发者提供了一个有效的电子邮件地址，并且在每次发布新的NPM包之前，需要验证你的电子邮件。 大概翻译如下： 原因主要是为了防止垃圾邮件恶意批量注册和发布。 操作当收到以上报错时： 打开npm的官网 登录 看到以下图片所示banner 点击上图红字部分”send it again”，来发送一封验证邮件 打开你的注册邮箱，找到验证邮件，点击邮件中的链接，确认验证 如果需要更换注册邮箱，请在email edit地址修改","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"},{"name":"email","slug":"email","permalink":"https://zj-john.github.io/tags/email/"},{"name":"verified","slug":"verified","permalink":"https://zj-john.github.io/tags/verified/"}]},{"title":"Chrome devtools-Application面板","date":"2018-01-09T10:04:47.000Z","path":"notes/ckbdbl401000n2ktyyg48823z.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Application面板的具体用法。 官方教程 Application面板此面板检查加载的所有资源，包括IndexedDB与Web SQL数据库，本地和会话存储，cookie，应用程序缓存。 包含以下功能： 查看和修改本地存储与会话存储。 检查和修改 IndexedDB 数据库。 对 Web SQL 数据库执行语句。 查看应用缓存和服务工作线程缓存。 点击一次按钮即可清除所有存储、数据库、缓存和服务工作线程。 本地存储Storage -&gt; Local Storage 以键值对（KVP）存储 可以执行： 修改：双击 新增：空白处双击 删除：X 按钮 清空：Clear All 刷新 Session存储Storage -&gt; Session Storage 以键值对（KVP）存储，操作同本地存储 IndexedDBStorage -&gt; IndexedDB 以KVP存储的数据库，不支持新建库，支持数据的增删查改 Web SQLWeb SQL Database规范已经被废弃 Storage -&gt; Web SQL Web SQL 数据库, 不支持值更新，支持使用sql语句查询。 W3C教程 应用缓存Cache -&gt; Application Cache Type: Master:资源上指示此缓存为其主文件的 manifest 属性。 Explicit:此资源在清单中明确列出。 Network:指定此资源的清单必须来自网络。 Fallback:Resource 列中的网址作为另一个网址（未在 DevTools 中显示）的回退网址形式列出。 状态： IDLE：缓存没有新更改。 CHECKING：正在提取清单并检查有无更新。 DOWNLOADING：正在将资源添加到缓存中。 UPDATEREADY：存在新版本的缓存。 OBSOLETE：正在删除缓存。 服务工作线程缓存Cache -&gt; Cache Storage 清除服务工作线程、存储、数据库和缓存Application -&gt; Clear Storage 选择性的注销服务工作线程、存储和缓存","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"react中import css文件全局污染","date":"2018-01-09T03:27:30.000Z","path":"tips/ckbdbl44j009d2ktyf88owxte.html","text":"问题：react中import css文件全局污染 react中利用webpack打包，可以把css作为一个model导入到文件中，方式如下：1import &apos;./TestModel.css&apos; 不过这种方式进来的css文件实际上是在渲染的时候，给对应的html中添加了一个内嵌样式&lt;style&gt;,那么如果一个html是由多个component组成，而每个component中都import了一个css文件，那么这个html文件在实际加载时，就会把多个component中的CSS文件作为&lt;style&gt;同时加载，这么一来就把这些CSS的作用域放大化了，就会造成样式污染。 解决方案参考腾讯团队的这篇文章 一般做法： 加个父元素的选择器，限制范围 Class的名称复杂一些，降低冲突概率（主要是和外部引用插件之间的冲突） 保证所有CSS不重名，copy的文件先重命名…… 命名约定这种方式大概最容易想到，既然CSS变为全局化，那么直接把它们写在一个文件中就可以了。如果真的写在了一个文件中，那么怎么区分各个部分呢，就要依靠一个规范化的命名约定。 CSS应该如何组织和命名，可以参考BEM,更多信息可以搜索 OOCSS（面向对象CSS），SMACSS，SMACSS，SUITCSS 缺点： JS CSS之间没有打通(复杂组件使用JS和CSS共同处理样式，无法打通造成冗余) 命名复杂化 JS中直接使用style抛弃CSS文件，直接在JS中定义style的object对象，然后内联方式使用。 缺点： 无法使用伪类 样式会大量重复 不能使用stylus、sass等成熟的预处理器 JS管理模块最常用CSS Modules，可以依托于构建工具使用，比如webpack。 webpack中使用方法：webpack.config1234567891011121314&#123; test: /\\.css$/, use: [ &#123; loader: 'css-loader', options: &#123; // 启用 modules: true, // 最终生成的样式 localIdentName: '[name]__[local]--[hash:base64:5]' &#125; &#125; ]&#125; 语法 :local(.className) 可以被用来在局部作用域中声明 className。局部的作用域标识符会以模块形式暴露出去(即使用时需要导入各个模块)。 使用 :local（无括号）可以为此选择器启用局部模式。:global(.className) 可以用来声明一个明确的全局选择器。使用:global（无括号）可以将此选择器切换至全局模式。 loader 会用唯一的标识符(identifier)来替换局部选择器。所选择的唯一标识符以模块形式暴露出去。 demo.css123456.normal &#123; color: green;&#125;:local(.className) &#123; background: red; &#125;:local(.className .subClass) &#123; color: green; &#125;:local .className .subClass :global(.global-class-name) &#123; color: blue; &#125; 你可以使用 :local(#someId)，但不推荐这种用法。推荐使用 class 代替 id。 demo.js123import styles from './demo.css';console.log(styles);buttonElem.outerHTML = `&lt;button class=$&#123;styles.normal&#125;&gt;Submit&lt;/button&gt;` 生成的HTML：1&lt;button class=&quot;button--normal-abc53&quot;&gt;Submit&lt;/button&gt; 缺点： 需要在运行时才获取className，性能损耗大。解决： （babel-plugin-react-css-modules），【未测试】 对于嵌套和外部组件样式更改无效，比如：嵌套：1234.menu &gt; .btn &gt; .fa &#123; position: relative; bottom: 4px;&#125; 外部样式：下面是修改datatable渲染后的默认样式的123456ul.dt-button-collection&gt;.active&gt;a,ul.dt-button-collection&gt;.active&gt;a:focus,ul.dt-button-collection&gt;.active&gt;a:hover &#123; color: black; background-color: white;&#125; 当前方案鉴于以上问题和改造的成本，目前项目中采用的还是最原始的“加个父元素的选择器，限制范围”方案，此种方案后期改为less或sass，直接提取父元素加一个嵌套即可。","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"CSS Module","slug":"CSS-Module","permalink":"https://zj-john.github.io/tags/CSS-Module/"}]},{"title":"react程序中 Failed to execute 'insertBefore' on 'Node'&& Cannot read property 'nextSibling' of null","date":"2018-01-08T03:22:53.000Z","path":"tips/ckbdbl44e00932ktynx7fflb9.html","text":"问题：react程序中 Failed to execute ‘insertBefore’ on ‘Node’&amp;&amp; Cannot read property ‘nextSibling’ of null 代码执行的功能是 在以下table中点击每一行右侧的红色btn，会弹出一个modal，modal中可以进行一些其它操作以及关闭modal。 现在遇到的问题是打开modal时console中会报错（Failed to execute ‘insertBefore’ on ‘Node’），modal可以打开，但是关闭时报错Cannot read property ‘nextSibling’ of null，且无法关闭。 相关效果和代码如下： 图例Table： 点击按钮时，console中的报错： 虽然有报错，modal可以正常打开： 点击modal关闭按钮时的报错，且modal无法关闭： 相关代码main.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; Component &#125; from 'react'import &#123; config &#125; from 'ConfigRoot/config'import Datatable from 'ComponentsRoot/tables/Datatable';import ActionModalByRelation from '../../../../../modals/inAndOutByApp/ActionModalByRelation'let operation_render = function (data, type, full, row, meta) &#123; return `&lt;span style=\"margin-right: 10px\" class=\"deviceAction tool_tip\" data-toggle=\"tooltip\" title=\"拉入\\出操作\"&gt;&lt;img src=\"assets/img/pull.png\" style=\"height: 17px;width: 17px\"/&gt;&lt;/span&gt;&lt;!--&lt;span style=\"margin-right: 10px\" class=\"containerAction tool_tip\" data-toggle=\"tooltip\" title=\"容器操作\"&gt;&lt;img src=\"assets/img/container.png\" style=\"height: 23px;width: 23px\"/&gt;&lt;/span&gt;--&gt; `&#125;export default class ServerInGroup extends Component &#123; constructor (props) &#123; super(props); console.log('props', props) let page = this; this.columns = [ &#123;data: 'ci_code', title: '主机名', render: ci_render&#125;, &#123; data: null, title: '操作', orderable: false, className: \"menu\", render: function () &#123; return `&lt;span class=\"deviceAction tool_tip glyphicon glyphicon-resize-horizontal btn btn-xs\" data-toggle=\"tooltip\" title=\"拉入\\出操作\"&gt;&lt;/span&gt; &lt;span class=\"containerAction tool_tip glyphicon glyphicon-cog btn btn-xs\" data-toggle=\"tooltip\" title=\"容器操作\"&gt;&lt;/span&gt;` &#125;, createdCell: function (td, cellData, rowData, row, col) &#123; $(td).find('.tool_tip').tooltip(&#123; placement: 'top', &#125;); $(td).on('click', '.deviceAction', function () &#123; page.setState(&#123; showModal: true, modalInfo: rowData, &#125;) &#125;); &#125; &#125; ]; let columns = &#123;\"columns\": this.columns&#125;; this.state = &#123; options: Object.assign(this.props.options , columns), showModal: false, modalInfo: null, &#125; &#125; hideModal = () =&gt; &#123; this.setState(&#123; showModal: false &#125;) &#125; render () &#123; return ( &lt;div&gt; &lt;Datatable options=&#123; this.state.options &#125; lengthChange=&#123;false&#125; searching=&#123;false&#125; autoWidth=&#123;false&#125; className=\"table\" style=&#123;&#123;'width': '100%'&#125;&#125; id=\"serverRelationInGroup\" &gt; &lt;/Datatable&gt; &#123;this.state.showModal? &lt;ActionModalByRelation showModal=&#123;this.state.showModal&#125; modalInfo=&#123;this.state.modalInfo&#125; hideModal=&#123;this.hideModal&#125; type=\"group\"/&gt; : '' &#125; &lt;/div&gt; ) &#125;&#125; modal.js12345678910111213141516171819202122232425262728293031323334353637import React from 'react'import &#123; Button, Modal &#125; from 'react-bootstrap'export default class ActionModalByRelation extends React.Component &#123; constructor (props) &#123; super(props) &#125; componentWillMount () &#123; &#125; close = () =&gt; &#123; this.props.hideModal() &#125; render () &#123; return (&lt;div&gt; &lt;Modal show=&#123;this.props.showModal&#125; onHide=&#123;this.close&#125; className=\"pull_in_modal\"&gt; &lt;Modal.Header closeButton&gt; &lt;Modal.Title className=\"text-center\"&gt;Title&lt;/Modal.Title&gt; &lt;/Modal.Header&gt; &lt;Modal.Body&gt; &lt;div className=\"row\"&gt; &lt;/div&gt; &lt;/Modal.Body&gt; &lt;Modal.Footer&gt; &lt;/Modal.Footer&gt; &lt;/Modal&gt; &lt;/div&gt; ) &#125;&#125; 解决方案后来遇到了如下类似报错：NotFoundError: Failed to execute ‘insertBefore’ on ‘Node’: The node before which the new node is to be inserted is not a child of this node. 通过给组件外套一层解决了。 12345import Datatable from 'react-datatable-jq'&lt;div&gt; &lt;Datatable &#123;...props&#125;&gt;&lt;/div&gt;","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"insertBefore","slug":"insertBefore","permalink":"https://zj-john.github.io/tags/insertBefore/"},{"name":"nextSibling","slug":"nextSibling","permalink":"https://zj-john.github.io/tags/nextSibling/"}]},{"title":"import中{}加与不加的区别","date":"2018-01-04T03:49:32.000Z","path":"tips/ckbdbl449008t2ktyzwl9w8p7.html","text":"问题：import中{}加与不加的区别 import模块时，有时有{}，有时不加，区别是什么呢？12import &#123; Tooltip &#125; from &quot;react-bootstrap&quot;;import ActionModal from &quot;ComponentRoot/modals/ActionModal&quot;; 实现原理官网 一般import时有以下几种方式：123456789101112131415161718192021222324// 导出默认模块import defaultExport from &quot;module-name&quot;;// 导出所有模块，并且指定&quot;name&quot;为命名空间，使用时module-name.someFunc() -&gt; name.someFunc();import * as name from &quot;module-name&quot;;// 导出 module-name 中 export 模块import &#123; export &#125; from &quot;module-name&quot;;// 以别名导出import &#123; export as alias &#125; from &quot;module-name&quot;;// 导出 module-name 中 export1, export2 模块 (muti)import &#123; export1 , export2 &#125; from &quot;module-name&quot;;// 综合导出import &#123; export1 , export2 as alias2 , [...] &#125; from &quot;module-name&quot;;import defaultExport, &#123; export [ , [...] ] &#125; from &quot;module-name&quot;;// 在这种情况下，默认导入将必须首先声明import defaultExport, * as name from &quot;module-name&quot;;// 等价于 import * from &quot;module-name&quot; 以module-name.someFunc()方式使用import &quot;module-name&quot;;","tags":[{"name":"import","slug":"import","permalink":"https://zj-john.github.io/tags/import/"}]},{"title":"Chrome devtools-Performance面板-技巧","date":"2018-01-02T04:07:06.000Z","path":"notes/ckbdbl40g001b2ktyvs2370h4.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Performance面板的具体用法。 官方教程 Performance面板分析运行时性能 不要编写会强制浏览器重新计算布局的 JavaScript。将读取和写入功能分开，并首先执行读取。 不要使您的 CSS 过于复杂。减少使用 CSS 并保持 CSS 选择器简洁。 尽可能地避免布局。选择根本不会触发布局的 CSS。 绘制比任何其他渲染活动花费的时间都要多。请留意绘制瓶颈。 JavaScriptJavaScript 计算，特别是会触发大量视觉变化的计算会降低应用性能。 不要让时机不当或长时间运行的 JavaScript 影响用户交互。 工具 进行 Timeline 记录，并找出疑似较长的 Evaluate Script 事件（黄色) 如果JavaScript 中出现较多的卡顿现象，您可能需要进一步分析并收集 JavaScript CPU 配置文件。CPU 配置文件会显示执行时间花费在页面的哪些函数上 问题 问题 示例 解决方案 大开销输入处理程序影响响应或动画。 触摸、视差滚动。 让浏览器尽可能晚地处理触摸和滚动，或者绑定侦听器 时机不当的 JavaScript 影响响应、动画、加载。 页面加载后用户向右滚动、setTimeout/setInterval。 优化 JavaScript 执行：使用 requestAnimationFrame、使 DOM 操作遍布各个帧、使用网络工作线程 长时间运行的 JavaScript 影响响应。 DOMContentLoaded 事件由于 JS 工作过多而停止 将纯粹的计算工作转移到网络工作线程。如果您需要 DOM 访问权限，请使用 requestAnimationFrame 会产生垃圾的脚本影响响应或动画。 任何地方都可能发生垃圾回收。 减少编写会产生垃圾的脚本 样式样式更改开销较大，在这些更改会影响 DOM 中的多个元素时更是如此。 只要您将样式应用到元素，浏览器就必须确定对所有相关元素的影响、重新计算布局并重新绘制。 工具 进行 Timeline 记录。检查大型 Recalculate Style 事件（紫色） 问题 问题 示例 解决方案 大开销样式计算影响响应或动画。 任何会更改元素几何形状的 CSS 属性，如宽度、高度或位置；浏览器必须检查所有其他元素并重做布局。 避免会触发布局的 CSS。 复杂的选择器影响响应或动画。 嵌套选择器强制浏览器了解与所有其他元素有关的全部内容，包括父级和子级。 在 CSS 中引用只有一个类的元素（高级的选择器可能消耗大量的计算时间）。 布局布局是浏览器用来计算页面上所有元素的位置和大小的过程 工具Timeline 可以确定页面何时会导致强制同步布局 (红色竖线) 问题 问题 示例 解决方案 强制同步布局影响响应或动画。 强制浏览器在像素管道中过早执行布局，导致在渲染流程中重复步骤。 先批处理您的样式读取，然后处理任何写入 布局抖动影响响应或动画。 形成一个使浏览器进入读取-写入-读取写入周期的循环，强制浏览器反复地重新计算布局。 使用 FastDom 内容库自动批处理读取-写入操作 绘制合成绘制是填充像素的过程。这经常是渲染流程开销最大的部分。 如果您在任何情况下注意到页面出现卡顿现象，很有可能存在绘制问题。 合成是将页面的已绘制部分放在一起以在屏幕上显示的过程。 工具Summary中Painting中耗时长 问题 问题 示例 解决方案 绘制风暴影响响应或动画。 较大的绘制区域或大开销绘制影响响应或动画。 避免绘制、提升将要移动到自有层的元素，使用变形和不透明度 层数激增影响动画。 使用 translateZ(0) 过度提升过多的元素会严重影响动画性能。 请谨慎提升到层，并且仅在您了解这样会有切实改进时提升到层 时间线事件属性参考文档 时间线事件属性 属性 显示时间 Aggregated time 对于带嵌套事件的事件，每个类别的事件所用的时间。 Call Stack 对于带子事件的事件，每个类别的事件所用的时间。 CPU time 记录的事件所花费的 CPU 时间。 Details 有关事件的其他详细信息。 Duration (at time-stamp) 事件及其所有子事件完成所需的时间，时间戳是事件发生的时间（相对于记录开始的时间）。 Self time 事件（不包括任何子事件）花费的时间。 Used Heap Size 记录事件时应用使用的内存大小，以及自上次采样以来已使用堆大小的增减 (+/-) 变化。 loading事件属于加载类别的事件及其属性 事件 Parse HTML：Chrome 执行其 HTML 解析算法。 Finish Loading： 网络请求已完成。 Receive Data： 请求的数据已被接收。存在一个或多个 Receive Data 事件。 Receive Response： 请求的初始 HTTP 响应。 Send Request： 网络请求已被发送。 属性 属性 说明 Resource 请求的资源的网址。 Preview 请求的资源的预览（仅图像）。 Request Method 用于请求的 HTTP 方法（例如，GET 或 POST）。 Status Code HTTP 响应代码。 MIME Type 请求的资源的 MIME 类型。 Encoded Data Length 请求的资源的长度（以字节为单位）。 Scripting 事件属于脚本类别的事件及其属性 事件 Animation Frame Fired：预定的动画帧被触发，其回调处理程序被调用。 Cancel Animation Frame： 预定的动画帧被取消。 GC Event： 发生垃圾回收。 DOMContentLoaded： 浏览器触发 DOMContentLoaded。当页面的所有 DOM 内容都已加载和解析时，将触发此事件。 Evaluate Script： 脚本已被评估。 Event： JavaScript 事件（例如，“mousedown”或“key”）。 Function Call： 发生顶级 JavaScript 函数调用（只有浏览器进入 JavaScript 引擎时才会出现）。 Install Timer： 已使用 setInterval() 或 setTimeout() 创建定时器。 Request Animation Frame： requestAnimationFrame() 调用已预定一个新帧。 Remove Timer： 之前创建的定时器已被清除。 Time： 一个脚本调用了 console.time() Time End： 一个脚本调用了 console.timeEnd() Timer Fired： 使用 setInterval() 或 setTimeout() 创建的定时器已被触发。 XHR Ready State Change： XMLHTTPRequest 的就绪状态已发生变化。 XHR Load： XMLHTTPRequest 已结束加载。 属性 属性 说明 Timer ID 定时器 ID。 Timeout 定时器指定的超时。 Repeats 指定定时器是否重复的布尔值。 Function Call 已调用一个函数。 Rendering 事件渲染类别的事件及其属性 事件 Invalidate layout：页面布局被 DOM 更改声明为无效。 Layout： 页面布局已被执行。 Recalculate style： Chrome 重新计算了元素样式。 Scroll： 嵌套视图的内容被滚动。 属性 属性 说明 Layout invalidated 对于 Layout 记录，导致布局失效的代码的堆叠追踪。 Nodes that need layout 对于 Layout 记录，被标记为需要在重新布局启动前布局的节点的数量。正常情况下，这些代码是被开发者代码声明为无效的代码，以及向上追溯到重新布局根目录的路径。 Layout tree size 对于布局记录，重新布局根目录下节点（Chrome 启动重新布局的节点）的总数。 Layout scope 可能的值为“Partial”（重新布局边界是 DOM 的一部分）或“Whole document”。 Elements affected 对于 Recalculate 样式记录，受样式重新计算影响的元素的数量。 Styles invalidated 对于 Recalculate 样式记录，提供导致样式失效的代码的堆叠追踪。 Painting 事件打印类别的事件及其属性 事件 Composite Layers： Chrome 的渲染引擎合成了图像层。 Image Decode： 一个图像资源被解码。 Image Resize： 一个图像的大小相对于其原生尺寸发生了变化。 Paint： 合成的图层被绘制到显示画面的一个区域。将鼠标悬停到 Paint 记录上会突出显示已被更新的显示画面区域。 属性 属性 说明 Location 对于 Paint 事件，绘制矩形的 x 和 y 坐标。 Dimensions 对于 Paint 事件，已绘制区域的高度和宽度。","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"Chrome devtools-Performance面板-初步使用","date":"2018-01-01T09:57:21.000Z","path":"notes/ckbdbl40s001t2ktyp06e4hqy.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Performance面板的具体用法。 官方教程 Performance面板使用性能面板可以通过分析运行时的性能。翻译自Get Started With Analyzing Runtime Performance 开始 请在隐身模式打开Google Chrome URL打开：https://googlechrome.github.io/devtools-samples/jank/ 打开DevTools 隐身模式可以确保Chrome运行在一个干净的状态，便于分析网页的性能。如果你安装了大量的扩展插件,这些插件可能会产生影响性能分析的噪声。 模拟移动设备CPU移动设备比台式机和笔记本电脑有更少的CPU。所以当你分析页面时,使用CPU Throtting 来模拟页面在移动设备上的执行 在DevTools,单击Performance面板 确保Screenshots复选框启用 单击Capture Settings。 对于CPU选项,选择2x slowdown。DevTools将会使用比平时慢2倍的CPU运行页面。 不同设备不同配置的设备需要设置不同的CPU放慢速度 DEMO演示由于读者配置、设备等不同，很难创建一个对所有读者来说一致的运行性能演示。所以在本DEMO（打开URL的DEMO）中，设置了一种可以自动调节的机制来满足不同读者的性能演示。 持续点击”Add 10”,直到蓝色方块移动明显比以前慢。在高端机器上,可能需要大约20点击 点击”Optimize”,蓝色方块的动画会变得更快更顺利。 单击”Un-Optimize”,蓝色方块移动会变慢有闪烁的感觉。 记录运行时的状态为什么优化后效果会变得更好呢，我们通过performance面板来分析下。 Performance面板中点击”记录”，DevTools会捕获在页面运行时性能指标 等几秒钟 单击停止记录，DevTools会停止记录并处理数据,然后显示性能分析结果。 选项说明： Disable JavaScript samples：禁用JS Func调用堆栈,减少了对移动设备运行时开销（reduces overhead when running against mobile devices.） Throttle the network while recording：更改网络情况 Enable advanced paint instrumentation：显示更为详尽的图表指导,把重要的性能开销置顶（instroduces significant performance overhead.） Throttle the CPU while recording：更改CPU情况 分析结果分析FPSFPS:frames per second 其中一个测量性能的主要指标是每秒的动画帧数(FPS)，对于动画来说，FPS === 60会是一个好的体验，少于这个数会觉得卡顿，大于这个数会觉得太快。 FPS图表如果FPS图表上是一片红色柱子，说明帧速率过低可能影响用户体验。通常来说，绿色越多FPS越高。 CPU图表FPS图表下是CPU图表，CPU图表中的颜色说明和Summary部分一致。如果CPU图中填满了颜色，说明cpu在性能记录过程中一直被占满了，此时应该想办法优化。 网页截图当鼠标在FPS、CPU或者NET图上划过时，可以看到对应时刻的网页截图，用以结合分析动画性能。 悬停在Frame部分，可以通过悬停鼠标来看这一时刻的FPS 打开FPS监控盘： 使用快捷键 ctrl+shift+P (win) 或者Command+shift+P(mac) 来打开名命令菜单 输入Rendering，选择Show Rendering 在Rendering窗格，启动FPS Meter。 查找瓶颈Summary选项卡当不点击任何具体event时，显示的是整个记录行为中各个分类所占的时间。对这个case来说，可以看到Rendering占了大部分时间，所以最好的优化方式是减少这一部分时间。 展开Main部分这一部分展示了主线程的event图。X轴记录了记录的时间，每个小柱图代表一个event，柱子的宽度越大表示这个event占用的时间越多；Y轴代表调用栈，如果同一Y轴上有多个events,说明靠上的event调用了下方的event。 查找具体数据通过在时间轴上点击，鼠标滚轮来放大一个单一的 Animation Frame Fired Event.此时Summary显示的这个event的具体信息。 放大事件的另一个方法是点击后利用W A S D键来操作。W,S是放大、缩小；A,D是移动. 快速搜索：Ctrl + F ，可以使用正则和忽略大小写两个模式 帧的右上角标识如果在Event的右上角看到一个红色的三角，说明这个Event可能有些问题。 当 requestAnimationFrame() 函数回调时会触发Animation Frame Fired Event 定位Event点击 Animation Frame Fired Event,Summary窗格上会展示这个event的详细信息，注意里面有一个”reveal”的链接。单击这个链接可以显示这个event的具体调用地址。再次单击可以跳转到源代码中具体的行内。 进入代码在app.update event下，如果放大看，可以看到下面的每一个紫色的event右上都有一个红色的三角。点击其中的一个查看Summary的具体信息。实际上，每一个都表示有一次强制重构布局。 在上面的紫色event上点击具体的调用源代码地址 app.js:70,这行代码就是导致重构布局的原因。 这段代码的问题是,在每个动画帧,它改变了每个方块的style,然后查询每个方块在页面上的位置。因为style改变了,浏览器不知道每个方块的具体位置,所以它对方块进行重新布局以计算其位置。 More","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"Chrome devtools-Network面板","date":"2017-12-29T02:31:20.000Z","path":"notes/ckbdbl409000y2ktycfh1krqe.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Network面板的具体用法。 官方教程 Network面板Network 面板记录页面上每个网络操作的相关信息，包括详细的耗时数据、HTTP 请求与响应标头和 Cookie，等等。 基本使用Filters窗格：使用这些选项（ALL JS CSS Img Media）可以控制在 Requests Table 中显示哪些资源。 提示：按住 Cmd (Mac) 或 Ctrl (Windows/Linux) 并点击过滤器可以同时选择多个过滤器。 文本字段关键词搜索 domain：仅显示来自指定域的资源。您可以使用通配符字符 (*) 来包含多个域。 has-response-header：显示包含指定 HTTP 响应标头的资源。 is：使用 is:running 可以查找 WebSocket 资源。 larger-than：显示大于指定大小的资源（以字节为单位）。 将值设为 1000 等同于设置为 1k。 method：显示通过指定 HTTP 方法类型检索的资源。 mime-type：显示指定 MIME 类型的资源。DevTools 会使用它遇到的所有 MIME 类型填充下拉菜单。 mixed-content：显示所有混合内容资源 (mixed-content:all)，或者仅显示当前显示的资源 (mixed-content:displayed)。 scheme：显示通过未保护 HTTP (scheme:http) 或受保护 HTTPS (scheme:https) 检索的资源。 set-cookie-domain：显示具有 Set-Cookie 标头并带有与指定值匹配的 Domain 属性的资源。 set-cookie-name：显示具有 Set-Cookie 标头并且名称与指定值匹配的资源。 set-cookie-value：显示具有 Set-Cookie 标头并且值与指定值匹配的资源。 status-code：仅显示 HTTP 状态代码与指定代码匹配的资源。 Requests Table窗格： Initiator：发起请求的对象或进程。值为以下选项之一： Parser: Chrome 的 HTML 解析器发起请求。Redirect: HTTP 重定向发起请求。Script: 脚本发起请求。Other: 某些其他进程或操作发起请求，例如用户通过链接或者在地址栏中输入网址导航到页面。 Size：响应标头（通常为数百字节）加响应正文（由服务器提供）的组合大小。 Time：从请求开始至在响应中接收到最终字节的总持续时间。 use small request rows选项可以使Request 窗格显示详细或简单信息。 size：详细时显示Size/Content，简单时显示Size Time：详细时显示Time/Latency，简单时显示Time 其中Size是响应头部和响应体结合起来的大小，Content是请求内容解码后的大小（如果有缓存时size &lt; content）；Time是从请求开始到接收到最后一个字节的总时长，Latency是从请求开始到接收到第一个字节的时间 Timeline列（Waterfall列）排序： Start Time：按每个网络请求的开始时间排序（默认排序）。 Response Time：按每个请求的响应时间排序。 End Time：按每个请求完成的时间排序。 Duration：按每个请求的总时间排序。选择此过滤器可以确定哪些资源的加载时间最长。 Latency：按请求开始与响应开始之间的时间排序。 选择此过滤器可以确定哪些资源至第一字节 (TTFB) 的时间最长。 记录网络活动和捕捉屏幕截图记录网络活动 红色：记录中 灰色：未记录 捕捉屏幕截图 蓝色：记录中 灰色：停用中 查看 DOMContentLoaded 和 load 事件信息DOMContentLoaded：当最初的HTML文档被完全加载和解析时触发（不等待样式、图片等） Overview 窗格中的蓝色竖线表示事件。 在 Summary 窗格中，您可以看到事件的确切时间 load：当页面完全加载时触发（资源及其相关资源完成） Overview 窗格中的红色竖线表示事件 在 Summary 窗格中，您可以看到事件的确切时间。 单个资源的详细信息cookie标签只有传输 Cookie 时，此标签才可用 Domain：Cookie 所属的域。 Path：Cookie 来源的网址路径。 Expires / Max-Age：Cookie 的 expires 或 max-age 属性的值。 Size：Cookie 的大小（以字节为单位）。 HTTP：指示 Cookie 应仅由浏览器在 HTTP 请求中设置，而无法通过 JavaScript 访问。 Secure：如果存在此属性，则指示 Cookie 应仅通过安全连接传输 Frames标签只有选定资源发起 WebSocket 连接时，此标签才会显示。 Data：消息负载。如果消息为纯文本，将在此处显示。 对于二进制操作码，此字段将显示操作码的名称和代码。 支持以下操作码：延续框架，二进制框架，连接关闭框架，Ping 框架，Pong 框架 Length：消息负载的长度（以字节为单位）。 Time：消息创建时的时间戳。 消息根据其类型进行彩色编码： 传出文本消息为浅绿色。 传入文本消息为白色。 WebSocket 操作码为浅黄色。 错误为浅红色。 目前仅保留最后 100 条 WebSocket 消息 可以测试的URL Timing标签Resource Timing 的阶段 可以通过consolo中以下命令输出某个资源的Timing 信息1performance.getEntriesByType(&quot;resource&quot;).filter(item =&gt; item.name.includes(&quot;.css&quot;)) 各阶段字段 Queuing：如果某个请求正在排队，则指示： -请求已被渲染引擎推迟，因为该请求的优先级被视为低于关键资源（例如脚本/样式）的优先级。 图像经常发生这种情况-请求已被暂停，以等待将要释放的不可用 TCP 套接字。-请求已被暂停，因为在 HTTP 1 上，浏览器仅允许每个源拥有六个 TCP 连接。-生成磁盘缓存条目所用的时间（通常非常迅速） Stalled/Blocking：请求等待发送所用的时间。 可以是等待 Queueing 中介绍的任何一个原因。 此外，此时间包含代理协商所用的任何时间。 Proxy Negotiation：与代理服务器连接协商所用的时间。 DNS Lookup：执行 DNS 查询所用的时间。 页面上的每一个新域都需要完整的往返才能执行 DNS 查询。 Initial Connection / Connecting：建立连接所用的时间，包括 TCP 握手/重试和协商 SSL 的时间。 SSL：完成 SSL 握手所用的时间。 Request Sent / Sending：发出网络请求所用的时间。 通常不到一毫秒。 Waiting (TTFB)：等待初始响应所用的时间，也称为至第一字节的时间。 此时间将捕捉到服务器往返的延迟时间，以及等待服务器传送响应所用的时间。 Content Download / Downloading：接收响应数据所用的时间。 查看资源发起者和依赖项按住 Shift 并将鼠标悬停在资源上，可以查看其发起者和依赖项。 绿色：发起者 红色：依赖项 悬停目标上方的第一个绿色编码资源为目标的发起者。 如果上方存在第二个也是绿色编码的资源，那么该资源将是发起者的发起者。 悬停目标下方红色编码的任何资源都是目标的依赖项。 对于具有大量资源的页面，您可能无法看到所有的发起者或依赖项。 复制、保存网络信息 Copy Response：将选定资源的 HTTP 响应复制到系统剪贴板。 Copy as cURL：以 cURL 命令字符串的形式将选定资源的网络请求复制到系统剪贴板。 Copy All as HAR：以 HAR 数据形式将所有资源复制到系统剪贴板。HAR 文件包含用于说明网络“瀑布”的 JSON 数据结构。多款第三方 工具 可以依据 HAR 文件中的数据重建网络瀑布。 Save as HAR with Content：将所有网络数据及每一个页面资源保存到 HAR 文件。 二进制资源（包括图像）以 Base64 编码文本的形式编码。 Replay XHR。重新发送选定的 XMLHTTPRequest。仅在 XHR 资源上显示。 cURL:用于进行 HTTP 事务的命令行工具curl 网络性能优化网络问题已被加入队列或已被停止的系列 HTTP 1.0/1.1 连接上，Chrome 会将每个主机强制设置为最多六个 TCP 连接。如果您一次请求十二个条目，前六个将开始，而后六个将被加入队列。最初的一半完成后，队列中的第一个条目将开始其请求流程。解决办法：设置多个子域。 HTTP 2 中，到服务器的单个 TCP 连接作为多路复用连接。这消除了 HTTP 1 中的六个连接限制，并且可以通过单个连接同时传输多个资源 至第一字节的漫长时间Timing图大片绿色，等待时间长表示至第一字节的时间 (TTFB) 漫长。建议将此值控制在 200 毫秒以下。长 TTFB 会揭示两个主要问题： 客户端与服务器之间的网络条件较差 服务器应用的响应慢 达到吞吐量能力Timing图大片蓝色，Content Download 阶段花费了大量时间，则提高服务器响应或串联不会有任何帮助。首要的解决办法是减少发送的字节数 检查工具Insight 规则Insights规则 chrome中的优化high-performance-networking-in-google-chrome gzip优化基于文本的资产的编码和传送大小","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"Chrome devtools-Sources面板","date":"2017-12-28T02:31:20.000Z","path":"notes/ckbdbl40a00112kty780mquvl.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Sources面板的具体用法。 官方教程 Sources面板在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。 断点类型 单行断点：On an exact region of code. 带条件的单行断点： On an exact region of code, but only when some other condition is true. DOM断点： On the code that changes or removes a specific DOM node, or its children. XHR断点： When an XHR URL contains a string pattern. 事件监听断点： On the code that runs after an event, such as click, is fired. 异常监听断点： On the line of code that is throwing a caught or uncaught exception. 函数断点： Whenever a specific function is called. 单行断点devTools中添加 打开Source面板 打开要调试的文件 找到要添加端点的行 在左侧行号处单击（蓝色标签） 程序中添加123console.log(&apos;b&apos;);debugger;console.log(&apos;c&apos;); 带条件的单行断点 打开Source面板 打开要调试的文件 找到要添加端点的行 在左侧行号处右击 选择Add conditional breakpoint. 输入表达式 按Enter激活（橘黄标签） 管理单行断点Breakpoints窗格中可以查看、激活、删除某个或多个断点 DOM断点DOM Breakpoints窗格中查看Elements面板上设定的DOM的Break on操作（子树更改,属性更改,节点移除） XHR断点XHR Breakpoints窗格中添加。 事件监听断点Event Listener Breakpoints窗格添加侦听的断点动作 异常监听断点窗格中的暂停号（∥）：Pause on exceptions 函数断点执行到函数时会停住123456function sum(a, b) &#123; let result = a + b; // DevTools pauses on this line. return result;&#125;debug(sum); // Pass the function object, not a string.sum();","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"JavaScript内存泄漏","date":"2017-12-27T02:41:45.000Z","path":"notes/ckbdbl40o001n2ktydcssyofx.html","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zj-john.github.io/tags/JavaScript/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"https://zj-john.github.io/tags/内存泄漏/"}]},{"title":"Chrome devtools-Console面板","date":"2017-12-27T02:14:03.000Z","path":"notes/ckbdbl407000v2kty9gi6um83.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Console面板的具体用法。 官方教程 Console面板在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell在页面上与JavaScript交互。 在其他面板以抽屉式展示 在 DevTools 处于聚焦状态时按 Esc。 按 Customize and control DevTools 按钮，然后按 Show console。 消息堆叠如果一条消息连续重复，而不是在新行上输出每一个消息实例，控制台将“堆叠”消息并在左侧外边距显示一个数字。此数字表示该消息已重复的次数。如果要取消这种行为，可以在DevTools 设置中启用 Show timestamps 控制台历史记录删除 在控制台中键入 clear()。 从您的 JavaScript 代码内调用 console.clear()。 Ctrl+L 保留启用控制台顶部的 Preserve log 复选框可以在页面刷新或更改之间保留控制台历史记录 保存右键，然后选择 Save as 选择执行环境默认环境设置为 top（页面的顶部框架）","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"Chrome devtools-Elements面板","date":"2017-12-26T02:41:45.000Z","path":"notes/ckbdbl40c00132ktymq63sp4h.html","text":"chrome大概是最常用的浏览器之一，这篇笔记讲解下Chrome devtools中Elements面板的具体用法。 官方教程 chrome 开发者工具如果要使用最新版的devtools，可以安装Chrome Canary版本. 打开方式： 在Chrome菜单中选择 更多工具 &gt; 开发者工具 在页面元素上右键点击，选择 “检查” 使用 快捷键 Ctrl+Shift+I (Windows) 或 Cmd+Opt+I (Mac) 面板： 元素面板 Elements:使用元素面板可以自由的操作DOM和CSS来迭代布局和设计页面. 控制台面板 Console:在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell在页面上与JavaScript交互。 源代码面板 Source:在源代码面板中设置断点来调试 JavaScript ，或者通过Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。 网络面板 Network:使用网络面板了解请求和下载的资源文件并优化网页加载性能。 性能面板 Performance:使用时间轴面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。 在 Chrome 57 之前为时间线面板 Timeline 内存面板 Memory:如果需要比时间轴面板提供的更多信息，可以使用“配置”面板，例如跟踪内存泄漏。 在 Chrome 57 之前为分析面板 Profiles 应用面板 Application:使用资源面板检查加载的所有资源，包括IndexedDB与Web SQL数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。 在 Chrome 52 之前为资源面板 Resources 安全面板 Security:使用安全面板调试混合内容问题，证书问题等等。 审计面板 Audits：对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。 Elements面板实时编辑DOM节点 编辑 移动 删除（Ctrl+Z 撤销） 滚动到视图： 要滚动页面使节点在视口中显示，请右键点击节点并选择 Scroll into View 实时编辑样式Styles 窗格可以显示应用到选定元素的 CSS 规则，优先级从高到低。 已被级联规则替换的规则将显示为带删除线的文本 继承的样式将在“Inherited from ”标头下显示为一组。点击标头中的 DOM 节点可以导航到其在 DOM 树视图中的位置。 灰色的条目不是已定义的规则，而是在运行时计算的规则 检查受选择器影响的元素在 Styles 窗格中将鼠标悬停在 CSS 选择器上可以查看受该选择器影响的所有元素。 此功能仅突出显示视口中的元素；视口以外的其他元素也可能受选择器影响。 （继承样式） 添加、启用和停用 CSS 类点击 .cls 按钮可以查看与当前选定元素关联的所有 CSS 类 编辑现有属性名称或值在名称或值突出显示时，按 Tab 可以向前移动到下一个属性、名称或选择器。按 Shift+Tab 可以向后移动。 编辑数字式 CSS 属性值时，可以使用下面的键盘快捷键增大和减小值： 使用向上键和向下键能够以 1 为增量增大和减小值（如果当前值介于 -1 和 1 之间，则增量为 0.1）。 使用 Alt+向上键和 Alt+向下键能够以 0.1 为增量增大和减小值。 使用 Shift+向上键能够以 10 为增量增大值；使用 Shift+向下键能够以 10 为增量减小值。 使用 Shift+Page Up（Windows、Linux）或 Shift+Function+向上键 (Mac) * 能够以 100 为增量增大值。使用 Shift+Page Down（Windows、Linux）或 Shift+Function+向下键 (Mac) 能够以 100 为增量减小值。 添加样式规则点击 New Style Rule 按钮可以添加一个新的 CSS 规则。点击并按住按钮可以选择要向哪一个样式表添加规则。 编辑 Sass、Less 或 Stylus借助 CSS 源映射，DevTools 可以将生成的文件自动映射到源代码文件，这样，您可以在 Sources 面板中实时编辑这些文件并查看结果，而不用离开 DevTools 或刷新页面。默认情况下，CSS 源映射处于启用状态。启用/关闭操作： 打开 DevTools 的 Settings 面板并点击 General。 开启 Enable CSS source maps 和 Auto-reload generated CSS。 检查和编辑框模型参数使用 Computed 窗格检查和编辑当前元素的框模型参数。 框模型中的所有值均可修改，只需点击它们即可 查看本地更改 在 Styles 窗格中，点击您修改的文件。DevTools 会将您带到 Sources 面板。 右键点击文件。 选择 Local modifications。 粉色背景的线表示移除，绿色背景的线表示添加。 DOM断点如果您的 JavaScript 正在更改 DOM 元素的样式，请将 DOM 断点设置为在元素属性修改时触发。在发生以下一种 DOM 更改时触发断点： 子树更改 属性更改 节点移除 元素上右键选择Break on可以添加断点。DOM Breakpoints窗格：每个断点都会列出元素标识符和断点类型 元素事件侦听器Event Listeners窗格：显示具有已注册侦听器的事件类型。 handler包含一个回调函数。右键点击函数并选择 Show Function Definition 可以查看函数的定义位置（如果源代码可用）。 useCapture指示 addEventListener 上的 useCapture 标志是否设置的布尔值。 许多 Chrome 扩展程序都会将其自己的事件侦听器添加到 DOM 上。如果您看到一些不是由您的代码设置的事件侦听器，您可能希望在隐身窗口中重新打开页面。默认情况下，隐身窗口会阻止扩展程序运行 选项： 查看祖先实体事件侦听器如果启用 Ancestors 复选框，除了当前选定节点的事件侦听器外，还会显示其祖先实体的事件侦听器 查看框架侦听器启用 Framework listeners 复选框时，DevTools 会自动解析事件代码的框架或内容库封装部分，然后告诉您实际将事件绑定到代码中的位置。如果停用 Framework listeners 复选框，事件侦听器代码很可能会在框架或内容库代码的其他地方解析。 angular测试没有成功，jQuery可以找到定义源函数 DevTools 的工作区设置持久化教程","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zj-john.github.io/tags/Chrome/"},{"name":"devtools","slug":"devtools","permalink":"https://zj-john.github.io/tags/devtools/"}]},{"title":"webpack devServer 中 proxy options","date":"2017-12-25T03:03:37.000Z","path":"tips/ckbdbl44b008w2kty614f28jr.html","text":"问题：webpack devServer中proxy options webpack中DevServer中使用proxy来接收mock数据，一直是用的是localhost:port的数据，没有什么问题。如果使用了非localhost、非根path的数据，要进行特殊配置。配置如下： 实现原理在webpack的官方devserver的文档中，并没有太多内容讲解proxy的用法。但是文档中告诉我们，这个部分时用了http-proxy-middleware这个包,所以我们在这里找到了很详细的用法。 12345678910111213141516171819devServer: &#123; historyApiFallback: true, contentBase: path.join(__dirname, \"dist\"), port: 2200, hot: true, compress: false, publicPath: '/', stats: \"minimal\", proxy: &#123; '/api/': &#123; target: 'http://mywebsite.mockdata.com/', changeOrigin: true, secure: false, pathRewrite: &#123; '^/api' : '/mock/8/api', &#125; &#125; &#125;&#125;, 参数用法： target: ‘http://www.example.org‘, // target host changeOrigin: true, // needed for virtual hosted sites ws: true, // proxy websockets pathRewrite: 1234&#123; &apos;^/api/old-path&apos; : &apos;/api/new-path&apos;, // rewrite path &apos;^/api/remove/path&apos; : &apos;/path&apos; // remove base path&#125; router: 12345&#123; // when request.headers.host == &apos;dev.localhost:3000&apos;, // override target &apos;http://www.example.org&apos; to &apos;http://localhost:8000&apos; &apos;dev.localhost:3000&apos; : &apos;http://localhost:8000&apos;&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://zj-john.github.io/tags/webpack/"},{"name":"devServer","slug":"devServer","permalink":"https://zj-john.github.io/tags/devServer/"},{"name":"proxy","slug":"proxy","permalink":"https://zj-john.github.io/tags/proxy/"}]},{"title":"高性能网站建设指南-笔记（十三）","date":"2017-12-22T04:12:42.000Z","path":"notes/ckbdbl43k007c2ktydj7zcwzy.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则14-使Ajax可缓存 减少HTTP请求 代码示例 这一章的内容很老，作者放了很大篇幅介绍web2.0和Ajax这种”新”技术，不再记录。只要能认识到Ajax请求也是一种http请求，可以适用以前讲到的各种规则(如3, 4, 9, 10, 11, 13等)即可。 最佳实践确保Ajax请求遵守性能指导，尤其应具有长久的Expires头 结尾本书的最后给大家提供了一个网页性能测试插件YSlow，有一些建议还是不错的。","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（十二）","date":"2017-12-21T03:44:23.000Z","path":"notes/ckbdbl43m007j2kty0y4nqcha.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则13-配置ETag 减少HTTP请求 代码示例 ETag(Entity Tag)实体标签 缓存过程 Expires头未过期，直接从缓存获取资源 Expires头过期后，发送条件Get，确认缓存的组件是否有效。有效则返回304 Not Modified，无效则返回更新后的组件 确认缓存组件是否有效有两种方式 比较最新修改日期，一致为有效(If-Modified-Since, Last-Modefied) 比较实体标签：实体是对组件的另一种称呼，http1.1中引入，唯一标识了一个组件的一个特定版本的字符串（If-None-Match） ETag带来的问题 不同后端服务器上返回的同一资源的ETag标签不一致，增加资源开销 If-None-Match的优先级高于If-Modified-Since 如果无须自定义ETag，最好不使用ETag。 最佳实践配置或移除ETag","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（十一）","date":"2017-12-20T04:10:43.000Z","path":"notes/ckbdbl43h00772ktylicea8h5.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则12-移除重复脚本 减少HTTP请求 代码示例 重复脚本来源 团队大小 脚本数量 危害 不必要的HTTP请求 执行JS所浪费的时间 避免重复脚本载入脚本时判断12345678910111213function insertScript(jsFile) &#123; if (alreadyInserted(jsFile)) &#123; return; &#125; pushInserted(jsFile); if (hasDependencies(jsFile)) &#123; var dependencies = getDependencies(jsFile); dependencies.map((script) =&gt; &#123; insertScript(script); &#125;) &#125;&#125; 最佳实践确保脚本只被包含一次","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"规范化 git commit","date":"2017-12-19T02:33:47.000Z","path":"tips/ckbdbl448008r2kty2bzozea1.html","text":"问题：规范化 git commit 更改开源项目中，发现commit时有限制，需要按照规范的格式提交。为了引入到自己的项目中，了解下实现原理。 实现原理直接看代码：package.json 123456789101112131415161718192021222324\"devDependencies\": &#123; \"validate-commit-msg\": \"^2.12.2\"&#125;,\"config\": &#123; \"ghooks\": &#123; \"commit-msg\": \"validate-commit-msg\" &#125;, \"validate-commit-msg\": &#123; \"types\": [ \"feat\", \"fix\", \"docs\", \"test\", \"chore\", \"refactor\", \"opti\" ], \"warnOnFail\": false, \"maxSubjectLength\": 100, \"subjectPattern\": \".+\", \"subjectPatternErrorMsg\": \"请输入message信息!\", \"helpMessage\": \"Commit message 格式错误, \\n请查看规范: https://github.com/conventional-changelog-archived-repos/validate-commit-msg\" &#125;&#125; 完成以上配置后，则只可以通过以下格式提交：123&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// or&lt;type&gt;: &lt;subject&gt; 使用了validate-commit-msg这个插件，相关参数说明： types: These are the types that are allowed for your commit message. “types”: “*“ to indicate that you don’t wish to validate types. warnOnFail: If this is set to true errors will be logged to the console, however the commit will still pass. subjectPattern: Optional, accepts a RegExp to match the commit message subject against. scope: This object defines scope requirements for the commit message 使用规范化的commit可以便于查找问题已经生产change log 后续学习可以参考Commit message 和 Change log 编写指南","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"image","slug":"image","permalink":"https://zj-john.github.io/tags/image/"},{"name":"base64","slug":"base64","permalink":"https://zj-john.github.io/tags/base64/"}]},{"title":"高性能网站建设指南-笔记（十）","date":"2017-12-18T06:25:08.000Z","path":"notes/ckbdbl43g00742ktyibk2x3dl.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则9-避免重定向 缩短响应时间 代码示例 重定向类型 301 ：永久重定向 302 ：暂时重定向 meta refresh : content的秒后，重定向到url指定的地址1&lt;meta http-equiv=\"refresh\" content=\"0\" url=http://website&gt; 重定向会耗费请求时间并且降低用户体验 重定向时，浏览器会自动将用户带到location字段所给出的url，响应体通常为空。301和302在实际中都不会被缓存，除非有附加的头（Expires，Cache-Control） 重定向之外的选择缺少结尾的斜线发生在URL的结尾必须出现斜线(/)而没有出现时，会重定向到带有斜线(/)的url。（和容器相关）当主机名缺少结尾斜线时不会发生重定向：因为浏览器在进行GET请求时必须指定一些路径，如果没有路径，会简单的使用文档根（/） 连接网站一般用于网站后端被重写的时候，连接新旧两个网站 域名调用可以使用CNAME的方式 同一台服务器，后端自己连接 重定向的功能 跟踪入站流量：对于内部流量，值得通过建立Referer日志来避免重定向 重定向的方法是跳转到本站一个地址（www.website.com/s/），然后再重定向(sports.website.com)。通过在日志中审计本站的地址，就可以统计出后续的跳转地址 跟踪出站流量：对于外部访问，可以通过信标的方式。 12345678910111213141516//html&lt;a href=\"http://en.wikipedia.org/wiki/Performance\" onclick=\"resultBeacon(this); return false;\"&gt;Performance - Wikipedia&lt;/a&gt;//jsvar beacon;function resultBeacon(anchor) &#123; beacon = new Image(); beacon.onload = gotoUrl; beacon.onerror = gotoUrl; // in case the image fails, we still want to redirect the user beacon.anchor = anchor; beacon.src = \"/bin/beacon204.gif?url=\" + escape(anchor.href);&#125;function gotoUrl() &#123; document.location = beacon.anchor.href;&#125; 美化URL：类似于短域名的作用 最佳实践寻找一种避免重定向的方法","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"img标签的src为一个远程图片的base64编码","date":"2017-12-15T02:55:57.000Z","path":"tips/ckbdbl44h00992ktynwe29i0q.html","text":"问题：img标签的src为一个远程图片的base64编码 在修改一个fork的项目时，有一个展示用户头像的地方，用的是后端一个判断处理后返回图片编码的url。原先的内容是从本地读取，现在需要改成从一个远端获取的图片地址。 解决方法方法如下：request请求图片url返回的response body本身就可以直接使用。不过当时在编码部分饶了很久。 1234567891011121314151617181920212223242526272829303132async avatar(ctx) &#123; try&#123; // ... let dataBuffer, type; const uri = 'https://***.google.cn/img/userPic/user_id.jpg'; const options = &#123; \"uri\": uri, \"strictSSL\": false, // 关键在这里 \"encoding\": null &#125; try &#123; // getPromiseByAjaxRequest 返回的是 request.body let getImage = await common.getPromiseByAjaxRequest(options); dataBuffer = getImage; type = 'image/jpeg'; // 二进制转为base64编码 // dataBuffer = getImage.toString('base64'); // 如果使64编码，应该要加上data:image/jpg;base64,这个前缀。 // ！！！！！！这个暂时未测试，后续测下 &#125; catch(e) &#123; // 默认头像 dataBuffer = fs.readFileSync(path.join(WEBROOT, 'static/image/avatar.png')); type = 'image/png' &#125; ctx.set('Content-type', type); ctx.body = dataBuffer; &#125;catch(err)&#123; ctx.body = 'error:' + err.message &#125;&#125; request包option中encoding的解释如下： encoding - encoding to be used on setEncoding of response data. If null, the body is returned as a Buffer. Anything else (including the default value of undefined) will be passed as the encoding parameter to toString() (meaning this is effectively utf8 by default). (Note: if you expect binary data, you should set encoding: null.) 也就是说传null的时候，会返回一个二进制数据构成的Buffer。 补充下：貌似二进制的转码不能用缓存还是localstorage，base64可以，这个之后要试下","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"image","slug":"image","permalink":"https://zj-john.github.io/tags/image/"},{"name":"base64","slug":"base64","permalink":"https://zj-john.github.io/tags/base64/"}]},{"title":"node中export一个异步函数","date":"2017-12-14T04:07:45.000Z","path":"tips/ckbdbl444008j2kty4ofanj1i.html","text":"问题：node中export一个异步函数 开发中遇到需要把一个异步函数写到common中，然后export出来的情况。方法如下： single callback1234567891011121314151617181920212223// module.js// foo:需要经过异步函数处理后的值// callback: 得到异步处理后的foo值后 需要执行的操作var foo, callback;someAsyncFunction(function(response) &#123; // 执行到这里，说明异步函数已经完成 foo = \"the value after async\"; // 执行进if说明 上次来调用时 异步还未执行完成 if( typeof callback == 'function' )&#123; callback(foo); &#125;&#125;);// cb是外部传入的callbackmodule.exports = function(cb)&#123; if(typeof foo != 'undefined')&#123; cb(foo); &#125; else &#123; // 当前异步还未执行完成，把cb储存在callback中 callback = cb; &#125;&#125; 12345// main.jsvar fooMod = require('./foo.js');fooMod(function(foo)&#123; //Here code using foo;&#125;); mutiple callback多个callback函数，非链式。 123456789101112131415161718// module.jsvar foo, callbackList = [];someAsyncFunction(function(response) &#123; foo = \"the value after async\"; // 循环调用当前的积累的callback函数 for(var i = 0; i &lt; callbackList.length; i++)&#123; callbackList[i](foo) &#125;&#125;);module.exports = function(cb)&#123; if(typeof foo != 'undefined')&#123; cb(foo); &#125; else &#123; callback.push(cb); &#125;&#125; 12345// main.jsvar fooMod = require('./foo.js');fooMod(function(foo)&#123; //Here code using foo;&#125;); promiseES6最优方式 1234567891011// module.jsconst asyncFunc = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // Where someAsyncFunction takes a callback, i.e. api call someAsyncFunction(data =&gt; &#123; resolve(data) &#125;) &#125;)&#125;export default asyncFunc 123// main.jsimport asyncFunc from './asyncFunc'asyncFunc().then(data =&gt; &#123; console.log(data) &#125;)","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"export","slug":"export","permalink":"https://zj-john.github.io/tags/export/"},{"name":"asynchronous","slug":"asynchronous","permalink":"https://zj-john.github.io/tags/asynchronous/"}]},{"title":"生产环境disable console log","date":"2017-12-13T07:08:55.000Z","path":"tips/ckbdbl446008o2kty1pbdp2xx.html","text":"问题：生产环境disable console log 开发和测试环境中会用到大量console.log方法来进行代码的调试，但生产上需要关闭这些输出。有以下几种方法。 Hack方法这应该是最容易想到的方法，直接改写console.log的方法。1234if (!DEBUG_MODE_ON) &#123; console = console || &#123;&#125;; console.log = function()&#123;&#125;;&#125; DEBUG 参数控制这种方式比较灵活，不过对于新接入的应用需要来一次全局的替换。1234// beforeconsole.log(\"output\");// afterDEBUG &amp;&amp; console.log(\"output\"); webpack等构件工具中配置以webpack为例，使用UglifyJsPlugin插件 12345678910[ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; // 在这里处理 drop_console: true &#125; &#125; &#125;)] 其它的compress options的取值点此","tags":[{"name":"console","slug":"console","permalink":"https://zj-john.github.io/tags/console/"},{"name":"production","slug":"production","permalink":"https://zj-john.github.io/tags/production/"}]},{"title":"高性能网站建设指南-笔记（八）","date":"2017-12-12T07:03:11.000Z","path":"notes/ckbdbl437006k2ktyfzkm6o2k.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则10-精简JavaScript 缩短响应时间 代码示例 精简去除所有注释、空白（空行、空格、换行、制表符） 混淆 原理：精简 + 改写代码（更改函数、变量名） 缺点：难于调试、本身可能引入错误、有些命名不能改 建议精简而非混淆 在结合了gzip之后，精简和混淆之间的差别将会减小 其它方法 内联JS精简 gzip：压缩效果优于精简 精简CSS： 删除注释、空白 合并相同类，移除不使用的类(复杂，不建议使用) 使用缩写（0px-&gt;0;#606-&gt;#660066）","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"编写可维护的JavaScript-笔记","date":"2017-12-11T04:36:42.000Z","path":"notes/ckbdbl42x00632ktykeaemn04.html","text":"编码规范缩进 空格 or Tab缩进，建议 4 空格为1个缩进。 空格、Tab勿混用 换行缩进：12345678910111213141516// function 参数换行 结尾分号，前边8空格（2缩进）callAFunction(document, element, window, &quot;some input string&quot;, true, 123, navigator);// 逻辑语句if (isLeapYear &amp;&amp; isFebruary &amp;&amp; day === 29 &amp;&amp; live) &#123; happyBirthDay();&#125;// 变量赋值 对齐let name = &quot;z_j&quot;, email = &quot;z_j@ctrip.com&quot;;// object 1缩进let book = &#123; title: &quot;HTML&quot;, author: &quot;zs&quot;&#125; 空行 方法间 赋值和方法间 注释前 方法内逻辑段落间 命名（驼峰式） 常量：大写 + 下划线 MAX_COUNT 变量：前缀名字 myName ：尽可能有意义，如果不好在字面体现含义，可加注释说明 函数：前缀动词 getName, isEnable 构造函数：大驼峰式 ApplicationList null（对象的占位符）：返回 、判断 undefined避免人为使用undefined 注释写给他人、写给自己 if, for, while, do…while…, try…catch…finally 使用花括号 风格 12345678910111213141516// googleif (isSuccess &amp;&amp; data.length&gt;0) &#123;&#125;// jqueryif ( isSuccess &amp;&amp; data.length&gt;0 ) &#123;&#125;for...in...:只用于遍历对象，且同时使用 hasOwnProperty()let prop;for (prop in object) &#123; if (object.hasOwnProperty(prop)) &#123; console.log(\"Property name is \" + prop); console.log(\"Property value is \" + object[prop]); &#125;&#125; 声明 一个逻辑块中，变量声明提到顶部，并且合并 函数声明放在变量声明之后 函数 函数调用：doSomething(params) 无空格 立即执行函数用一对括号包裹起来（其本质相当于语句） 严格模式“use strict“ 不要放在全局作用域，可以放在立即执行函数中（加一层作用域） 检查点： 句尾分号 单行长度（仿java规范，小于80字符） === or !== “” or ‘’ 统一，可以设立默认约定为“”双引号 实践规范解耦 三元组解耦 - JS-HTML（事件绑定、JS外置、Template），CSS-HTML(CSS外置) 无耦合 NO Impossible 避免使用全局变量（作用域污染） 函数内部不使用外部变量，以参数传入 单全局变量：类库 JQuery $ 零全局变量：立即执行函数1234(function(win) &#123; let doc = win.document; // other code&#125;(window)); 事件处理 隔离应用逻辑和用户行为 最小需要 1234567891011121314151617let MyApplication = &#123; handleClick: function(event) &#123; // 清除事件污染 event.preventDefault(); event.stopPropagation(); // 应用逻辑 this.showPopup(event.clientX, event.clientY); &#125;, showPopup: function(x, y) &#123; // 内部逻辑 &#125;&#125;;addListener(element, \"click\", function(event) &#123; MyApplication.handleClick(event);&#125;); 值检测： typeof :原始值检测 instanceof:引用值检测 in: 属性检测123456if (\"name\" in object) &#123; // 逻辑&#125;// errorif (object[\"name\"]) &#123;&#125; 配置数据分离 常见配置数据： URL，重复的值，设置，展示给用户的值 （统一性） 123456789101112131415161718192021222324252627282930// 当前export const status_render = function(data, type, full, row, meta) &#123; if (!data) &#123; return '-' &#125; let statusType if (data === 'NORMAL') &#123; statusType = `&lt;span class=\"label webinfo-label-normal\"&gt;正常&lt;/span&gt;` &#125; else if (data === 'FROZEN') &#123; statusType = `&lt;span class=\"label webinfo-label-warning\"&gt;冻结&lt;/span&gt;` &#125; return statusType&#125;// 改进const STATUS_RENDER_CONFIG = &#123; \"NORMAL\": &#123; \"text\": \"正常\", \"label\": \"label-normal\", \"icon\": \"fa-normal\" &#125;&#125;;export const status_render = function(data, type, full, row, meta) &#123; let statusType = `&lt;span class=\"label\"&gt;-&lt;/span&gt;`; if(data in STATUS_RENDER_CONFIG ) &#123; statusType = `&lt;span class=\"label $&#123; STATUS_RENDER_CONFIG[data.toUpperCase()]['label'] &#125;\"&gt;$&#123; STATUS_RENDER_CONFIG[data.toUpperCase()]['text'] &#125;&lt;/span&gt;` &#125; return statusType;&#125; 储存：JSON、JS 抛错 throw new Error(“message”) try…catch 协作 不要随意更改（覆盖、新增、删除）非自己创建的对象，包含：原生对象（Object、Array等）、DOM、BOM、类库 如果确实需要，请继承 工具 JSLint :最早，可定制型差，不建议使用 JSHint：可配置参数定制，不支持自定义规则 ESlint： 默认使用JSHint的规则，支持自定义。推荐","tags":[{"name":"编写可维护的JavaScript","slug":"编写可维护的JavaScript","permalink":"https://zj-john.github.io/tags/编写可维护的JavaScript/"}]},{"title":"vagrant up 命令无反应","date":"2017-12-07T02:18:30.000Z","path":"tips/ckbdbl445008m2ktyso065cgv.html","text":"问题：vagrant up 命令无反应 由于开源项目的需要，要在windows下设置linux开发环境，同事介绍了vagrant这款软件。安装vagrant的过程中，设置好box，init后，使用vagrant up命令启动时，无报错，无反馈。 解决方法使用debug参数查看up命令的详细过程1vagrant up --debug 发现卡在如下输出上：1234INFO subprocess: Starting process: [&quot;C:\\windows\\System32\\WindowsPowerShell\\v1.0\\/powershell.EXE&quot;, &quot;-NoLogo&quot;, &quot;-NoProfile&quot;, &quot;-NonInteractive&quot;, &quot;-ExecutionPolicy&quot;, &quot;Bypass&quot;, &quot;-Command&quot;, &quot;(new-object System.Security.Principal.WindowsPrincipal([System.Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)&quot;]INFO subprocess: Command not in installer, restoring original environment...DEBUG subprocess: Selecting on IODEBUG subprocess: stdout: False 看起来像是powershell的问题，在vargrant的issue上找了下，看大神们的解答是因为powershell版本的问题。使用以下命令查看，win7默认版本是powershell 2。通过补丁update版本到5.0。1$PSVersionTable.PSVersion 之后再vagrant up就可以成功了。 其它问题目前已实现可以通过端口映射、ip映射的方式把node后端、react前端映射到win7自己的浏览器中，不过有一个问题是hot server无法映射到win7的浏览器上，每次更新后要手动刷新。","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://zj-john.github.io/tags/vagrant/"},{"name":"powershell","slug":"powershell","permalink":"https://zj-john.github.io/tags/powershell/"}]},{"title":"react 利用根目录进行引用组件","date":"2017-12-05T04:25:12.000Z","path":"tips/ckbdbl44000892ktyex74sggp.html","text":"问题：react 利用根目录进行引用组件 react中由于使用node的引用方式，所以经常会跨各种文件夹引用，比如：12import ActionWizard from &quot;../../../components/forms/wizards/ActionWizard&quot;;import UiValidate from &quot;../../../components/forms/validation/UiValidate&quot;; 这种方式写起来和修改起来相当麻烦。 解决方法使用webpack中的alias方法配置别名：1234567891011const path = require(&apos;path&apos;);module.exports = &#123; ... resolve: &#123; alias: &#123; &apos;ComponentsRoot&apos;: path.resolve(__dirname, &apos;./src/app/components&apos;) &#125;&#125;, ...&#125;; 然后在引用时，方式如下：12import ActionWizard from &quot;ComponentsRoot/forms/wizards/ActionWizard&quot;;import UiValidate from &quot;.ComponentsRoot/forms/validation/UiValidate&quot;;","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://zj-john.github.io/tags/webpack/"}]},{"title":"angular中rowspan样式","date":"2017-12-04T03:30:32.000Z","path":"tips/ckbdbl443008g2kty0vrx04g0.html","text":"问题：angular中rowspan样式 本文探讨了angular框架中原生table和ngTable中rowspan的用法。 原生的table使用方法：1234567891011121314151617&lt;table border=1&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Group&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Gender&lt;/th&gt; &lt;th&gt;Status&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody ng-repeat=\"group in groups\"&gt; &lt;tr ng-repeat=\"member in group.members\"&gt; &lt;td rowspan=\"3\" ng-if=\"!($index%3)\"&gt;&#123;&#123;group.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; member.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; member.gender &#125;&#125;&lt;/td&gt; &lt;td rowspan=\"3\" ng-if=\"!($index%3)\"&gt;&#123;&#123;group.status&#125;&#125;&lt;/td&gt; &lt;/tbody&gt;&lt;/table&gt; 1234567891011121314151617181920function Ctrl($scope) &#123; $scope.groups = [ &#123; name: 'Employees', members: [ &#123; name: 'John', gender: 'M'&#125;, &#123; name: 'Jane', gender: 'F'&#125;, &#123; name: 'John', gender: 'M'&#125; ], status: 'Active' &#125;, &#123; name: 'Pets', members: [ &#123; name: 'Rex', gender: 'M'&#125;, &#123; name: 'Lucy', gender: 'F'&#125;, &#123; name: 'Rex', gender: 'M'&#125; ], status: 'Active' &#125; ];&#125; ngTable中使用方法：一般用法12345678910111213141516171819202122232425262728&lt;table ng-table=\"page.tableParams\" class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;选择&lt;/th&gt; &lt;th&gt;策略&lt;/th&gt; &lt;th&gt;IP&lt;/th&gt; &lt;th&gt;权重&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody ng-repeat=\"d in $data\"&gt; &lt;tr ng-repeat=\"line in d.line_list\"&gt; &lt;td class=\"text-center\" rowspan=\"3\" ng-if=\"!($index%3)\" &gt; &lt;div class=\"checkbox checkbox-primary\"&gt; &lt;input id=\"akamai_source_select_&#123;&#123; d.name &#125;&#125;\" checked=\"false\" type=\"checkbox\" ng-model=\"d.checked\" class=\"form-control\"&gt; &lt;label for=\"akamai_source_select_&#123;&#123; d.name &#125;&#125;\"&gt;&lt;/label&gt; &lt;/div&gt; &lt;/td&gt; &lt;td class=\"text-center\" rowspan=\"3\" ng-if=\"!($index%3)\" sortable=\"'name'\"&gt;&#123;&#123; d.name &#125;&#125;&lt;/td&gt; &lt;td class=\"text-center\"&gt;&#123;&#123; line.ip &#125;&#125;&lt;/td&gt; &lt;td class=\"text-center\"&gt;&#123;&#123; line.weight &#125;&#125;&lt;/td&gt; &lt;td class=\"text-center\"&gt; &lt;button class=\"btn btn-warning btn-sm\" ng-click=\"page.log(d.domain)\" ng-if=\"line.enable\"&gt;关闭&lt;/button&gt; &lt;button class=\"btn btn-primary btn-sm\" ng-click=\"page.log(d.domain)\" ng-if=\"!line.enable\"&gt;开启&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 123456789101112131415vm.data = [ &#123; name:\"ctslb-wspci-fq-peng\", line_list:[ &#123;\"enable\":true , \"weight\":1.0, \"ip\":\"1.1.1.1\"&#125;, &#123;\"enable\":true, \"weight\":1.0, \"ip\":\"1.1.1.1\"&#125;, &#123;\"enable\":true, \"weight\":1.0, \"ip\":\"1.1.1.1\"&#125; ] &#125;];vm.tableParams = new NgTableParams(&#123; count : 10 &#125;, &#123; dataset: vm.data&#125;); ngTable中的问题上面的写法中其实有个问题：对于ngTable来说，其实是不需要&lt;thead&gt;的，一般写法：使用title属性来定义列标题。123456789&lt;table id=\"akamai_line_table\" ng-table=\"page.tableParams\" class=\"table\"&gt; &lt;tbody ng-repeat=\"d in $data\"&gt; &lt;tr ng-repeat=\"line in d.line_list\"&gt; &lt;td title=\"'#'\" class=\"text-center\" rowspan=\"3\" ng-if=\"!($index%3)\" sortable=\"'name'\"&gt;&#123;&#123; d.name &#125;&#125;&lt;/td&gt; &lt;td title=\"'type'\" class=\"text-center\" sortable=\"'line.type'\"&gt;&#123;&#123; line.type &#125;&#125;&lt;/td&gt; &lt;td title=\"'enable'\" class=\"text-center\" sortable=\"'line.enable'\"&gt;&#123;&#123; line.enable&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 但是在使用这种方法时会发现一个问题，就是：当有两个列需要rowspan时，如果使用title定义标题，第二个使用rowspan的列的标题会无法展示，后续的标题会前提，所以最终结果是最后一列无标题。 给自己：记得提个issue问下","tags":[{"name":"ngTable","slug":"ngTable","permalink":"https://zj-john.github.io/tags/ngTable/"},{"name":"angular","slug":"angular","permalink":"https://zj-john.github.io/tags/angular/"},{"name":"rowspan","slug":"rowspan","permalink":"https://zj-john.github.io/tags/rowspan/"}]},{"title":"高性能网站建设指南-笔记（八）","date":"2017-12-03T06:45:52.000Z","path":"notes/ckbdbl439006o2ktyeh0wiy3e.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则9-减少DNS查找 缩短响应时间 代码示例 DNS缓存和TTL DNS查找可以被缓存起来以提高性能。包括不限于局域网中的缓存服务器（ISP），操作系统缓存，浏览器缓存 浏览器拥有自己的缓存记录，来直接减少浏览器查找DNS记录的时间。如果没有缓存记录，会向上层继续查找缓存 域名对应的IP地址会变化，所以应该周期性的清除缓存中的DNS记录 影响DNS缓存的因素 TTL：查找返回的DNS记录中包含了一个存活时间（TTL），告诉客户端这个记录可以缓存多久。 浏览器一般会忽略这个值，并设置自己的时间限制。keep-alive特性同时覆盖TTL和浏览器的时间限制。 浏览器对缓存记录的数量有限制。如果访问较多不同域名，较早的DNS记录会被删除。（操作系统可能依然保留有该记录,所以会继续较少DNS查询的开销） TTL的值网站发给客户端的最大TTL值在1min到1h之间，取决于网站的配置。 客户端收到的DNS记录的平均TTL值只有最大TTL值的一半。当浏览器进行DNS查找时，DNS解析器返回的时间是其记录的TTL的剩余时间。如果最大TTL是5min，DNS解析器返回的TTL范围可能是1~300s，平均是150s。对于给定的主机名，每次执行DNS查找时接收到的TTL的值会变化。 浏览器的视角windows的缓存命令：1234// 查看ipconfig /displaydns// 刷新ipconfig /flushdns IE通过修改注册表修改配置值,位置如下：HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\InternetSettings\\ DNSCacheTimeout：30min - DNS缓存时间 KeepAliveTimeout：1min - TCP连接允许空闲的时间 ServerInfoTimeout：2min - 尽管没有Keep-Alive，如果一个域名每2min重用了一次，并且没有发生错误，也无需进行DNS查找 FirefoxFirefox的参数配置 network.dnsCacheExpiration: 1h network.dnsCacheEntries: 512 - 可缓存的记录数 network.http.keep-alive.timeout: 30s 减少DNS查找 减少唯一主机名的数量（相当于减少并行下载，可能会增加响应时间 建议是将页面组件分别放到至少2个，但不要超过4个主机名下 Keep-Alive通过重用现有连接，避免了TCP/IP开销，同时可以减少DNS查找 最佳实践通过使用Keep-Alive和较少的域名来减少DNS查找","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"Ubuntu开发环境配置","date":"2017-11-28T10:33:08.000Z","path":"notes/ckbdbl40q001q2ktysk7k7vri.html","text":"最近由于想二次开发YAPI的功能，由于了解到YAPI只能在MAC或LINUX系统上运行，windows上有些依赖无法安装，所以在自己的WIN7 PC上通过VMware安装Ubuntu的虚拟机。一些问题记录如下： 安装VMware Workstations，下载Ubuntu镜像安装虚拟机的步骤不再讲述。 vmware虚拟机显示屏幕太小文档 无法手动启动VMware Tools安装文档 安装nodejs文档 Python的安装和使用文档 Atom编辑器文档 使用root登陆帐户文档 读取/root/.profile时发现错误文档 部署MongoDB文档","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zj-john.github.io/tags/Ubuntu/"},{"name":"Node","slug":"Node","permalink":"https://zj-john.github.io/tags/Node/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://zj-john.github.io/tags/MongoDB/"}]},{"title":"高性能网站建设指南-笔记（七）","date":"2017-11-27T03:58:23.000Z","path":"notes/ckbdbl432006a2ktyemiot8rs.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则8-使用外部JavaScript和CSS 提高用户体验 代码示例 内联 VS 外置 内联： 减少了HTTP请求次数，但是增大了HTTP文档的大小，难以缓存 外置： 增加了HTTP请求次数一次，但是可以缓存 选择： 与HTML文档请求数量相关的，外部JavaScript和CSS组件被缓存的频率 纯粹而言，内联快一些 衡量用户查看 用户产生的页面查看越少，越适合使用内联JS和CSS。（不会造成外部文件的复用，即无需使用缓存） 用户产生很多的页面查看，浏览器很可能将外部文件放入缓存。次数越多，外置JS和CSS的利益越大 空缓存 VS 完整缓存如果网站本质上能够为用户带来高完整缓存率，使用外部文件的收益就更大。如果不大可能产生完整缓存，则内联是更好的选择。 也就是说，如果一个网站的各个页面的外部文件是公用的，比如用户第一次是空缓存，之后的多次后续页面查看会具有完整缓存。那么使用外部文件是值得的。如果每个页面的可复用外部文件很少，后续页面都相当于一个新页面，那么就选择内联。一般来说，第一种类型的网站更多。 组件重用这个问题在于：把JS和CSS打包到外部文件时，边界如何划分。分为以下几种： 各个页面的文件独立保存，完全分离。（适用于很少进行跨页访问的网站） 把所有文件打包为一个文件：增大首次下载量；部分代码更新时，影响整体的缓存更新。（适用于每用户每月会话数量较高，普通用户在一个会话中访问多个不同页面的网站。一次下载，多次缓存） 折中方式：部分合并打包，部分单独下载。取决于前端代码中JS和CSS的依赖情况。 最佳方案根据作者对网站结果的度量，对一般的网站（上述1，2的情况）而言，最好的解决方案通常是将JS和CSS部署到外部文件中，且带有Expires头来保持缓存。 主页 页面查看数量唯一 空缓存比例高 很多主页是用户到网站访问的唯一一个页面，谈不上重用基于此，对于网站主页来说，更倾向于使用内联的方式。 利用外部文件得到内联的收益加载后下载为download加一个延时，确保页面呈现完毕后，再下载。（用于初始页后还需要访问其它页面） 1234567891011121314151617181920212223function doOnload()&#123; setTimeout(\"download()\", 1000)&#125;windows.onload = doOnload;function download() &#123; // 执行下载 downloadJS(url); downloadCSS(url);&#125;// 脚本中不应包含立即执行的内容，对用户感知function downloadJS(url) &#123; var elem = document.createElement(\"script\"); elem.src = url; document.body.appendChild(elem);&#125;//不应使用相对单位，可能对页面产生影响，将组件放到一个不可见的IFrame中是一种更好的方式（不赞同）function downloadCSS(url) &#123; var elem = document.createElement(\"link\"); elem.rel = \"stylesheet\"; elem.type = \"text/css\"; elem.href = url; document.body.appendChild(elem);&#125; 动态内联利用cookie等作为指示器，来表明使用内联还是外置。没有cookie的时候，使用内联（首次加载），并写cookie。之后从外部加载。即便cookie的状态和缓存状态不匹配，也不会影响页面工作，只是没有那么优化。","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（六）","date":"2017-11-24T06:56:49.000Z","path":"notes/ckbdbl43d006x2kty2hjbyj6s.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则7-避免CSS表达式 提高用户体验 代码示例 由于CSS表达式目前不在被各大浏览器支持，所以这一规则无需使用。 CSS表达式CSS表达式如下，利用expression方法可以使用js语法动态计算一些内容。 1div.title &#123; background-color: expression( (new Date()).getHours()%2 ? \"#B8D4FF\" : \"#F08A00\" ); &#125; 这种方法只在老版本的IE支持。根据IE规定，IE8之后也不再支持。表达式的缺点及不再支持的原因见文档。 最佳实践 不使用CSS表达式（无需额外注意） 动态调整CSS的需求可以在js中利用DOM实现","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（五）","date":"2017-11-23T04:07:39.000Z","path":"notes/ckbdbl43e00712ktyxcxdszue.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则5-将脚本放在底部展示 提高用户体验 代码示例 脚本带来的问题脚本也会为上节讲到的可视化带来问题，因为使用脚本时，所有位于脚本以下的内容，逐步呈现都被阻塞了。所以将脚本放在越靠下的位置，意味着可以逐步呈现越多的内容。 脚本会阻塞对其后面内容的呈现 脚本会阻塞对其后面组件的下载 并行下载 HTTP1.1规范：建议浏览器从每个主机名并行的下载两个组件。 根据HTTP1.1的规范，如果把资源从一个主机名下平均的移到两个主机名下，响应时间可以减少大约一半。 HTTP1.1的规范对浏览器只是一个建议，用户可以根据浏览器提供的配置操作来调整这一默认配置。但这种配置依赖于用户的浏览器，不能从服务器端主动触发。 使用多个主机名的话受限于带宽和CPU速度，过多的并行下载反而会降低性能。根据作者推荐，2个主机名比使用其它个数更能带来更好的性能。 在下载脚本(注：图片等其它资源是可以的)时并行下载实际上是被禁用的，即使使用了不同的主机名，浏览器也不会启动其它的下载。主要是为了保证脚本能够按照正确的顺序执行，因为脚本间可能存在着依赖关系。 最佳实践将脚本移到页面底部,&lt;/body&gt;标签前。","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（四）","date":"2017-11-22T02:22:28.000Z","path":"notes/ckbdbl43i00792ktys2yvcbx6.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则5-将样式表放在顶部 提高用户体验 代码示例 可视化可视化回馈对用户来说很重要，它可以告诉用户 系统是否崩溃 还需要等多久 可以看到进度的变化，使得等待不那么无聊 对web来说，HTML页面就是进度指示器，当浏览器逐步加载的时候，会为等待页面的用户提供视觉反馈，改善整体体验。 按照逻辑上讲，将样式放在页面的底部（&lt;body&gt;之前），可以使HTML先加载，用户体验会变好。但实际上并非如此，浏览器和用户等待位于底部的样式表时，浏览器会延迟加载显示任何可视化组件，导致白屏（只发生在Internet Explorer中，并且依赖于页面如何加载）。将样式表放在文档底部会导致在浏览器中组织内容逐步呈现。为避免当样式变化是重绘页面中的元素，浏览器会阻塞内容的逐步呈现。 如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析完全之前无需绘制任何东西。否则，在其准备好之前显示内容会遇到FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题 Sleep.cgi为了展示延迟组件如何影响Web页面，作者开发了一个Perl CGI脚本。下载 和 源码 参数： sleep: 将响应延时多少s。默认0s type: 返回的组件类型，可取值gif、js、css、html、swf。默认gif expires: -1:返回一个已经过时的Expires头(避免被缓存)；0:不返回Expires头；1:返回一个未来的Expires头。默认值为1 last: -1：返回一个Last-Modified头，其时间戳和文件的时间相等；0：不返回Last-Modified头。默认值为-1 redir: 1:产生302响应，重定向回同样的不带redir=1的URL 使用方法：123&lt;!-- 做一个慢速的图片和样式加载 --&gt;&lt;img src=\"/bin/sleep.cgi?type=gif&amp;amp;sleep=2&amp;amp;expires=-1&amp;amp;last=0&amp;amp;imagenum=1&amp;amp;t=1511320646\" height=\"20\"&gt;&lt;link rel=\"stylesheet\" href=\"/bin/sleep.cgi?type=css&amp;amp;sleep=1&amp;amp;expires=-1&amp;amp;last=0\"&gt; 最佳实践使用&lt;link&gt;标签将样式表放在文档的HEAD中 将样式表包含在文档中有Link和@import两种方式。经样例测试，@import的样式表即使放在head中，也依然是最后下载的（@import导致的组件下载无序性），所以会产生白屏。所以推荐使用Link的方式加载外部样式。 唯一例外： 如果你的样式表不要求呈现页面，可以想办法在文档加载完毕后动态加载进来，详见规则8","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（三）","date":"2017-11-21T04:02:25.000Z","path":"notes/ckbdbl43b006u2kty228xxtoy.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则4-压缩组件 缩减http数据包大小 代码示例 目的： 减小页面大小，缩短网络响应时间 方法：gzip是目前最流行最有效的压缩方法 12345//浏览器头声明支持压缩Accept-Encoding:gzip,deflate//服务器头确认响应已被压缩Content-Encoding:gzip 效果：压缩通常能将相应的数据量减少近70% 压缩规则： HTML、JS、CSS、XML、JSON建议压缩，其中JS、CSS最为普遍 图片、PDF不建议压缩，因为它们本来就已经压缩了，试图再次压缩只会浪费CPU资源，还有可能增大文件大小 通常对大于1KB或2KB的文件进行压缩。可以在服务端（nginx、apache等）进行配置. 书中提到的配置方法由于版本过老，不再记录。需要的话可以在各个web服务器软件的配置文件中学习。截止本文记录时，最新的配置方法见：Apache、Nginx 代理缓存 描述：当浏览器通过代理发送请求时，由于不同请求的来源浏览器对压缩的支持不一样，有可能造成代理上一份资源的缓存无法满足所有的客户端浏览器。 方法：web服务器的响应中添加Vary头。web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。Vary头的内容可以多种多样。 12// 服务器头(response) Vary包含Accept-Encoding表示返回浏览器时，可以使用压缩过的资源。Vary不带这个标志，表示使用未压缩过的资源Vary: Accept-Encoding 边缘情形描述只为已经证实过支持压缩的浏览器提供压缩内容，这被称作浏览器白名单方式 方法可以在web服务器配置文件中，根据User-Agent来判断是否支持压缩;如果使用代理，可以在Vary头中加入User-Agent来综合判断。 12// 这里的User-Agent指的是具体的浏览器的UserAgent的值，如MozillaVary: Accept-Encoding, &#123;User-Agent&#125; 缺点UserAgent有上千种值，代理不太可能对每一种组合进行缓存。这实际上破坏了代理缓存。 最佳实践 如果用户较少，且浏览器行为相似。或者你更注意带宽开销，可以使用Vary:Accept-Encoding来支持压缩 如果你的用户群量级大且多变，能够应付较高的带宽开销，可以使用Cache-Control:Private (Belongs to Response Header)来禁用代理缓存","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（二）","date":"2017-11-20T02:28:40.000Z","path":"notes/ckbdbl43a006q2kty7f1rwmun.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 规则2-使用内容发布网络(CDN) 缩短http的响应时间 代码示例 使用CDN优于尝试使用分布式架构重新设计你的web程序，后者会出现同步会话状态，数据库同步等复杂问题 知名的付费CDN供应商：Akamai、Mirror Image、SAVVIS、Limelight 免费CDN供应商：Globule，CoDeeN，CoralCDN CDN用于发布静态内容，如图片、脚本、样式表、Flash，不用于动态（数据库连接、状态管理、验证等） 优点：缩短响应时间、备份、扩展存储、缓存等 缺点：可能会受其他网站影响，因为节点是公用的；有些配置需要依赖于供应商 方式：可以同时接入两家CDN供应商，用于backup和防灾测试CDN的功能需要在多个地理位置上测量响应时间。国内可以使用免费测试工具如17CE，奇云测。还有付费测试工具基调 规则3-添加Expires头 减少http请求 代码示例 目的：利用浏览器的缓存能力,减少HTTP请求 Expires Response Header 优点：请求到期前不会再发送HTTP请求 缺点：需要服务器和客户端时钟严格同步；过期时间需要检查；过期时间定期更新 什么时候304，什么时候200（from cache）？？？ Max-Age &amp;&amp; mod_expiresMax-Age Response Header 为了解决Expires头的缺点，HTTP1.1（注：之前的版本不支持）引入Cache-Control头。可以使用头的Max-Age指令指定组件被缓存多久，以s为单位。如果从组件被请求开始过去的秒数少于max-age，浏览器就使用缓存版本。 1Cache-Control: max-age=315360000 HTTP规范规定，如果max-age和Expires同时出现，max-age将重写Expires头。 mod_expires mod_expires是Apache提供的一种配置方法，可以通过ExpiresDefault指令来设置Expires头。（Apache进行了封装，使能够像max-age那样以相对日期设置Expires头） 空缓存 VS 完整缓存 空缓存和完整缓存指的是与页面相关的浏览器缓存的状态。页面组件没在缓存中则为空缓存，对立的是完整缓存。 提出这两个概念的作用是告诉你缓存很重要……，然后请优化完整缓存（对所有的请求都尽可能使用缓存） 不仅仅是图片 长久的Expires头应该包括图片、及不经常变化的JS、CSS、Flash等。 大部分网站 图片、JS、CSS可缓存30天以上，可以根据网站的需要自己定义。 修订文件名 为了获取更新，可以更新组件的文件名来使浏览器重新获取资源，例如加入版本号 一个具有长久Expires头的组件会被缓存后续浏览器可从硬盘上直接读取。如果一个组件没有Expires头，它仍然会存储在缓存中，在后续请求时，浏览器会检查缓存并发现这个组件已过期。为了提高效率，浏览器会向原始服务器发送一个get请求，如果组件虽然过期但是没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头（304 Not Modified）告诉浏览器可以使用缓存的组件。","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"高性能网站建设指南-笔记（一）","date":"2017-11-17T02:52:50.000Z","path":"notes/ckbdbl436006h2ktydd67i7rn.html","text":"总览本书介绍了提高网站性能的14条规则： 减少HTTP请求 使用内容发布网络 添加Expires头 压缩组件 将样式表放在顶部 将脚本放在底部展示 避免CSS表达式 使用外部JavaScript和CSS 减少DNS查找 精简JavaScript 避免重定向 移除重复脚本 配置ETag 使Ajax可缓存 本书配套实例：点此访问 绪言本书有两个绪言，记录如下： 绪言A：前端性能的重要性性能黄金法则：从web服务器获取HTML文档，到呈现在浏览器只花费10%~20%的响应时间（后端），需要关注剩余80%~90%的响应消耗（前端，HTML文档所引用的各个组件：CSS、JS、IMAGE等）。 对网站性能来说，前端的优化成本和效果优于后端。 绪言B：HTTP概述熟悉HTTP协议可以带来更多可优化的点。例如： 压缩 1234//浏览器头声明支持压缩Accept-Encoding:gzip,deflate//服务器头确认响应已被压缩Content-Encoding:gzip 使用缓存：304 Not Modified 缓存有效性源自其最后修改时间。1234//浏览器头。浏览器发送最后修改时间给服务器端,询问我可以继续使用这个文件么If-Modified-Since: Fri, 17 Nov 2017 12:20:12 GMT//服务器头。服务器确认这个文件从上次修改时间到现在是否修改过，如果没有修改，则发送304，不再发送响应体Last-Modified: Fri, 17 Nov 2017 12:20:12 GMT Expires 304可以让页面加载的更快，但仍然需要在客户端和服务器之间进行一次往返确认。使用Expires头可以消除这个需要。 12//首次请求时，服务器头返回这个资源的过期时间。浏览器在这个过期时间之前不再重新发送请求，而是从缓存中获取资源Expires: Sat, 18 Nov 2017 12:20:12 GMT Keep-Alive 一个连接上进行多个请求。12345//浏览器头 Connection来指出对Keep-Alive的支持Connection: keep-alive//服务器头 Connection来指出对Keep-Alive的支持Connection: keep-alive// 关闭连接时，浏览器或服务器可以发送Connection: close 头来关闭连接 规则1-减少HTTP请求代码示例 图片地图（Image Map） 目的：减少图片的请求数。 方法：使用标签，将原先分散的多张图片合并为一张传输，通过map的方式指定不同部位不同动作。 缺点：图片必须是连续的。精确定义区域比较困难，一般定义为矩形区域。 12345678910&lt;center&gt; &lt;img usemap=\"#map1\" border=\"0\" src=\"/images/imagemap.gif\"&gt; &lt;map name=\"map1\"&gt; &lt;area shape=\"rect\" coords=\"0,0,31,31\" href=\"javascript:alert('Home')\" title=\"Home\"&gt; &lt;area shape=\"rect\" coords=\"36,0,66,31\" href=\"javascript:alert('Gifts')\" title=\"Gifts\"&gt; &lt;area shape=\"rect\" coords=\"71,0,101,31\" href=\"javascript:alert('Cart')\" title=\"Cart\"&gt; &lt;area shape=\"rect\" coords=\"106,0,136,31\" href=\"javascript:alert('Settings')\" title=\"Settings\"&gt; &lt;area shape=\"rect\" coords=\"141,0,171,31\" href=\"javascript:alert('Help')\" title=\"Help\"&gt; &lt;/map&gt;&lt;/center&gt; CSS Sprites 目的：合并图片，减少图片请求数 方法：利用span或者div等支持背景图片的HTML元素，使用CSS的background-position属性，可以讲HTML背景放置在期望的位置上 优点：不需要地图中的图片是连续的，且合并的图片比单独的图片相加要小（虽然多了空白，但是少了图片本身的开销：颜色表、格式开销等）。 CSS:12345678910111213#navbar span &#123; //每个图片的长宽 width:31px; height:31px; display:inline; float:left; background-image:url(/images/spritebg.gif);&#125;.home &#123; background-position:0 0; margin-right:4px; margin-left: 4px;&#125;.gifts &#123; background-position:-32px 0; margin-right:4px;&#125;.cart &#123; background-position:-64px 0; margin-right:4px;&#125;.settings &#123; background-position:-96px 0; margin-right:4px;&#125;.help &#123; background-position:-128px 0; margin-right:0px;&#125; HTML:1234567&lt;div id=\"navbar\" style=\"background-color: #F4F5EB; border: 2px ridge #333; width: 180px; height: 32px; padding: 4px 0 4px 0;\"&gt; &lt;a href=\"javascript:alert('Home')\" title=\"Home\"&gt;&lt;span class=\"home\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href=\"javascript:alert('Gifts')\" title=\"Gifts\"&gt;&lt;span class=\"gifts\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href=\"javascript:alert('Cart')\" title=\"Cart\"&gt;&lt;span class=\"cart\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href=\"javascript:alert('Settings')\" title=\"Settings\"&gt;&lt;span class=\"settings\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href=\"javascript:alert('Help')\" title=\"Help\"&gt;&lt;span class=\"help\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; 内联图片（Inline Image） 目的：去除图片下载 方法：利用data属性，将图片转为64位编码后写在HTML中 缺点：1.需浏览器支持；2.存在数据大小的限制；3.转为编码后会增大图片的大小；4.不会被缓存 可以放在外联样式表中，增加一个HTTP请求来换取缓存 1234567891011121314&lt;center&gt;&lt;a href=\"javascript:alert('Home')\" title=\"Home\"&gt;&lt;img border=\"0\" src=\"data:image/gif;base64,R0lGODlhHwAfAPcAAAAAAIxKAKVjCLW1tb29tcbGv...\"&gt;&lt;/a&gt;&lt;a href=\"javascript:alert('Gift')\" title=\"Gift\"&gt;&lt;img border=\"0\" src=\"data:image/gif;base64,R0lGODlhHwAfAPcAAAAAAABCpTlCrVKE1lqU94y17...\"&gt;&lt;/a&gt;...&lt;/center&gt;&lt;!-- 或者 --&gt;&lt;a href=\"javascript:alert('Home')\" title=\"Home\"&gt;&lt;span class=\"home\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;!-- 样式可以写在外联表中 --&gt;&lt;style type=\"text/css\"&gt;.home &#123; background-image: url(data:image/gif;base64,R0lGODlhHwAfAPcAAAAAAIxKAKVjCLW1tb29tcbGv...); margin-left: 4px;&lt;/style&gt; 合并脚本和样式表 目的: 减少http请求 方法：脚本之间合并，样式表之间合并。 需要保持JS的模块化，一组特定的模块生成一个目标文件。比如文件1需要script1,script2,script3,文件2需要script2,script3,script4,scipt5。那么合并后，产生script1，script_combine(包含script2,3)，script4，script5。","tags":[{"name":"高性能网站建设指南","slug":"高性能网站建设指南","permalink":"https://zj-john.github.io/tags/高性能网站建设指南/"},{"name":"High Performance Web Sites","slug":"High-Performance-Web-Sites","permalink":"https://zj-john.github.io/tags/High-Performance-Web-Sites/"}]},{"title":"JavaScript设计模式-笔记","date":"2017-11-15T13:32:44.000Z","path":"notes/ckbdbl40m001j2ktyrxws58v3.html","text":"","tags":[{"name":"JavaScript设计模式","slug":"JavaScript设计模式","permalink":"https://zj-john.github.io/tags/JavaScript设计模式/"}]},{"title":"Bootstrap中动态创建的元素如何添加tooltip效果","date":"2017-11-13T03:41:34.000Z","path":"tips/ckbdbl442008d2ktye8kyxhui.html","text":"问题：动态创建的元素如何添加tooltip效果 tooltip是一种常用的效果类提示工具，用于增强title属性的样式。不同的前段框架有自己不同的使用和展现方式，比如Bootstrap、JQueryUI、Popper等。本文主要依托Bootstrap讲解。 对于Bootstrap，只需要如下代码即可完成配置。123456789&lt;!-- HTML中如下配置： --&gt;&lt;!-- placement：top（default） right bottom left --&gt;&lt;button type=\"button\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"Tooltip on top\"&gt; Tooltip on top&lt;/button&gt;&lt;!-- title可以加html样式，如下： --&gt;&lt;button type=\"button\" data-toggle=\"tooltip\" data-html=\"true\" title=\"&lt;em&gt;Tooltip&lt;/em&gt; &lt;u&gt;with&lt;/u&gt; &lt;b&gt;HTML&lt;/b&gt;\"&gt; Tooltip with HTML&lt;/button&gt; 12// js中触发$('button').tooltip(); 这种显示的配置适用于页面初始化。如果一个元素是动态生成的，比如说datatable column中生成，这种方式将会失效。 解决方案使用selector属性：123$('body').tooltip(&#123; selector: '[rel=tooltip]'&#125;); 官方说明如下；| Name | Type | Default | Description ||———-|:—————:|——–:|————————————————————————————————————————————————————————-|| selector | string or false | false | If a selector is provided, tooltip objects will be delegated to the specified targets. In practice, this is used to enable dynamic HTML content to have popovers added. |","tags":[{"name":"tooltip","slug":"tooltip","permalink":"https://zj-john.github.io/tags/tooltip/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://zj-john.github.io/tags/Bootstrap/"}]},{"title":"angular checkbox 取值技巧","date":"2017-11-10T03:12:56.000Z","path":"tips/ckbdbl43u007z2kty6cuu8kde.html","text":"问题：angular checkbox 取值技巧 angular中使用checkbox，绑定model后，返回的默认值是bool类型的true or false。这对于对于需要特定返回的情况，处理不太友好。 解决方案使用ng-true-value和ng-false-value,这两个值分别指定选中和不选中checkbox时 ng-model的值。1&lt;input type=\"checkbox\" ng-model='test' ng-true-value='1' ng-false-value=\"0\" name=\"type\" &gt;","tags":[{"name":"angular","slug":"angular","permalink":"https://zj-john.github.io/tags/angular/"},{"name":"checkbox","slug":"checkbox","permalink":"https://zj-john.github.io/tags/checkbox/"}]},{"title":"select添加placeholder","date":"2017-11-09T12:27:59.000Z","path":"tips/ckbdbl43x00822kty6i3whqmf.html","text":"问题：select添加placeholder select默认是没有placeholder这个属性的，但是又希望加一个类似于placeholder的效果，该怎么做呢？ 解决方案最佳解决方案：1234567&lt;select&gt; // selected :让选项默认选中，出现在select当前框中 // disabled ：使此项不能被当做有效项使用 // display:none : 让select选中其它值后，placeholder项不再出现 &lt;option value=\"\" disabled selected style='display:none;'&gt;placeholder的内容&lt;/option&gt; &lt;option value=\"option1\"&gt;Option1&lt;/option&gt;&lt;/select&gt; 效果如下： 请选择… Option1 Option2 angular中：123456&lt;select name=\"type\" ng-model=\"user\" ng-options=\"t.id as t.name for t in user_list\"&gt; &lt;option value='' disabled selected style='display:none;'&gt; 请选择用户...&lt;/option&gt;&lt;/select&gt;","tags":[{"name":"select","slug":"select","permalink":"https://zj-john.github.io/tags/select/"},{"name":"placeholder","slug":"placeholder","permalink":"https://zj-john.github.io/tags/placeholder/"}]},{"title":"jQuery checkbox 选中失效问题","date":"2017-11-08T06:11:24.000Z","path":"tips/ckbdbl43y00862ktyyzntzvqy.html","text":"问题：jQuery checkbox 选中失效问题 做项目的时候遇到了需要用jQuery来选中checkbox的情况，但是发现多次使用时，首次生效，之后就无法选中的情况。使用的代码如下：1234// 选中$(\"[type=checkbox]\").attr('checked', true);// 取消选中$(\"[type=checkbox]\").removeAttr('checked'); 解决方案使用prop代替attr即可。1234// 选中$(\"[type=checkbox]\").prop('checked',true); // 取消选中$(\"[type=checkbox]\").prop('checked',false); 原因为什么使用prop和attr的效果不同呢，两者又有什么区别。我们来看下官网的说法： The difference between attributes and properties can be important in specific situations. Before jQuery 1.6, the .attr() method sometimes took property values into account when retrieving some attributes, which could cause inconsistent behavior. As of jQuery 1.6, the .prop() method provides a way to explicitly retrieve property values, while .attr() retrieves attributes. For example, selectedIndex, tagName, nodeName, nodeType, ownerDocument, defaultChecked, and defaultSelected should be retrieved and set with the .prop() method. Prior to jQuery 1.6, these properties were retrievable with the .attr() method, but this was not within the scope of attr. These do not have corresponding attributes and are only properties. Concerning boolean attributes, consider a DOM element defined by the HTML markup &lt;input type=”checkbox” checked=”checked” /&gt;, and assume it is in a JavaScript variable named elem: Code Desc elem.checked true (Boolean) Will change with checkbox state $( elem ).prop( “checked” ) true (Boolean) Will change with checkbox state elem.getAttribute( “checked” ) “checked” (String) Initial state of the checkbox; does not change $( elem ).attr( “checked” )(1.6) “checked” (String) Initial state of the checkbox; does not change $( elem ).attr( “checked” )(1.6.1+) “checked” (String) Will change with checkbox state $( elem ).attr( “checked” )(pre-1.6) true (Boolean) Changed with checkbox state According to the W3C forms specification, the checked attribute is a boolean attribute, which means the corresponding property is true if the attribute is present at all—even if, for example, the attribute has no value or is set to empty string value or even “false”. This is true of all boolean attributes. Nevertheless, the most important concept to remember about the checked attribute is that it does not correspond to the checked property. The attribute actually corresponds to the defaultChecked property and should be used only to set the initial value of the checkbox. The checked attribute value does not change with the state of the checkbox, while the checked property does. Therefore, the cross-browser-compatible way to determine if a checkbox is checked is to use the property: if ( elem.checked ) if ( $( elem ).prop( “checked” ) ) if ( $( elem ).is( “:checked” ) ) The same is true for other dynamic attributes, such as selected and value. 简单的说，具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()。具体列表如下：","tags":[{"name":"checkbox","slug":"checkbox","permalink":"https://zj-john.github.io/tags/checkbox/"},{"name":"jQuery","slug":"jQuery","permalink":"https://zj-john.github.io/tags/jQuery/"}]},{"title":"datatable 后端分页处理","date":"2017-10-31T09:37:57.000Z","path":"tips/ckbdbl43r007t2kty3ujo38gx.html","text":"问题：datatable 后端分页处理 对于datatable来说，即使对大数据量的处理，如果不涉及状态数据（比如有实时要求）且后端接口速度够快的话，其实不用做后端分页也可以。在option中使用“deferRender”: true，基本上能达到较快的渲染速度。1234567$(document).ready(function() &#123; $('#example').DataTable( &#123; \"ajax\": \"data/arrays.txt\", //当处理大数据时，延迟渲染数据，有效提高Datatables处理能力 \"deferRender\": true &#125; );&#125;); 但是，真的碰到了上述情况，那么后端分页就是必须的了。下面来看： 解决办法官网 、 中文网镇贴. 直接上代码，如下。注意有一些key的值是datatable规定好的，具体的服务器参数和返回的参数可以在上述文档中找到，不再赘述。123456789101112131415161718192021222324252627282930313233let &#123;url, data, type&#125; = options.ajax;// 开启后端分页options.serverSide = true;options.ajax = &#123; url: url, data: function ( d ) &#123; // d中包含了当开启了服务器模式时，DataTables 会默认发送到服务器的参数 // 可以对d中的数据进行处理，来适配后端的需求 // 删除关键字搜索 即searching:false delete d.search; let _order = d.order[0]; let column = d.columns[_order.column].data; // 只允许对一列数据进行排序，排序的column从index改为key d.order = &#123; column: column, dir: _order.dir &#125;; // 只有一列排序，columns的值将用不到 所以删除 delete d.columns; // data中存放了要post的数据 $.extend( d, data ); return JSON.stringify( d ); &#125;, type: type, contentType: \"application/json; charset=utf-8\", // 从后端返回的数据也可以处理为自己想要的格式 dataSrc: function ( json ) &#123; json.recordsFiltered = json.recordsTotal; return json.data; &#125;&#125;// init datatableelement.DataTable(options); 此代码对应的req和res契约如下：12345678910111213141516171819202122232425req:&#123; // form 数据，相当于上述代码的post data \"id\":\"10002\", \"name\": \"hotel_product_search\", // 以下为table信息 为分页所传的数据 \"length\": 10 , // table每页展示数量 \"start\": 0, // 第一条数据的起始位置，比如0代表第一条数据 // 排序 只支持单排序，asc：升序 desc：降序，这个值在上述代码中做过特殊处理。 \"order\":&#123;column: \"id\", dir: \"asc\"&#125; \"draw\":1 // 这个值前端用于判断ajax的顺序 无需做处理。&#125;res:&#123; \"success\": true, \"msg\": \"\", \"draw\": 1 // 前端传输的值 \"recordsTotal\": 10054 //数据库里总共记录数，该值会显示在datatable的页脚位置 \"data\": [ // 具体信息 &#123; \"id\": \"100402\", \"name\": \"hotel_product_search\", &#125; ]&#125;","tags":[{"name":"datatable","slug":"datatable","permalink":"https://zj-john.github.io/tags/datatable/"},{"name":"serverside","slug":"serverside","permalink":"https://zj-john.github.io/tags/serverside/"}]},{"title":"hexo yilia主题的优化-访问统计篇","date":"2017-10-27T03:31:48.000Z","path":"notes/ckbdbl428004n2ktybenrt70a.html","text":"简介一个帅气的博客应该具有： 文章目录 文章评论功能 主页显示时，文章的截断功能 博客的访客、浏览量的统计 本篇讲解 文章的截断功能和访问、浏览统计 的设置方法。 截断功能默认情况博客的主页上的文章会全文显示，所以主页就显得非常臃肿。如何把主页上的文章截断，只展示一部分内容呢：实现非常简单，在文章md源文件中需要截断的地方加上如下代码。加上后，文章内容会在该代码的位置进行截断，主页上只显示该代码上部的内容。1&lt;!-- more --&gt; 访问、浏览统计不蒜子插件实现网站访问、浏览统计的第三方插件有很多，Amazon、baidu、Google都有提供，大家可以根据需要自己去搜索。我这里用的是国内开发人员“不如”开发的不蒜子插件。插件的具体原理、实现方法、扩展开发可以参看插件官方页面。如果只是使用的话，方法非常简单，可以跳过文档，直接看下一步。 配置方法本文我们把访问统计放在博客的页面底部，所以需要修改对应的模板文件： themes\\yilia\\layout\\_partial\\footer.ejs。 修改后的文件见下：12345678910111213141516171819202122&lt;footer id=&quot;footer&quot;&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 不蒜子内容 Start--&gt; &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot; style=&quot;display: inline;&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot; style=&quot;display: inline;&quot;&gt; 总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt; &lt;!-- 不蒜子内容 End --&gt;&lt;/footer&gt; Tip: 这里把不蒜子的内容放在footer tag内，是为了把footer的样式用在不蒜子中。如果自己写样式的话，只要保持不蒜子内容的完整，代码放置位置就随意了。 最终实现的效果：","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zj-john.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zj-john.github.io/tags/yilia/"},{"name":"优化","slug":"优化","permalink":"https://zj-john.github.io/tags/优化/"}]},{"title":"hexo yilia主题的优化-评论篇","date":"2017-10-26T04:06:48.000Z","path":"notes/ckbdbl423004a2ktywiiftpb0.html","text":"简介一个帅气的博客应该具有： 文章目录 文章评论功能 主页显示时，文章的截断功能 博客的访客、浏览量的统计 本篇讲解 文章评论 的设置方法。 设置方法选择第三方插件yilia主题里默认提供了几种插件的支持，其中： 多说、网易云跟帖已经关闭 畅言需要域名备案才可使用 disqus在国内由于你懂的原因,基本上不能正常使用 Gitment设置、维护比较复杂，且只支持GitHub账号 看起来，基本上都处于不能用的状态。所以最终选用的是来必力这个插件。来必力安装使用方便，且提供管理、统计界面。 使用的话，注册一下，然后选择个人使用的免费版本City版本，选择“现在安装”，会到代码管理界面，如下： 设置yilia 配置文件打开yilia的配置文件:\\themes\\yilia_config.yml,在其中加入内容，见下： 1234567891011121314151617181920212223242526#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: &apos;&apos; #存储评论的 repogitment_oauth: client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret#6 来必力 把代码管理中 data-uid中的内容复制到这里。livere_uid: &quot;*************&quot; 配置模板文件打开页面模板文件：themes\\yilia\\layout\\_partial\\article.ejs，在文件末尾如下位置，添加来必力代码管理中心的代码。 先判断配置文件中是否配置了来必力。配置方法见上一小节。123&lt;% if (theme.livere_uid)&#123; %&gt;...&lt;% &#125; %&gt; 为了评论框的效果，我们在代码上层添加了duoshuo的section样式:1&lt;section class=&quot;duoshuo&quot; id=&quot;comments&quot;&gt;&lt;/section&gt; 整体代码如下： 12345678910111213141516171819202122232425262728293031&lt;% if (theme.gitment_owner &amp;&amp; theme.gitment_repo &amp;&amp;theme.gitment_oauth &amp;&amp; theme.gitment_oauth.client_id &amp;&amp; theme.gitment_oauth.client_secret)&#123; %&gt;&lt;%- partial(&apos;post/gitment&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;% &#125; %&gt;&lt;!-- 来必力City版安装代码 --&gt;&lt;% if (theme.livere_uid)&#123; %&gt; &lt;!-- 这一句是适配样式 --&gt; &lt;section class=&quot;duoshuo&quot; id=&quot;comments&quot;&gt; &lt;!-- 以下是 来必力City版安装代码 --&gt; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC8zMTQ5MS84MDU1&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt;&lt;% &#125; %&gt; 完成上述配置后，就可以看到效果啦： 关闭评论方法这里的设置会对所有的文章生效。如果想要关闭评论功能要怎么办呢？只需要在刚才设置判断条件的地方多加一个判断条件，如下代码所示。然后在不需要评论的文章head中加comment: false，在需要加评论的文章head中加comment: true即可. 123&lt;% if (theme.livere_uid &amp;&amp; post.comment)&#123; %&gt;...&lt;% &#125; %&gt; （^_^ 看到这里，你对hexo的实现原理是不是也多了些了解呢） Tips：如果开启了此设置，但需要开启评论的文章数又很多。可以在文章的template文件（scaffolds文件夹下）中把comment：true加上，这样再使用hexo new命令创建的文件默认就开启了评论。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zj-john.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zj-john.github.io/tags/yilia/"},{"name":"优化","slug":"优化","permalink":"https://zj-john.github.io/tags/优化/"}]},{"title":"hexo yilia主题的优化-目录篇","date":"2017-10-25T03:06:48.000Z","path":"notes/ckbdbl42100452ktyoaqwdnfk.html","text":"简介一个帅气的博客应该具有： 文章目录 文章评论功能 主页显示时，文章的截断功能 博客的访客、浏览量的统计 本篇讲解 文章目录 的设置方法。 设置方法修改模板目录是针对文章来说的，所以对文章添加目录，需要修改默认的文章模板。对于yilia主题，文章的模板是themes\\yilia\\layout\\_partial\\article.ejs文件。在该文件中添加的内容和位置如下： 1234567891011121314151617181920212223242526272829303132333435363738···&lt;% if (post.link || post.title)&#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123;class_name: 'article-title'&#125;) %&gt; &lt;% if (!post.noDate)&#123; %&gt; &lt;%- partial('post/date', &#123;class_name: 'archive-article-date', date_format: null&#125;) %&gt; &lt;% &#125; %&gt; &lt;/header&gt;&lt;% &#125; %&gt;&lt;!-- 目录内容 --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;p class=\"show-toc-btn\" id=\"show-toc-btn\" onclick=\"showToc();\" style=\"display:none\"&gt; &lt;span class=\"btn-bg\"&gt;&lt;/span&gt; &lt;span class=\"btn-text\"&gt;文章导航&lt;/span&gt; &lt;/p&gt; &lt;div id=\"toc-article\" class=\"toc-article\"&gt; &lt;span id=\"toc-close\" class=\"toc-close\" title=\"隐藏导航\" onclick=\"showBtn();\"&gt;×&lt;/span&gt; &lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function showToc()&#123; var toc_article = document.getElementById(\"toc-article\"); var show_toc_btn = document.getElementById(\"show-toc-btn\"); toc_article.setAttribute(\"style\",\"display:block\"); show_toc_btn.setAttribute(\"style\",\"display:none\"); &#125;; function showBtn()&#123; var toc_article = document.getElementById(\"toc-article\"); var show_toc_btn = document.getElementById(\"show-toc-btn\"); toc_article.setAttribute(\"style\",\"display:none\"); show_toc_btn.setAttribute(\"style\",\"display:block\"); &#125;; &lt;/script&gt;&lt;% &#125; %&gt;&lt;!-- 目录内容结束 --&gt;&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt;··· 添加CSS样式添加的模板内容包括HTML和JS，现在需要为HTML添加一个合适的CSS，例如浮动、缩进等效果。CSS样式需要添加在themes\\yilia\\source \\main.******.css文件中（此文件是yilia源文件压缩后的文件，不同的yilia版本******的内容会有所区别）。在该文件末尾添加如下内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/* 目录css */#container .show-toc-btn,#container .toc-article &#123; display: block&#125;.toc-article &#123; z-index: 100; background: #fff; border: 1px solid #ccc; max-width: 250px; min-width: 150px; max-height: 500px; overflow-y: auto; -webkit-box-shadow: 5px 5px 2px #ccc; box-shadow: 5px 5px 2px #ccc; font-size: 12px; padding: 10px; position: fixed; right: 35px; top: 129px&#125;.toc-article .toc-close &#123; font-weight: 700; font-size: 20px; cursor: pointer; float: right; color: #ccc&#125;.toc-article .toc-close:hover &#123; color: #000&#125;.toc-article .toc &#123; font-size: 12px; padding: 0; line-height: 20px&#125;.toc-article .toc .toc-number &#123; color: #333&#125;.toc-article .toc .toc-text:hover &#123; text-decoration: underline; color: #2a6496&#125;.toc-article li &#123; list-style-type: none&#125;.toc-article .toc-level-1 &#123; margin: 4px 0&#125;.toc-article .toc-child &#123;&#125;/* cd-bounce-1在main******.css中文件有设置，这里是做效果替换 */@-moz-keyframes cd-bounce-1 &#123; 0% &#123; opacity: 0; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125; 60% &#123; opacity: 1; -o-transform: scale(1.01); -webkit-transform: scale(1.01); -moz-transform: scale(1.01); -ms-transform: scale(1.01); transform: scale(1.01) &#125; 100% &#123; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125;&#125;@-webkit-keyframes cd-bounce-1 &#123; 0% &#123; opacity: 0; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125; 60% &#123; opacity: 1; -o-transform: scale(1.01); -webkit-transform: scale(1.01); -moz-transform: scale(1.01); -ms-transform: scale(1.01); transform: scale(1.01) &#125; 100% &#123; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125;&#125;@-o-keyframes cd-bounce-1 &#123; 0% &#123; opacity: 0; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125; 60% &#123; opacity: 1; -o-transform: scale(1.01); -webkit-transform: scale(1.01); -moz-transform: scale(1.01); -ms-transform: scale(1.01); transform: scale(1.01) &#125; 100% &#123; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125;&#125;@keyframes cd-bounce-1 &#123; 0% &#123; opacity: 0; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125; 60% &#123; opacity: 1; -o-transform: scale(1.01); -webkit-transform: scale(1.01); -moz-transform: scale(1.01); -ms-transform: scale(1.01); transform: scale(1.01) &#125; 100% &#123; -o-transform: scale(1); -webkit-transform: scale(1); -moz-transform: scale(1); -ms-transform: scale(1); transform: scale(1) &#125;&#125;.show-toc-btn &#123; display: none; z-index: 10; width: 30px; min-height: 14px; overflow: hidden; padding: 4px 6px 8px 5px; border: 1px solid #ddd; border-right: none; position: fixed; right: 40px; text-align: center; background-color: #f9f9f9&#125;.show-toc-btn .btn-bg &#123; margin-top: 2px; display: block; width: 16px; height: 14px; background: url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat; -webkit-background-size: 100%; -moz-background-size: 100%; background-size: 100%&#125;.show-toc-btn .btn-text &#123; color: #999; font-size: 12px&#125;.show-toc-btn:hover &#123; cursor: pointer&#125;.show-toc-btn:hover .btn-bg &#123; background-position: 0 -16px&#125;.show-toc-btn:hover .btn-text &#123; font-size: 12px; color: #ea8010&#125;.toc-article li ol, .toc-article li ul &#123; margin-left: 30px;&#125;.toc-article ol, .toc-article ul &#123; margin: 10px 0;&#125; 可以压缩后再添加。 文章中添加设置在需要添加目录的文章中，开头添加toc: true.如本篇：123456789title: hexo yilia主题的优化-目录篇categories: - notestags: - hexo - yilia - 优化toc: truedate: 2017-10-25 12:06:48 文章的目录是根据markdown中的#标识来区别的，即h1(#)到h6(######)","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zj-john.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zj-john.github.io/tags/yilia/"},{"name":"优化","slug":"优化","permalink":"https://zj-john.github.io/tags/优化/"}]},{"title":"select filters on ng-table from async call","date":"2017-10-19T02:26:32.000Z","path":"tips/ckbdbl43t007w2ktyazk692wf.html","text":"问题：select filters on ng-table from async call 使用ngTable自带的filter功能，如果是select形式的filter，其filter-data需要在页面加载时完成。所以如果是异步加载filter-data的话，使用传统的angular的数据更新dom，是不生效的。如下：123456789// html:controller as page&lt;td data-title=\"'Test'\" filter=\"&#123; test: 'select'&#125;\" filter-data=\"page.data\"&gt;&#123;&#123;row.test&#125;&#125;&lt;/td&gt;// jsvar vm = this;// initvm.data = [1, 2];// ajax 更改data的值为[3, 4]后,html中select中的值还是[1, 2],并不会更新。vm.data = changeDataAsync() 解决办法官网 通过函数的方式解决12345678910// html:controller as page&lt;td title=\"'Test'\" sortable=\"'test'\" filter=\"&#123; test: 'select'&#125;\" filter-data=\"page.get_filter()\"&gt;&#123;&#123;row.test&#125;&#125;&lt;/td&gt;//jsvm.get_filter = function()&#123; var def = $q.defer(); var list_filter = []; list_filter = changeDataAsync() def.resolve(list_filter); return def;&#125; 改写filter模板（未实际测试）使用filter-data=”filterOptions”，此时默认模板：ng-options=”data.id as data.title for data in $column.data”。这个模板的问题在于$column.data时固定的值，并不会随着$scope.filterOptions的更新而改变。更改模板为：ng-options=”data.id as data.title for data in “，即可以更新。或者完全自己写一个模板替代。样例 Tip：这种方式对于要制作联动filter的效果也是必不可少的。","tags":[{"name":"ngTable","slug":"ngTable","permalink":"https://zj-john.github.io/tags/ngTable/"},{"name":"select","slug":"select","permalink":"https://zj-john.github.io/tags/select/"},{"name":"filter","slug":"filter","permalink":"https://zj-john.github.io/tags/filter/"},{"name":"async","slug":"async","permalink":"https://zj-john.github.io/tags/async/"}]},{"title":"datatable通过post ajax方式获取源数据","date":"2017-10-18T02:54:55.000Z","path":"tips/ckbdbl43o007n2kty5md2n0yl.html","text":"问题：datatable通过post ajax方式获取源数据 Datatable大概是最常用的table插件了，其中ajax是获取源数据最常用的方式。Datatable ajax的一般使用同jQuery的ajax，非常方便。但是如果通过post方式传输数据，参数的使用方式上就有区别。 官网镇贴. 解决办法1234567891011121314// url是api 接口；data是传参let &#123;url, data, type&#125; = options.ajax;ajax = &#123; url: url, data: function ( d ) &#123; // $.extend：拷贝、合并 // d:Datatables构造的请求参数，如果开启了服务器模式( serverSideOption ) 这个还会包含服务器请求的一些参数 $.extend( d, data ); return JSON.stringify( d ); &#125;, type: type, contentType: \"application/json; charset=utf-8\", dataSrc: \"data\"&#125; datatable ajax支持三种参数说明：string(url) 指定返回数据的url。Datatables默认接收的是一个属性为data，如果你返回的数据不是这样， 你需要使用 ajax.dataSrc来处理。 只能用于Get请求。 12345678910//data.json返回数据格式如下&#123; \"data\": [ [\"Tiger Nixon\", \"System Architect\", \"Edinburgh\", \"5421\", \"2011/04/25\", \"$3,120\"], ...... ]&#125;$('#example').DataTable( &#123; \"ajax\": \"data.json\"&#125; ); object(类似于ajax)其中以下3个参数有特殊用法。 data的用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 添加一个静态值，来提交额外的参数.不允许变量$('#example').dataTable(&#123; \"ajax\": &#123; \"url\": \"data.json\", \"data\": &#123; \"user_id\": 451 &#125; &#125;&#125;);// 添加额外的参数发送到服务器(注意：下列方式不适用于服务器模式)（函数没有返回）// 开启服务器模式： serverSide：true；此时排序、搜索、分页由datatable传参，后端处理$('#example').DataTable(&#123; \"ajax\": &#123; \"url\": \"data.json\", \"data\": function ( d ) &#123; // 额外传参是&#123;extra_search: value&#125; d.extra_search = $('#extra').val(); &#125; &#125;&#125;);//添加额外的参数发送到服务器(适用服务器模式)（函数有返回）$('#example').DataTable(&#123; \"serverSide\":true, \"ajax\": &#123; \"url\": \"data.json\", \"data\": function (d) &#123; return $.extend(&#123;&#125;, d, &#123; \"extra_search\": $('#extra').val() &#125;); &#125; &#125;&#125;);//以json格式提交$('#example').dataTable(&#123; \"ajax\": &#123; \"url\": \"data.json\", \"contentType\": \"application/json\", \"data\": function ( d ) &#123; return JSON.stringify( d ); &#125; &#125;&#125;);//动态传参数(在每次Datatables请求服务器时都可以动态计算提交的参数)//初始化表格var oTable = $(\"#example\").DataTable(&#123; ajax: &#123; url: \"dataList.action\", data: &#123; args1: \"我是固定传参的值，在服务器接收参数[args1]\" &#125; &#125;&#125;);//当你需要多条件查询，你可以调用此方法，动态修改参数传给服务器function reloadTable() &#123; var name = $(\"#seName\").val(); var admin = $(\"#seAdmin\").val(); var param = &#123; \"obj.name\": name, \"obj.admin\": admin &#125;; oTable.settings()[0].ajax.data = param; oTable.ajax.reload();&#125; dataSrc的用法当ajax或server-side process时，datatable默认在获取数据中找“data”属性作为源数据。如果需要换这个属性值的话，有以下2种方式。string： 123456789101112131415// 使用 dataSrc属性把 data改为 tableData （比如： &#123; tableData: [ ...data... ] &#125; ）$('#example').dataTable(&#123; \"ajax\": &#123; \"url\": \"data.json\", \"dataSrc\": \"tableData\" &#125;&#125;);// 通过 dataSrc 设置为空字符串，不从数组对象里获取，而是从数组里获取 （比如： &#123; [ ...data... ] &#125; ）$('#example').dataTable( &#123; \"ajax\": &#123; \"url\": \"data.json\", \"dataSrc\": \"\" &#125;&#125;); function: 1234567891011$('#example').dataTable( &#123; \"ajax\": &#123; \"url\": \"data.json\", \"dataSrc\": function ( json ) &#123; for ( var i=0, ien=json.data.length ; i&lt;ien ; i++ ) &#123; json.data[i][0] = '&lt;a href=\"/message/'+json.data[i][0]+'\"&gt;View message&lt;/a&gt;'; &#125; return json.data; &#125; &#125;&#125; ); success的用法在datatable中不要使用success函数。因为datatable内部有使用success这个函数，如果自定义内部函数会被覆盖掉。如果需要处理返回值，可以使用dataSrc来处理。 function(自定义)12345678910$('#example').DataTable(&#123; // data:发送给服务器的数据 // callback: 必须被执行，DataTables才能获取到数据;且将返回的数据作为callback()的唯一参数 // settings: Datatables的设置对象 \"ajax\": function (data, callback, settings) &#123; callback( JSON.parse( localStorage.getItem('dataTablesData') ) ); &#125;&#125;);","tags":[{"name":"datatable","slug":"datatable","permalink":"https://zj-john.github.io/tags/datatable/"},{"name":"post","slug":"post","permalink":"https://zj-john.github.io/tags/post/"},{"name":"ajax","slug":"ajax","permalink":"https://zj-john.github.io/tags/ajax/"}]},{"title":"react-bootstrap-typeahead的使用","date":"2017-10-17T02:27:28.000Z","path":"tips/ckbdbl43q007q2ktycjuzwcka.html","text":"问题：react-bootstrap-typeahead的使用 最近开发react应用，用到的是react-bootstrap来构建基础样式。但是用于input的typeahead组件，这个框架中没有提供。为了样式的统一，最终选用了react-bootstrap-typeahead这个typeahead控件。使用过程中遇到了以下几个问题，在此记录一下： 效果和控件demo不符 直接npm install –save react-bootstrap-typeahead后，仿照demo中的代码使用，发现展示效果和demo的样式差别很大，不是想要的效果。 通过对demo版本的比较发现，直接通过下列命令安装的版本是2.0.0-alpha.4版本，而GitHub中demo的版本是1.4.2。 解决：如果需要使用demo中的效果，需要指定版本来安装。 12345//wrong:\"react-bootstrap-typeahead\": \"^2.0.0-alpha.4\"npm install --save react-bootstrap-typeahead//correctnpm install --save react-bootstrap-typeahead@1.4.2 query 与 response 内容不匹配，不显示option这个问题的表征是如果你搜索了”z_j”,后端返回的是一个字典数组[{“name”:’zj-john’}],此时labelKey是”zj-john”,并不和z_j匹配，所以typeahead的可选择项为空。原因是”By default, the filtering algorithm only searches the field that corresponds to labelKey. However, you can pass an array of additional fields to search”解决： 使用 filterBy={[“query”]} 属性，增加匹配字段 实现input不能输入，只能从select获取值插件虽然提供了onblur的方法，但是使用 onBlur 属性，对于keyboard选择支持良好，对click支持不佳。 click中先执行onBlur，再执行onChange，导致选中框被提前清空。 具体可参考以下issues：112119127210解决：延时执行onblur 完整用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768handleOwnerBlur = () =&gt; &#123; //对于click事件，会先执行onBlur，再执行onChange，导致选中框被提前清空。所以延时0.5s setTimeout(()=&gt;&#123; if(this.refs.input_owner.getInstance().state.selected.length===0) this.refs.input_owner.getInstance().clear(); &#125;, 500);&#125;handleOwner = query =&gt; &#123; if (!query) &#123; return; &#125; this.setState(&#123; clearbutton: true &#125;); let url = config.base_url; let post_data = &#123; \"length\": 20, \"q\": query, \"type\": \"owner\" &#125; $.ajax(&#123; url: url, data: JSON.stringify(post_data), type: 'post', contentType: \"application/json; charset=utf-8\", success: function (data) &#123; if (data.result) &#123; data.data.map((item)=&gt;&#123; // 把检索字作为返回结果的一个字段，使得filter检索的时候可以检索到 item.query = query; &#125;) this.setState(&#123; owner_typeahead_options: data.data &#125;); &#125; else &#123; alert(data.message); &#125; &#125;.bind(this), error: function () &#123; alert(data.message); &#125;.bind(this) &#125;)&#125;renderMenuItemOwner = (option, props, index) =&gt; &#123; return ( &lt;div&gt; &#123;option.value&#125; &lt;div&gt; &lt;small style=&#123;&#123; \"wordBreak\":\"break-all\" , \"whiteSpace\": \"initial\" &#125;&#125;&gt;&#123;option.name&#125;&lt;/small&gt; &lt;/div&gt; &lt;/div&gt; );&#125;&lt;Typeahead ref=\"owner\" name=\"owner\" // 是否显示 clear btn(x图标) clearButton = &#123;this.state.clearbutton&#125; maxHeight = &#123;300&#125; maxResult = &#123;20&#125; options=&#123;this.state.owner_typeahead_options&#125; labelKey=&#123;\"name\"&#125; filterBy=&#123;[\"query\"]&#125; placeholder=\"请输入……\" onInputChange=&#123;this.handleOwner&#125; onBlur=&#123;this.handleOwnerBlur&#125; selected = &#123;[this.state.app_owner]&#125; renderMenuItemChildren=&#123;this.renderMenuItemOwner&#125;/&gt; tip: 如果不是为了适配bootstrap的效果，可以选用其它星级更高的typeahead插件（应该也有更好的bootstrap的适配插件，暂时没找到）。 即使typeahead的内容是后端API异步给到的，也建议使用&lt;Typeahead&gt;而非&lt;AsyncTypeahead&gt;。因为&lt;AsyncTypeahead&gt;的props更少，且不好调试。&lt;Typeahead&gt; + promise 完全可以替代&lt;AsyncTypeahead&gt;","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"typeahead","slug":"typeahead","permalink":"https://zj-john.github.io/tags/typeahead/"},{"name":"react-bootstrap-typeahead","slug":"react-bootstrap-typeahead","permalink":"https://zj-john.github.io/tags/react-bootstrap-typeahead/"}]},{"title":"正则表达式中(?:pattern)的含义","date":"2017-10-16T02:51:12.000Z","path":"tips/ckbdbl46600ci2ktyh4puhw0q.html","text":"问题：正则表达式中 (?:pattern)的含义 在看jQuery源码的时候，碰到”/^(?:\\s(&lt;[\\w\\W]+&gt;)[^&gt;]|#([\\w-]*))$/“这个正则表达式，对其中的(?:pattern)不太明白。 解决方法官网解释如下： (?:x)：匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。 ?:是非捕获元之一.(?:)代表不捕获分组。比较(X)和(?:X)，前者是捕获分组，后者不捕获，区别在于正则表达式匹配输入字符串之后所获得的匹配的（数）组当中没有(?:X)匹配的部分；12345678var m = \"abcabc\".match(/(?:a)(b)(c)/)//结果 [\"abc\", \"b\", \"c\"]// m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a// m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence// m[2] 是捕获组2，即(c)匹配到的var m = \"abcabc\".match(/(a)(b)(c)/)//结果 [\"abc\", \"a\", \"b\", \"c\"] 分析下这个正则表达式的作用：1234567891011121314151617181920212223242526272829// 这个正则表达式是为了匹配selector：例如&lt;html&gt;、#id，且 id的优先级超过tagvar rquickExpr = /^(?:\\s*(&lt;[\\w\\W]+&gt;)[^&gt;]*|#([\\w-]*))$/;// /^、$/: 匹配头尾// /^()$/ : （）：标记一个子表达式的开始和结束位置，但会有一个副作用，是相关的匹配会被缓存，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。此时可用?:放在第一个选项前来消除这种副作用// /^(?:)$/ :不捕获最外成括号的整体匹配// \\s*: 匹配空白字符0次或多次// &lt;[\\w\\W]+&gt; : 匹配任意字符1次或者多次 ([]:匹配方括号(\\w:匹配一个单字字符 \\W:匹配一个非单字字符)// [^&gt;]*: 以&gt;开头的任意字符0次或多次// 以上匹配 tag 如&lt;div&gt; &lt;li&gt;test// | 或// 以下匹配id// #([\\w-]*): 匹配\"#&lt;string&gt;\"0次或多次// 执行测试：// rquickExpr.exec( selector );来执行// 如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。// 如果不加?: ，则每个数组的length为4var selector = '&lt;html&gt;';// [\"&lt;html&gt;\", \"&lt;html&gt;\", undefined]var selector = '#id';// [\"#id\", undefined, \"id\"]var selector = '&lt;html&gt;#id';// [\"&lt;html&gt;#id\", \"&lt;html&gt;\", undefined]var selector = '&lt;div&gt;asdgasdg'// [\"&lt;div&gt;asdgasdg\", \"&lt;div&gt;\", undefined] 另外还有两种非捕获元是 ?= 和 ?!. x(?=y):匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 x(?!y):匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’","tags":[{"name":"tip","slug":"tip","permalink":"https://zj-john.github.io/tags/tip/"}]},{"title":"ngTable中使用全局搜索","date":"2017-10-13T04:12:46.000Z","path":"tips/ckbdbl45z00c52ktyw16lwe8y.html","text":"问题：ng-table中使用全局搜索 在使用angular作为主体语言的项目中，一般选用ngTable来展示表格。 jQuery中常用的datatable在angular中效果并不理想。在使用ng-repeat这种angular的方式渲染时，性能慢的出奇。换为后端defer的方式加载的话，性能会有提升，但是这种方式失去了angular数据响应式渲染的有点。 ngTable中的默认的search方式，是给每一列加自己的筛选。如下图： 这种过滤方式的优点是精准，但是缺点也很明显，无法做到全局匹配。如果想做到类似于datatable中全局搜索的效果应该怎么操作呢？ 解决方法直接上代码：12345678910111213141516171819202122232425//html 部分&lt;table ng-table=\"page.tableParams\" class=\"table table-bordered table-striped\"&gt; &lt;caption&gt; &lt;span class=\"pull-right\"&gt; // 类似于datatable的 搜索框 &lt;input placeholder=\"Search\" class=\"form-control input-sm\" type=\"text\" ng-model=\"page.keyword\" ng-change=\"page.search()\"&gt; &lt;/span&gt; &lt;/caption&gt; &lt;tr ng-repeat=\"d in $data\"&gt; &lt;td title=\"'域名'\" sortable=\"'domain'\"&gt;&#123;&#123; d.domain &#125;&#125;&lt;/td&gt; &lt;td title=\"'类型'\" sortable=\"'is_internet'\"&gt;&#123;&#123; d.is_internet?\"外网\":\"内网\" &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div ng-if=\"page.tableParams.total() == 0\" class=\"text-center\"&gt; No data found&lt;/div&gt;//JS controllerAs: 'page'vm.search = function()&#123; vm.tableParams = new NgTableParams(&#123; count : 10 &#125;, &#123; dataset: $filter('filter')(vm.selected_data, vm.keyword); &#125;);&#125; 为什么不在html中ng-repeat后直接filter呢？一般来说，首先会使用ng-repeat=”d in $data | filter:page.keyword”的方式进行过滤。但是这种方式在ngTable中行不通，因为这里的$data实际是ngTable做了分页后的数据，也就是currentPageData，所以filter只能过滤当前页面的内容。 扩展学习：controller中$filter的用法filter一般在html中用于格式化，在controller中也可以通过$filter使用。在使用中要了解filter原型，以便传参。另外，两者用法有所区别： 1234567//将12.45格式化为货币，使用自定义单位符号为 'CHY￥', 小数指定1位, 会执行四舍五入操作&#123;&#123; 12.45 | currency:'CHY￥':1&#125;&#125;//currencyFilter：function(amount, currencySymbol, fractionSize)$filter('currency')('12.45', 'CHY￥', 1);// 或者 直接使用currencyFiltercurrencyFilter('12.45', 'CHY￥', 1) 可以看出，html中除值外，其余参数使用”:”来传参。controller中可以使用统计$filter或者单独filter来处理。常用内置filter： currencyFilter（currency）：function(amount, currencySymbol, fractionSize) dateFilter（date）：function(date, format, timezone) filterFilter（filter）：function(array, expression, comparator) jsonFilter（json）：function(object, spacing) limitToFilter（limitTo）：function(input, limit) lowercaseFilter（lowercase）：function(string) uppercaseFilter（uppercase）：function(string) numberFilter（number）：function(number, fractionSize) orderByFilter（orderBy）：function(array, sortPredicate, reverseOrder)","tags":[{"name":"ngTable","slug":"ngTable","permalink":"https://zj-john.github.io/tags/ngTable/"},{"name":"filter","slug":"filter","permalink":"https://zj-john.github.io/tags/filter/"},{"name":"angular","slug":"angular","permalink":"https://zj-john.github.io/tags/angular/"}]},{"title":"如何选择NPM依赖包版本号前缀","date":"2017-10-12T10:05:22.000Z","path":"tips/ckbdbl46200cc2ktymx7cvv5h.html","text":"问题：如何选择NPM依赖包版本号前缀 跑别人的代码，发现有两个依赖包没有安装。准备配置到package.json中时发现依赖包版本前还有前缀，这都是啥意思。12345678910111213\"dependencies\": &#123; \"ng-table\": \"^3.0.1\"&#125;,\"scripts\": &#123; \"test\": \"gulp test\", \"start\": \"gulp serve\", \"build\": \"gulp serve:dist\"&#125;,\"devDependencies\": &#123; \"angular-ui-router\": \"1.0.0-rc.1\", \"browser-sync\": \"~2.9.11\", \"browser-sync-spa\": \"~1.0.3\"&#125; 解决方法参考回答：stackoverflow官网 ~和^的作用和区别： ~会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0 ^会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0 当然，直接写前缀也没有任何问题。 注意^版本更新可能比较大，会造成项目代码错误;使用~来标记版本号，这样可以保证项目不会出现大的问题，也能保证包中的小bug可以得到修复 扩展学习除了~和^外，还有其他前缀可以使用，见下： version Must match version exactly >version Must be greater than version >=version etc &lt;version &lt;=version ~version “Approximately equivalent to version” ^version “Compatible with version” 1.2.x 1.2.0, 1.2.1, etc., but not 1.3.0 http://… See ‘URLs as Dependencies’ below * Matches any version “” (just an empty string) Same as * latest Obtains latest release version1 - version2 Same as &gt;=version1 &lt;=version2. range1 || range2 Passes if either range1 or range2 are satisfied. git… See ‘Git URLs as Dependencies’ below user/repo See ‘GitHub URLs’ below tag A specific version tagged and published as tag See npm-dist-tag path/path/path See Local Paths below 12345678910111213141516&#123; &quot;dependencies&quot; : &#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot; , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot; , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot; , &quot;boo&quot; : &quot;2.0.1&quot; , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot; , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot; , &quot;til&quot; : &quot;~1.2&quot; , &quot;elf&quot; : &quot;~1.2.3&quot; , &quot;two&quot; : &quot;2.x&quot; , &quot;thr&quot; : &quot;3.3.x&quot; , &quot;lat&quot; : &quot;latest&quot; , &quot;dyl&quot; : &quot;file:../dyl&quot; , &quot;npm&quot; : &quot;git+ssh://git@github.com:npm/npm.git#v1.0.27&quot; &#125;&#125; 讨论一个好玩儿的问题，当执行npm install –save时，默认是使用~还是^呢？从npm的merge上看，目前使用default to ^ instead of ~的标准。 有兴趣的可以看看类似的讨论：https://github.com/npm/npm/issues/4587https://github.com/npm/init-package-json/issues/10","tags":[{"name":"tip","slug":"tip","permalink":"https://zj-john.github.io/tags/tip/"}]},{"title":"PC维修记","date":"2017-10-11T07:26:47.000Z","path":"notes/ckbdbl41d002z2ktyritdrt23.html","text":"国庆放假带电脑回家，一为值班，二为娱乐。结果到家开机就发现进不去系统了，后面就开始漫长的维修经历。按照时间先后顺序记录如下： 电脑品牌：Lenovo操作系统：win7 专业版 问题发生坐高铁回家的上午，临时拷贝了一些东西到移动硬盘。拷贝完成准备关机时，发现电脑进入到360的更新系统的状态，并标识请勿关闭电源。等了一会儿，发现进度根本不动，所以点了取消，系统变为取消中……，之后就卡在这个界面。由于赶时间，关上了屏幕，拔掉了电源。 到家后，开机。发现启动特别慢，windows的四色图标大概话了20~30分钟才出现，意识到可能出问题了。好不容易挨到输入账号密码的页面，输入密码后，经历了大概又30min的等待，出现了第一个报错： 解决问题问题1：user profile service服务未能登录尝试解决： 正常无法登录时，首先选择使用“安全模式”尝试登录，耗费大量时间后成功登入系统。发现系统卡顿到不行，一次邮件操作大概需要10min左右的反馈时间。 平时也会选择使用“最后一次正确的配置”来登录。本次用1h的时间证明失败 能够成功进入到安全模式后，面临两种选择：1.修复原账户；2.创建新账户。可以二者结合进行。由于安全模式过于卡顿，所以创建了一个新账户。然后重新启动。 进入系统依然很慢，但是好在通过新账户可以进入到系统。但是出现和安全模式一样的问题，十分卡顿。尝试通过注册表修复原账户，网上介绍的方法如下,简单来说就是注册表中会对账户信息做一个备份，把当前问题账户的记录删除，使用对应的备份记录替代。 进入下列注册表项HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList您在左边的画面会看到两个类似的文件夹，类似“S-1-5-21-xxxxx &amp; S-1-5-21xxxxx”和“S-1-5-21-xxxxx &amp; S-1-5-21xxxxx.bak”，将不带.bak的注册表文件夹重命名为xxx.bak.old，然后将.bak的注册表文件夹恢复成原来正常的名字，如“S-1-5-21-xxxxx &amp; S-1-5-21xxxxx”，重启电脑即可恢复正常 操作后重启，进入原账户，问题依然。既然新账户能登陆，干脆把需要的内容备份后，把老账户干掉算了。操作后，新账户可以慢……慢……慢……登录到系统了。问题暂时解决。 到目前为止，虽然可以进入到系统。但是1h的开机时间，10min的操作反馈时间无法容忍。于是开始解决第二个问题。 问题2：电脑卡顿尝试解决： 卡顿一般可能是内存不足导致的。但经过Lenovo在系统启动时自带的硬件自检程序，证明了内存无异常。排除了这个问题。 通过系统日志中查看，发现有大量的报错：“设备 \\Device\\Ide\\IdePort2 没有在传输等待时间内响应”： 从报错上看应该是硬盘有点问题，于是运行了磁盘检查。由于当前正在使用，所以系统告知我关机后会自动检查。 进行了很长时间的检查后，看到有坏道被监测出。待检查完毕，重新开机修复坏道时，发现无法进入系统了，报错： 问题3：a disk read error occurred尝试解决： MD，现在连系统都进不去了，还怎么解决…… 突然发现Lenovo 自带了 Lenovo Diagnostics工具，可以进行硬盘检测和修复 长达6h的检测和修复后，发现问题照旧…… 鉴于之前新账户是可以登录系统的，感觉是C盘的硬盘有问题，其它磁盘应该还好。所以打算把C盘格式化后重装下。 最终解决： 制作U盘启动，进入PE，发现C盘和D盘都无法识别，其它盘正常。 格式化C盘、D盘后，使用恢复文件工具把需要的文件都救了回来 之前有做过系统备份，从镜像中重装了系统。 重装后，系统正常。问题解决…… Tips:重装了系统后，首先安装了360安全卫士。上次我没有听你的话，是我错了……","tags":[{"name":"lenovo","slug":"lenovo","permalink":"https://zj-john.github.io/tags/lenovo/"}]},{"title":"chrome button按钮点击之后会有蓝色边框","date":"2017-10-09T07:08:58.000Z","path":"tips/ckbdbl46400cf2ktyd61ybie1.html","text":"问题： chrome button按钮点击之后会有蓝色边框 为了更好的用户体验，chrome浏览器默认会为当前获得焦点的button添加outline属性（一个带颜色的边框），这样可以方便用户使用tab键更换当前焦点按钮。怎么去除这种效果呢？ 解决方法如果想要去掉这种效果，可以在css中添加样式123button:focus &#123;outline:none;&#125;//或者button:focus &#123;outline:0;&#125; 其它浏览器，比如Firefox也会有类似的行为.如果想要去除，需要使用Mozilla的私有属性：123::-moz-focus-inner &#123;border-color: transparent;&#125;// 或::-moz-focus-inner &#123;border:0;&#125; 另外：此种方式对初始化的元素生效，对js中创建的元素是否生效待测试","tags":[{"name":"chrome","slug":"chrome","permalink":"https://zj-john.github.io/tags/chrome/"},{"name":"button","slug":"button","permalink":"https://zj-john.github.io/tags/button/"},{"name":"outline","slug":"outline","permalink":"https://zj-john.github.io/tags/outline/"}]},{"title":"git add -all 无法提交当前目录外的变动","date":"2017-09-21T02:10:00.000Z","path":"tips/ckbdbl45s00bp2kty445syzyc.html","text":"问题：git add -all 无法提交当前目录外的变动 解决方法在git2.0版本中，提交所有变动需要使用git add -all :/ 替代 git add -all，后者只能提交当前目录的变动。 123456789101112warning: The behavior of &apos;git add --all (or -A)&apos; with no path argument from a subdirectory of the tree will change in Git 2.0 and should not be used anymore.To add content for the whole tree, run: git add --all :/ (or git add -A :/)To restrict the command to the current directory, run: git add --all . (or git add -A .)With the current Git version, the command is restricted to the current directory","tags":[{"name":"git","slug":"git","permalink":"https://zj-john.github.io/tags/git/"},{"name":"add","slug":"add","permalink":"https://zj-john.github.io/tags/add/"}]},{"title":"Git ignore 修改后不生效","date":"2017-09-20T03:28:59.000Z","path":"tips/ckbdbl45400ai2ktyn9wdrlzq.html","text":"问题：Git ignore 修改后不生效 解决方法.gitignore文件中新加了忽略规则，发现并未生效。原因：.gitignore只能忽略没有被追踪的文件，如果文件已经被纳入了版本管理中，则修改无效。解决：先把本地缓存删除（改变成未被追踪状态），然后再提交。 详细理解和说明可以参考.gitignore官方解释。具体操作如下：123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos; 扩展学习：gitignore语法忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略带有敏感信息的配置文件，比如存放口令的配置文件。 如果不知道有哪些文件需要忽略，可以参考ignore template,里面根据语言列出了对应ignore的模板 以下语法应用在.gitignore文件中（若根目录下没有，可手工新建）。 windows新建时提示必须添加文件名，无法创建的解决办法:1.使用文件名.gitignore.来创建(末尾有个”.”);2.使用notepad等文本编辑器保存 123456789# 此为注释 – 将被 Git 忽略*.sample # 忽略所有 .sample 结尾的文件!lib.sample # 但 lib.sample 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODOfoo/ # 忽略 foo/ 目录下的所有文件foo # 匹配所有名为foo的文件或目录**/foo/bar # 匹配所有foo一级目录下名字为bar的文件或目录/log/* # 屏蔽log下所有文件，不包括log文件夹本身doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt","tags":[{"name":"git","slug":"git","permalink":"https://zj-john.github.io/tags/git/"},{"name":"ignore","slug":"ignore","permalink":"https://zj-john.github.io/tags/ignore/"}]},{"title":"img src 默认地址设置","date":"2017-09-19T07:05:02.000Z","path":"tips/ckbdbl44q009s2ktykprxunbm.html","text":"问题：img src 地址不存在时，展示默认图片 解决方案：12345678//js//this.onerror='' 防止默认图片失效导致死循环&lt;img src=\"image.gif\" onerror='this.onerror=\"\";this.src=\"default.jpg\"'/&gt;//react&lt;img src=&#123;this.state.img&#125; ref=&#123;img =&gt; this.img = img&#125; onError=&#123; () =&gt; this.img.src = 'img/default.img'&#125;&gt; tips: onerror 事件会在文档或图像加载过程中发生错误时被触发。支持该事件的 HTML 标签:&lt;img&gt;, &lt;object&gt;(添加多媒体时使用), &lt;style&gt;。多用于img。","tags":[{"name":"react","slug":"react","permalink":"https://zj-john.github.io/tags/react/"},{"name":"img","slug":"img","permalink":"https://zj-john.github.io/tags/img/"},{"name":"default","slug":"default","permalink":"https://zj-john.github.io/tags/default/"},{"name":"onerror","slug":"onerror","permalink":"https://zj-john.github.io/tags/onerror/"}]},{"title":"clean-webpack-plugin :clean from outside of the project root","date":"2017-09-18T03:17:34.000Z","path":"tips/ckbdbl44c008z2ktytj5ghrrw.html","text":"问题：clean-webpack-plugin :clean from outside of the project root 问题分析webpack中的clean-webpack-plugin插件一般用于在打包前删除打包(dist)目录。123456789101112131415161718192021222324252627//installnpm install clean-webpack-plugin --save-dev// usagenew CleanWebpackPlugin(paths [, &#123;options&#125;])// webpack.config.js 中var CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; plugins: [ // 要删除的path：dist build new CleanWebpackPlugin(['dist', 'build'], &#123; // An absolute path for the root root: '/full/project/path', // Write logs to console. verbose: true, // Use boolean \"true\" to test/emulate delete. (will not remove files). // Default: \"false\", remove files dry: false, // Instead of removing whole path recursively, // remove all path's content with exclusion of provided immediate children. // Good for not removing shared files from build directories. exclude: ['shared.js'] &#125;) ]&#125; 在webpack使用clean-webpack-plugin插件时，如果指明删除的path([“dist”,”build”])是webpack所在目录的上级或上级其它目录时，会提示不在项目的root范围内，无法删除。这是一种防止误操作的保护机制。如果打包目录不在前端的文件夹下，比如和java结合，打包目录在java static下，此时需要指定root，才可以删除。具体如下： 解决方案1指定root根目录解决outside的问题，但root需要用绝对地址，所以用resolve解决掉路径中的”..”或”.”1234new CleanWebpackPlugin([&apos;*.*&apos;, &apos;js&apos;], &#123; root: path.resolve(__dirname, &apos;../main/resources/static&apos;), verbose: true&#125;) 解决方案2通过查看clean-webpack-plugin的源码，可以找到 allowExternal 这个参数。12345678// 判断是否在project目录下的逻辑：// disallow deletion any directories outside of root path.if (rimrafPath.indexOf(projectRootDir) &lt; 0 &amp;&amp; !_this.options.allowExternal) &#123; _this.options.verbose &amp;&amp; console.warn( &apos;clean-webpack-plugin: &apos; + rimrafPath + &apos; is outside of the project root. Skipping...&apos;); results.push(&#123; path: rimrafPath, output: &apos;must be inside the project root&apos; &#125;); return;&#125; 设置allowExternal: true即可满足需求。默认是false，如下：1options.allowExternal = options.allowExternal || false; Tips/Questions：clean-webpack-plugin中使用的删除插件是node的rimraf,功能相当于rm -rf(带递归删除)。但是在实际测试中，如果要删除的目录不是空目录，会把当前目录下文件删除后，报错不能删除非空文件夹。 具体原因还没深究，有知晓的童鞋一起分享下，谢谢。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://zj-john.github.io/tags/webpack/"},{"name":"clean-webpack-plugin","slug":"clean-webpack-plugin","permalink":"https://zj-john.github.io/tags/clean-webpack-plugin/"},{"name":"allowExternal","slug":"allowExternal","permalink":"https://zj-john.github.io/tags/allowExternal/"}]},{"title":"json-server","date":"2017-09-15T03:27:32.000Z","path":"notes/ckbdbl42h00582ktyz6wkg9in.html","text":"json-server是一款常用的mock插件。 教程/源码https://github.com/typicode/json-server 基本用法：12// 全局安装npm install json-server -g 在package.json 文件中加入脚本12345678910111213// 基本用法// help 查看CLI说明json-server -h// cmd使用json-server db.json --port 3003// npm中使用// --port 在3003端口启一个server 或简写为 -p// server提供的api的内容是db.json中的数据\"scripts\": &#123; \"mock\": \"json-server db.json --port 3003\"&#125; api中数据需要更复杂逻辑的话，文件内容可以用js文件替代，但输出必须是一个json格式的数据 123456789101112// /mock/db.jsmodule.exports = function() &#123; var data = &#123; users: [] &#125; // Create 1000 users for (var i = 0; i &lt; 1000; i++) &#123; data.users.push(&#123; id: i, name: 'user' + i &#125;) &#125; return data&#125;// cmd启动json-server db.js -p 3003 配置可以在根目录（mock）下使用一个json文件对api进行配置：1234567891011121314151617181920212223242526272829303132// /mock/json-server.json&#123; \"host\": \"0.0.0.0\", \"port\": \"3003\", // 监听文件变化 \"watch\": false, // response 延迟 \"delay\": 500, // 不输入任何log \"quiet\": true, // 设置静态文件目录 \"static\": \"./public\", // 进行转发过滤等特殊路由配置 \"routes\": \"./routes.json\"&#125;// /mock/routes.json&#123; // /news/1/show → /news/1 \"/news/:id/show\": \"/news/:id\", // /api/posts # → /posts // /api/posts/1 # → /posts/1 \"/api/*\": \"/$1\", // /posts/javascript # → /posts?category=javascript \"/posts/:category\": \"/posts?category=:category\", // /articles?id=1 # → /posts/1 \"/articles\\\\?id=:id\": \"/posts/:id\"&#125;// 运行// 如果是json-server.json，config可省略json-server db.js --config json-server.json 需要注意的是，路由必须以 / 开头 以下内容没有实际用处，知道就行。 返回静态文件：在根目录（如：mock）下设立public目录后，即可直接访问其下的所有静态文件，包括但不限于js, css ,markdown 文件等,如：http://localhist:3003/readme.md。此时默认主页无法访问 :Returns default index file or serves ./public directory URL 过滤12345678910111213141516171819202122232425262728293031323334353637383940414243// json内容示例&#123; \"id\": 0, \"title\": \"11111\", \"desc\": \"111222333\", \"tag\": \"123\", \"views\": 3810, \"images\": [ \"http://dummyimage.com/200x100/79f2a5&amp;text=别角置\", \"http://dummyimage.com/200x100/f28279&amp;text=收面几容受取\", \"http://dummyimage.com/200x100/7993f2&amp;text=做件\" ]&#125;// 使用 . 操作对象属性值// 获取图片数量为3，且标签字数为2的新闻GET /news?images.length=3&amp;tag.length=2// 使用 _start 和 _end 或者 _limit 针对id// 获取id=10开始的5篇新闻GET /news?_start=10&amp;_limit=5// 获取id=20开始,id=35结束的新闻GET /news?_start=20&amp;_end=35// 按照浏览数量降序排列GET /news?_sort=views&amp;_order=DESC// 选取浏览量在2000-2500之间的新闻GET /news?views_gte=2000&amp;views_lte=2500//使用 _ne 排除一个值// 选择tag属性不是 \"国际新闻\" 的分类GET /news?tag_ne=国际新闻//使用 _like 进行模糊查找 (支持正则表达式)// 查找title中含有 \"前端\" 字样的新闻GET /news?title_like=前端//使用 q，在对象全部value中遍历查找包含指定值的数据// 查找新闻全部字段包含 \"强拆\" 字样的数据GET /news?q=强拆 支持各种http方法，用法标准如下：1234567g.default routesGET /postsGET /posts/1POST /postsPUT /posts/1PATCH /posts/1DELETE /posts/1 中文mock推荐结合mock.js使用，支持更好","tags":[{"name":"json-server","slug":"json-server","permalink":"https://zj-john.github.io/tags/json-server/"},{"name":"mock","slug":"mock","permalink":"https://zj-john.github.io/tags/mock/"}]},{"title":"Django:No module named MYSQLdb","date":"2017-09-14T03:20:24.000Z","path":"tips/ckbdbl43l007f2kty1u5x3932.html","text":"问题：使用virtualenv搭建Django老项目，遇到Django:No module named MYSQLdb centosYou need to use one of the following commands. Which one depends on what OS and software you have and use. easy_install mysql-python(mix os) pip install mysql-python (mix os) apt-get install python-mysqldb(Linux Ubuntu, …) cd /usr/ports/databases/py-MySQLdb &amp;&amp; make install clean(FreeBSD) yum install MySQL-python (Linux Fedora, CentOS …)【亲测可用】 For Windows, see this answer: https://stackoverflow.com/q/21440230/4646678 Windows如果你全局可以安装mysql-python，把python目录 (默认C:/python27)下lib/site-package目录中的以下4个文件复制到你的虚拟环境的site-packages目录下，就可以了。 MySQL_python-1.2.4-py2.7.egg-info(folder) MySQLdb(folder) _mysql_exceptions.py/.pyc/.pyo _mysql.pyd","tags":[{"name":"python","slug":"python","permalink":"https://zj-john.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zj-john.github.io/tags/django/"},{"name":"MYSQLdb","slug":"MYSQLdb","permalink":"https://zj-john.github.io/tags/MYSQLdb/"}]},{"title":"npm","date":"2017-09-13T07:26:39.000Z","path":"notes/ckbdbl42d00512kty57utsx7l.html","text":"npm描述 nodejs的包管理器，用于node插件管理（包括安装、卸载、更新、查看、搜索、发布等） 教程 基础教程 官网教程 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344//npm初始化，在当前目录下生成package.json文件npm init//npm 升级npm install npm -g//安装模块//--save是对生产环境所需依赖的声明(开发应用中使用的框架，库), 内容写入package.json//--save-dev是对开发环境所需依赖的声明(构建工具，测试工具).内容写入package.jsonnpm install &lt;Module Name&gt; --save// -g 全局安装，install可以简写为inpm i &lt;Module Name&gt; -g//目录下已有package.json，根据其中内容安装相关依赖// 默认会下载dependencies和devDependencies中的模块// 使用参数 --production或者注明NODE_ENV变量值为production时，只会下载dependencies中的模块npm install//先安装到全局，然后link到当前目录npm link &lt;Module Name&gt;// 查看所有已安装模块及其依赖 -g 列出所有全局安装的模块npm lsnpm ls -g// 卸载模块npm uninstall &lt;Module Name&gt; // 更新模块npm update &lt;Module Name&gt; //搜索模块npm search &lt;Module Name&gt;//展示模块信息npm info &lt;Module Name&gt;// 执行脚本、命令// npm的start是一个特殊的脚本名称，不需要跟具体的脚本名称，// 如果对应的此脚本的名称不是start，则用法如：npm run build.// 相关脚本、命令可以在package.json中的scripts下写入。npm startnpm run &#123;script name&#125; 本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。 npm换源淘宝npm镜像搜索地址：http://npm.taobao.org/registry地址：http://registry.npm.taobao.org/ 使用有很多方法来配置npm的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝npm镜像举例： 临时使用 1npm --registry https://registry.npm.taobao.org install &lt;Module Name&gt; 持久使用 123npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry 通过cnpm使用 1234// 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org// 使用cnpmcnpm install &lt;Module Name&gt;","tags":[{"name":"npm","slug":"npm","permalink":"https://zj-john.github.io/tags/npm/"},{"name":"cnpm","slug":"cnpm","permalink":"https://zj-john.github.io/tags/cnpm/"}]},{"title":"利用hexo、GitHub搭建自己的博客","date":"2017-09-12T06:06:28.000Z","path":"projects/ckbdbl46b00cr2ktylc9xgzs3.html","text":"Blog是提升逼格的利器。 启用GitHub后，首先想到的便是利用GitHub的资源，搭建一下自己的博客。参考了网上的很多教程，也踩了很多坑，经验教训如下： 功能：Blog 工具：GitHub, hexo, yilia 难度等级: ★★ 项目地址: https://github.com/zj-john/zj-john.github.io 1.GitHub新建repository在GitHub填好各种资料，新建repository后，要拉取到本地进行开发。 配置ssh key：在GitHub上把本地的ssh添加进去 网上很多教程上说需要在settings-GitHub Pages下用到Launch automatic page generator，但是这个按钮（功能）在新版的GitHub中已经不支持了，无需特殊配置. 在本地拉取文件，修改文件（比如：readme.md）后提交，成功说明GitHub步骤完成 Tips: push origin master时可能会抛错：fatal: remote error:You can’t push to git://github.com/my_user_name/my_repo.git Use git@github.com:my_user_name/my_repo.git会让修改源为https什么的，但是本地实践来看，[remote “origin”] url必须修改为 url = git@github.com:* git的这个地址，https也不行。要修改的文件是在.git目录下config文件或者用命令git remote set-url origin git@github.com:my_user_name/my_repo.git。 Tips:关心GitHub contribute的童鞋可能会发现，本地推到了源后，GitHub contribute上并未记录本次commit，需要把本地的git的邮箱放到GitHub的setting中，让GitHub知晓你本地git也是你。 2.搭建hexo搭建前后请一定阅读下以下文档:hexo中文官网：https://hexo.io/zh-cn/ （搭建前后各看一遍，理解更清楚）yilia的官网：https://github.com/litten/hexo-theme-yilia （如果使用yilia主题,点击查看效果 ） Tips: hexo是用npm安装的，如果报错：hexo时出现ERROR Deployer not found: Git此类报错，请单独安装其内部插件 如：npm install hexo-deployer-git –save 可以把hexo init在你本地的文件目录下，如果报错文件夹不是空，可以随便找个地方init，然后整体搬过来即可，不影响后续使用。 yilia主题是git clone过来的，如果不用git的submodel的话，提交会变的很麻烦。不是特别在yilia的版本和更新的话题的话，可以把yilla主题下的.git目录干掉，让它成为普通文件。 3.hexo yilia配置hexo搭建后，开始修改各类配置文件，刚开始配置时很多项目不知道有什么用处，写起来会比较烦。建议找一个成熟的项目来看。推荐下自己的blog项目，里面master分支是hexo打包后的文件，没有什么参考价值。请看hexo分支，里面是hexo的源目录，hexo、yilla等配置都在里面，可以直接拿出来copy或研究。","tags":[{"name":"blog","slug":"blog","permalink":"https://zj-john.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://zj-john.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zj-john.github.io/tags/yilia/"},{"name":"github","slug":"github","permalink":"https://zj-john.github.io/tags/github/"}]},{"title":"个人简历","date":"2017-09-06T08:32:52.000Z","path":"cv/ckbdbl400000m2ktycvykzhf2.html","text":"张珺 Birth: 1989.11.06 Email: zj_john@qq.com Blog: https://zj-john.github.io/ Github: https://github.com/zj-john 教育经历2012.09-2015.06华东师范大学 计算机应用技术 硕士研究方向：现代软件技术 职业经历2014.07-至今携程旅游网络技术(上海)有限公司-网站运营中心-高级技术支持工程师职责：运维自动化工具设计与开发，目前专职于前端开发、管理 项目经历WEB开发项目按时间顺序排列： 内部自动化工具Portal职责：全栈开发技术：后端 Django + MySQL 前端：Jquery + Bootstrap内容：日常使用的工具的汇总查看及管理，简单单页应用 CDN自助申请及管理工具职责：全栈开发技术：后端 Django + MySQL 前端：Jquery + Bootstrap内容：包括申请模块，邮件模块，管理模块，权限模块，接口模块 Spider工具职责：全栈开发技术：Angular1 + Django内容：各地区爬虫管理、远程操作工具 CMP2.0职责：前端开发技术：前期用JQuery，后期迭代为Angular1，打包压缩用Gulp内容：携程一键式多环境资源申请管理产品 SiteController2.0职责：前端开发技术：Angular + Gulp + Inspinia内容：携程一站式切换、故障快速恢复产品 Webinfo7.0职责：前端开发技术： React全家桶（Redux + Route + Webpack） + SmartAdmin内容：携程新一代应用资源管理产品 ReactSeedProject AngularSeedProject DnsConfigPortal职责：前端开发技术：Angular + Gulp + Inspinia内容：域名、DNS、CDN、海外加速管理、展示平台 Cginder职责：前端开发技术：React全家桶 + Material内容：全链路压测工具 Hybrid开发 应用资源查询APP职责：前端开发技术：SenchaTouch + Cordova内容：运维资源管理工具移动化 EasyGo APP职责：产品经理/前端开发/推荐算法技术：Ionic + JQuery + Django内容：一款行程规划推荐APP,携程3rd Hackathon竞赛 最佳项目 + CEO大会展示 哇吖 APP职责：前端开发技术：Framework7内容：哇吖网移动APP开发 其它 运维聊天机器人：职责：脚本开发技术：Docker + Rocket.chat + TypeScript内容：ChatOps工具，已在携程落地，携程Hackathon 竞赛（4th）第6名 技能点 JS ( ES6 + Angular + React + Node ) CSS ( CSS3 ) HTML ( HTML5 ) Webpack + Gulp + Git + Docker Python ( Django + Salt ) Http + CDN + OS + PS + PR 自我描述 拿的出手： 前端开发 + 产品经理 马马虎虎：Python + 网络 + OS 基本了解：Java + PHP 整点爱好：吉他+游泳+日语+料理+BlockChain 未来打算：前端、项目管理 兴趣爱好 游泳、羽毛球 动漫 音乐（吉他） 料理 写作 新技术（最近在看区块链）","tags":[{"name":"Frontend","slug":"Frontend","permalink":"https://zj-john.github.io/tags/Frontend/"},{"name":"Programmer","slug":"Programmer","permalink":"https://zj-john.github.io/tags/Programmer/"},{"name":"PM","slug":"PM","permalink":"https://zj-john.github.io/tags/PM/"},{"name":"Devops","slug":"Devops","permalink":"https://zj-john.github.io/tags/Devops/"}]},{"title":"Hello github","date":"2017-09-05T08:32:52.000Z","path":"uncategorized/ckbdbl3yd00002ktyekpo6ut5.html","text":"欢迎来到我的博客。","tags":[{"name":"test","slug":"test","permalink":"https://zj-john.github.io/tags/test/"},{"name":"blog","slug":"blog","permalink":"https://zj-john.github.io/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zj-john.github.io/tags/Hexo/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://zj-john.github.io/tags/GitHub-Page/"},{"name":"Git","slug":"Git","permalink":"https://zj-john.github.io/tags/Git/"}]},{"title":"我的简历","date":"2017-09-05T08:32:52.000Z","path":"uncategorized/ckbdbl3yh00012ktymue1u8ji.html","text":"个人信息 张珺 1989.11.06 教育经历2012.09-2015.06华东师范大学 计算机应用技术 硕士研究方向：现代软件技术 职业经历2014.07-至今携程旅游网络技术(上海)有限公司-网站运营中心职责：运维自动化工具设计与开发，目前专职前端开发、管理 项目经历WEB开发Hybrid开发其它自我描述兴趣爱好 游泳、羽毛球 动漫 音乐（吉他） 料理 写作 新技术（最近在看区块链）","tags":[{"name":"Frontend","slug":"Frontend","permalink":"https://zj-john.github.io/tags/Frontend/"},{"name":"CV","slug":"CV","permalink":"https://zj-john.github.io/tags/CV/"},{"name":"Programmer","slug":"Programmer","permalink":"https://zj-john.github.io/tags/Programmer/"},{"name":"PM","slug":"PM","permalink":"https://zj-john.github.io/tags/PM/"},{"name":"Devops","slug":"Devops","permalink":"https://zj-john.github.io/tags/Devops/"}]},{"title":"一个向GitHub定期自动提交commit的小脚本","date":"2017-09-05T08:32:52.000Z","path":"projects/ckbdbl46900cn2kty88cuxknl.html","text":"偷懒是人类进步的阶梯。 作为一只重度加班狗和强迫症患者，没有时间每天更新GitHub，但是又不能忍受contributions上的空白，所以只能动动脑子，搞点取巧的东西。 目的：定期自动向GitHub发起commit 工具：node, git, schtasks(win), crontab(linux) 难度等级: ★ 项目地址: https://github.com/zj-john/autoCommit 第1步：自动提交git以下三行代码可以完成一次提交123git add --allgit commit -m &quot;update&quot;git push origin master node中写法如下： 12345678910111213141516171819//git目录下新建index.jsconst child_process = require(\"child_process\");//定义一个执行cmd的函数const execCMD = function(cmd)&#123; child_process.exec(cmd, function(error, stdout, stderr) &#123; if(error) &#123; console.error('error: ' + error); return; &#125; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); &#125;)&#125;//用&amp;&amp;连接多条CMD命令const cmd = 'git add --all :/ &amp;&amp; git commit -m \"update\" &amp;&amp; git push origin master';execCMD(cmd); cmd中执行 1node index.js 可以看到执行了一次commit。至此，第一步完成 第2步：更新目录下内容为了让git每一次都有可以提交的commit，需要自动更改目录下的内容。这一步骤大家可以自由发挥，比如建立一个文本文件，内容为当前时间，在每次执行commi前，更新其中的内容等。我这里是写了一个爬虫，在定期commit的同时获取一些信息保存下来，不需要的同学可以直接跳过以下部分了。 以下操作是从 https://github.com/explore 页面爬取本周星数最高，fork最多的git项目，保存到一个txt文本中 1234567891011121314151617181920212223242526272829303132//爬虫const crawler = require('crawler');// 时间处理插件，生成txt文件名称时使用const moment = require('moment');const crawlerUrl = \"https://github.com/explore\";const crawlerMeta = new crawler(&#123; maxConnections: 1, callback: (error, res, done) =&gt; &#123; if (error) &#123; export_to_text(error, \"./error/\" + moment().format(\"YYYY-MM-DDThh-mm-ss\") + '.txt'); &#125; else &#123; let $ = res.$; // 判断是否重定向, 如果页面数量超标的话则会重定向到其他页面 if (res.request.headers.referer == undefined) &#123; var content = []; $('.d-md-flex').find('li').each((i, item) =&gt; &#123; var $item = $(item); var name = $item.find('div').find('a').text(); var desc = $item.find('div').find('p').text(); content.push(&#123; \"name\": name, \"desc\": desc &#125;); &#125;); export_to_text(JSON.stringify(content), './file/' + moment().format(\"YYYY-MM-DDThh-mm-ss\") + '.txt'); &#125; &#125; done(); &#125;&#125;) 第3步：建立计划任务123456789101112131415const child_process = require(\"child_process\");//每8h小时执行一次index.jsconst execCMD = function()&#123; child_process.exec('schtasks /create /tn \"auto-commit\" /tr \"cmd /c node '+ __dirname + '\\\\index.js\" /sc hourly /mo 8 /f', function(error, stdout, stderr) &#123; if(error) &#123; console.error('error: ' + error); return; &#125; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); &#125;)&#125;execCMD(); 后记：以上3步基本完成脚本所需所有功能，需要源码的同学请在 https://github.com/zj-john/autoCommit 自取。 因为工作的电脑是win7的，目前只实现了windows下的自动commit。在mac或linux下使用的小伙伴，请自行修改代码吧。 欢迎贡献代码，一起进步。","tags":[{"name":"node","slug":"node","permalink":"https://zj-john.github.io/tags/node/"},{"name":"github","slug":"github","permalink":"https://zj-john.github.io/tags/github/"},{"name":"schtasks","slug":"schtasks","permalink":"https://zj-john.github.io/tags/schtasks/"},{"name":"contribution","slug":"contribution","permalink":"https://zj-john.github.io/tags/contribution/"}]}]